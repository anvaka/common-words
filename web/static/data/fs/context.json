[{"word":"0000000000000000E","context":[["0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00",1110],["0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00",1110],["0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00",1110],["0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00",1110],["0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00  0.0000000000000000E+00",1110]],"useCount":5550},{"word":"0x0","context":[["let wLangID = 0x0",38],["elif (flags &&& 0x00100000) <> 0x0 then ILTypeInit.BeforeField",22],["| Some blob -> Some (if (flags &&& 0x0001) <> 0x0 then PublicKey blob else PublicKeyToken blob)",22],["else 0x0",24],["if n < padded_len - 8  then 0x0",24],["0x0",31],["| _ -> 0x0",36],["let nochunk next = ({addr= 0x0;size= 0x0; } ,next)",37],["let nochunk next = ({addr= 0x0;size= 0x0; } ,next)",37],["hasMetadata= ((flags &&& 0x0001) = 0x0),",22]],"useCount":2839},{"word":"2drop","context":[["2drop drop",40],["2drop 0 EXIT",37],["2drop 0",37],["drop 2drop",42],["2drop 2drop",73],["2drop 2drop",73],["2drop false",82],["2drop                           \\ | don't do anything",88],["2drop ;",106],["2drop",1000]],"useCount":2166},{"word":"A","context":[["printfn \"%A\" department",97],["///  - `configProcessStartInfoF` - A function which overwrites the default ProcessStartInfo.",82],["printfn \"%A\" ps.Parameters",84],["/// A flag read eagerly from the provided type and used to compute basic properties of the type definition.",85],["﻿// Prime - A PRIMitivEs code library.",88],["printfn \"%A\" employee",103],["A longer description",113],["employees |> Seq.iter (printfn \"%A\")",124],["printfn \"%A\" argv",145],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234]],"useCount":14395},{"word":"AThis","context":[["(\"This\",AThis);",2174]],"useCount":2174},{"word":"AbstractIL","context":[["open Microsoft.FSharp.Compiler.AbstractIL.Diagnostics",606],["open Microsoft.FSharp.Compiler.AbstractIL",679],["open Microsoft.FSharp.Compiler.AbstractIL.Internal",698],["open Microsoft.FSharp.Compiler.AbstractIL.IL",701],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",835],["open Microsoft.FSharp.Compiler.AbstractIL",225],["open Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types",134],["open Microsoft.FSharp.Compiler.AbstractIL.IL",179],["open Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX",180],["open Microsoft.FSharp.Compiler.AbstractIL.Internal",194]],"useCount":5252},{"word":"Add","context":[["ilg.Emit(OpCodes.Add)",65],["/// Add XML documentation information to this provided constructor",217],["membersKnown.Add i",64],["locals.Add(catchVar, exceptionVar)",64],["// TODO : Add assertions for debugging/testing.",64],["/// Add definition location information to the provided type definition.",146],["/// Add XML documentation information to this provided field",66],["blobList.Add( blob )",68],["Array.iter parameters.Add paras",68],["[<CompiledName(\"Add\")>]",86]],"useCount":10859},{"word":"An","context":[["///  - `frame` - An input data frame that is to be filled",27],["/// An implementation type for labelled points on chart. This type should not be used directly.",24],["/// <param name=\"timeout\">An optional timeout parameter (in milliseconds) to wait for a reply message.",28],["/// <param name=\"cancelAction\">An optional function to be executed when a cancellation is requested.</param>",28],["/// <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>",28],["///     An item passed back to 'hasTextChangedSinceLastTypecheck' to help determine if",30],["/// An intermediate definition that represent the point in an implicit class definition where",36],["///  - `series` - An input series that is to be filled",22],["// An ugly bit of code to pre-determine if a type has a nullary constructor, prior to establishing the",36],["///  - `series` - An input series to be resampled",84]],"useCount":1860},{"word":"AnonymousObject","context":[["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`7[T1,T2,T3,T4,T5,T6,T7]: T7 Item7",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`6[T1,T2,T3,T4,T5,T6]: T1 Item1",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`3[T1,T2,T3]: T3 get_Item3()",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`8[T1,T2,T3,T4,T5,T6,T7,T8]: T1 get_Item1()",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`8[T1,T2,T3,T4,T5,T6,T7,T8]: T1 Item1",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`5[T1,T2,T3,T4,T5]: T3 Item3",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`3[T1,T2,T3]: System.String ToString()",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`3[T1,T2,T3]: T2 Item2",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`1[T1]: System.Type GetType()",18],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`3[T1,T2,T3]: T1 Item1",18]],"useCount":1998},{"word":"App","context":[["| SynExpr.App(_exprAtomicFlag, _isInfix, synExpr1, synExpr2, _range) ->",21],["type App() =",46],["| ApplicableExpr(_, Expr.App(Expr.Val(vf,_,_),_,_,[],_),_), _",40],["| Expr.App(Expr.Val(vf,_,_),_,[tyarg],[startExpr;finishExpr],_)",39],["| SynExpr.App (_,_,e1,e2,_) ->",34],["| SynExpr.App (_,_,_,_,m)",31],["| Expr.App(f,fty,tyargs,argsl,m) ->",26],["\"{DB03555F-0C8B-43BE-9FF9-57896B3C5E56}\" // Windows Phone 8/8.1 App (VB.NET)",23],["\"{C089C8C0-30E0-4E22-80C0-CE093F111A43}\" // Windows Phone 8/8.1 App (C#)",23],["open Android.App",85]],"useCount":2327},{"word":"Append","context":[["sb.Append(\"(\").Append(box(x.Item1).ToString()).Append(\",\")",63],["sb.Append(\"(\").Append(box(x.Item1).ToString()).Append(\",\")",63],[".Append(\"; \")",80],["let (~~) (t:string) = sb.Append t |> ignore",119],["sb.Append(\"(\").Append(box(x.Item1).ToString()).Append(\",\")",63],[".Append(box(x.Item2).ToString()).Append(\",\")",54],[".Append(box(x.Item2).ToString()).Append(\",\")",54],[".Append(\"]\")",48],[".Append(box(x.Item3).ToString()).Append(\",\")",45],[".Append(box(x.Item3).ToString()).Append(\",\")",45]],"useCount":5734},{"word":"AreEqual","context":[["Assert.AreEqual(result,10)",88],["Assert.AreEqual(expected, actual)",129],["Assert.AreEqual(enum.MoveNext(), true)",102],["Assert.AreEqual(2, !i)",93],["Assert.AreEqual(42,result)",86],["Assert.AreEqual(1, !i)",69],["Assert.AreEqual(enum.MoveNext(), false)",68],["Assert.AreEqual(y, x)",61],["Assert.AreEqual(convertedForm, internalForm)",54],["| Success(hint, _, _) -> Assert.AreEqual(expected, hint)",56]],"useCount":3637},{"word":"Array","context":[["module Array =",200],["|> Array.ofList",207],["|> Array.ofSeq",308],["|> Array.toList",512],["|> Array.concat",157],["Array.empty",149],["let len = Array.length array",114],["|> Array.rev",103],["|> Array.unzip",97],["let results = Array.zeroCreate len",82]],"useCount":18850},{"word":"Assembly","context":[["| TypeContainer.Type superTy -> superTy.Assembly",64],["let assembly = Assembly.Load(assemblyBytes,null,System.Security.SecurityContextSource.CurrentAppDomain)",65],["| Some f -> Assembly.LoadFrom f",62],["| Namespace of Assembly * string // namespace",63],["| FSharpTypeAbbreviation of (System.Reflection.Assembly * string * string[])",61],["let assemblyLoadedInMemory = assemblyMainModule.Assembly",59],["member __.Assembly = assembly :> Assembly",59],["GlobalProvidedAssemblyElementsTable.theTable.Add(assemblyGenerator.Assembly, theAssemblyBytesLazy)",59],["abstract member ResolveAssembly : args : System.ResolveEventArgs -> Assembly",59],["member __.Assembly = assembly :> Assembly",59]],"useCount":4265},{"word":"AssemblyVersion","context":[["[<assembly: AssemblyVersion(\"1.0.0.0\")>]",1146],["[<assembly: AssemblyVersion(\"1.0.*\")>]",15],["[<assembly: AssemblyVersion(\"1.0.0\")>]",18],["[<assembly: AssemblyVersion(\"1.0.*\")>] *)",25],["[<assembly: AssemblyVersion(\"0.1.0.0\")>]",26],["[<AssemblyVersion(\"1.0.0.0\")>]",27],["// Try to find an AssemblyVersion attribute",48],["[<assembly:AssemblyVersion(\"1.0.0.0\")>]",90],["// [assembly: AssemblyVersion(\"1.0.*\")]",108],["// [<assembly: AssemblyVersion(\"1.0.*\")>]",949]],"useCount":2512},{"word":"Assert","context":[["Assert.Ignore \"Test not yet implemented.\"",592],["Assert.IsNotEmpty(r)",201],["Assert.Fail(log)",178],["Assert.AreEqual(2, !i)",93],["Assert.AreEqual(enum.MoveNext(), true)",102],["Assert.IsTrue(this.ErrorsExist)",106],["Assert.True(result)",108],["| _ -> Assert.Fail()",114],["Assert.AreEqual(expected, actual)",129],["| Failure(message, _, _) -> Assert.Fail(message)",168]],"useCount":11575},{"word":"Ast","context":[["open Ast",46],["open FSharpLint.Framework.Ast",39],["let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : Ast.SynExpr)) in",37],["let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : Ast.SynExpr)) in",34],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : Ast.SynExpr)) in",43],["open Microsoft.FSharp.Compiler.Ast",729],["open Ast",167],["open Microsoft.FSharp.Compiler.Ast",105],["module Ast",62],[": Ast.SynExpr));",102]],"useCount":1925},{"word":"Async","context":[["|> Async.AwaitTask",149],["module Async =",94],["let! ct = Async.CancellationToken",105],["} |> Async.Start",117],["|> Async.Start",117],["let wholeProjectResults = checker.ParseAndCheckProject(Project1.options) |> Async.RunSynchronously",127],["} |> Async.RunSynchronously",195],["|> Async.Ignore",246],["|> Async.Parallel",574],["|> Async.RunSynchronously",2171]],"useCount":8119},{"word":"Attribs","context":[["vspec.Attribs",28],["({ Attribs = attribs; Name = nm } : ArgReprInfo)",20],["// INCOMPLETENESS: Attribs is empty here, so we can't look at attributes for",22],["let argInfo : ArgReprInfo = { Name=nmOpt; Attribs= [] }",24],["match TryFindFSharpAttribute g args tcref.Attribs with",26],["v.Attribs |> CheckAttribs cenv env;",26],["// INCOMPLETENESS: Attribs is empty here, so we can't look at return attributes for .NET or F# methods",33],["CheckFSharpAttributes g x.Attribs m",34],["let retInfo : ArgReprInfo = { Name=None; Attribs= [] }",36],["let showDeprecated = HasFSharpAttribute ncenv.g ncenv.g.attrib_RequireQualifiedAccessAttribute tycon.Attribs",36]],"useCount":2678},{"word":"AttributeTargets","context":[["[<AttributeUsage(AttributeTargets.Method,AllowMultiple=false)>]",35],["[<AttributeUsage (AttributeTargets.Method,AllowMultiple=false)>]",36],["[<AttributeUsage(AttributeTargets.Class,AllowMultiple=false)>]",36],["[<AttributeUsage(AttributeTargets.Property, AllowMultiple = false)>]",30],["[<AttributeUsage (AttributeTargets.Field,AllowMultiple=false)>]",27],["[<AttributeUsage (AttributeTargets.Class,AllowMultiple=false)>]",106],["[<AttributeUsage(AttributeTargets.All,AllowMultiple=false)>]",45],["[<AttributeUsage (AttributeTargets.All,AllowMultiple=false)>]",45],["[<AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)>]",55],["[<AttributeUsage (AttributeTargets.Class,AllowMultiple=false)>]",70]],"useCount":1900},{"word":"Attributes","context":[["member __.Attributes =",73],["override this.Attributes = (base.Attributes ||| (if isOut then ParameterAttributes.Out else enum 0)",46],["let attributes = adjustTypeAttributes ntd.Attributes true",64],["// Attributes, etc..",64],["override __.Attributes = if parameterDefaultValue.IsNone then enum 0 else ParameterAttributes.Optional",63],["let attributes = pt.Attributes &&& ~~~(enum (int32 TypeProviderTypeAttributes.SuppressRelocate))",58],["let eb = tb.DefineEvent(evt.Name, evt.Attributes, evt.EventHandlerType)",51],["override this.Attributes = PropertyAttributes.None",46],["member Attributes: IList<FSharpAttribute>",63],["override this.Attributes = methodAttrs",46]],"useCount":1963},{"word":"AutoOpen","context":[["[<AutoOpen; CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",24],["[<AutoOpen>]",256],["// Add the CCU and apply the \"AutoOpen\" attributes",15],["/// Add a set of module or namespace to the name resolution environment, including any sub-modules marked 'AutoOpen'",15],["﻿[<AutoOpen>]",643],["[<AutoOpen>]",4049],["[<assembly: AutoOpen(\"Microsoft.FSharp.Compiler.Interactive.Settings\")>]",14],["[<assembly: AutoOpen(\"Microsoft.FSharp\")>]",14],["//[<AutoOpen>]",13],["/// Add a list of module or namespace to the name resolution environment, including any sub-modules marked 'AutoOpen'",12]],"useCount":5066},{"word":"Boolean","context":[["Microsoft.FSharp.Quotations.PatternsModule: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice3Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean IsChoice5Of7",28],["Microsoft.FSharp.Core.FSharpChoice`3+Choice3Of3[T1,T2,T3]: Boolean IsChoice3Of3",28],["Microsoft.FSharp.Core.FSharpChoice`4+Choice1Of4[T1,T2,T3,T4]: Boolean IsChoice3Of4",28],["Microsoft.FSharp.Core.CLIEventAttribute: Boolean Match(System.Object)",28],["Microsoft.FSharp.Core.FSharpRef`1[T]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Collections.Array2DModule: Boolean Equals(System.Object)",28],["\"name\", upcast \"Boolean\"",30],["Microsoft.FSharp.Core.FSharpChoice`2+Choice1Of2[T1,T2]: Boolean Equals(Microsoft.FSharp.Core.FSharpChoice`2[T1,T2])",28],["Microsoft.FSharp.Core.ExtraTopLevelOperators: Boolean Equals(System.Object)",28]],"useCount":21649},{"word":"Build","context":[["open Microsoft.FSharp.Compiler.Build",53],["let tool = new Microsoft.FSharp.Build.Fsc()",98],["open Microsoft.Build.Utilities",93],["// You can specify all the values or you can default the Build and Revision Numbers",1037],["//       Build Number",918],["// The assembly version has the format {Major}.{Minor}.{Build}.{Revision}",300],["group Build",230],["open Microsoft.Build.Framework",93],["//      Build Number",129],["<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",113]],"useCount":5611},{"word":"C","context":[["(\"C\", \"file1\", ((9, 15), (9, 16)), [\"class\"]);",44],["type C() =",173],["C \"\"\"",74],["(\"C\", \"M.C\", \"file1\", ((9, 15), (9, 16)), [\"class\"]);",72],["(\"C\", \"M.C\", \"file1\", ((9, 15), (9, 16)), [\"class\"]);",72],["\".ctor: Microsoft.FSharp.Core.unit -> TestTP.Helper.C\"",45],["// to C<_> occurs then generate C<?ty> for a fresh type inference variable ?ty.",40],["let c = C()",31],["[ \"m\"; \"kg\"; \"s\"; \"A\"; \"K\"; \"mol\"; \"cd\"; \"Hz\"; \"N\"; \"Pa\"; \"J\"; \"W\"; \"C\"",37],["// to C<_> occurs then generate C<?ty> for a fresh type inference variable ?ty.",40]],"useCount":4793},{"word":"CG","context":[["let endOfHandler = CG.GenerateMark cgbuf \"endOfHandler\"",57],["CG.SetMarkToHere cgbuf afterHandler;",35],["CG.SetStack cgbuf [cenv.g.ilg.typ_Object];",39],["CG.SetStack cgbuf [];",48],["let startOfHandler = CG.GenerateMark cgbuf \"startOfHandler\"",57],["CG.SetMarkToHere cgbuf inplab;",52],["let afterJoin = CG.GenerateDelayMark cgbuf (pos + \"_join\")",48],["CG.EmitInstr cgbuf (pop 1) (Push [cenv.g.ilg.typ_Exception]) (I_castclass cenv.g.ilg.typ_Exception);",33],["let endScope = CG.GenerateDelayMark cgbuf (\"end_\" + nm)",32],["CG.EmitInstrs cgbuf",32]],"useCount":3122},{"word":"COM","context":[["/// Marshalling map for parameters. COM Interop only.",17],["IsComInterop: bool; (* Class or interface generated for COM interop *)",19],["// CallerSide optional arguments are largely for COM interop, e.g. to PIA assemblies for Word etc.",20],["// to COM components.  If you need to access a type in this assembly from",997],["// このプロジェクトが COM に公開される場合、次の GUID がタイプ ライブラリの ID になります",35],["// COM, set the ComVisible attribute to true on that type.",997],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["COM, set the ComVisible attribute to true on that type. *)",23],["to COM components.  If you need to access a type in this assembly from",23],["// not provide anything useful. To enable interop with some legacy COM APIs,",20]],"useCount":3296},{"word":"Call","context":[["// Call the recursive implementation.",216],["ilg.Emit(OpCodes.Call,cinfo)",116],["// Call the recursive implementation function.",72],["ilg.Emit(OpCodes.Call, meth)",63],["Quotations.Expr.Call(minfo, Array.toList parameters)",60],["Quotations.Expr.Call(parameters.[0], minfo, Array.toList parameters.[1..])",59],["ilg.Emit(OpCodes.Call, mappedMeth)",58],["if tagMeth.IsStatic then trans (Quotations.Expr.Call(tagMeth, [e]))",55],["| Quotations.Patterns.Call (objOpt,meth,args) ->",55],["trans (Quotations.Expr.Call(Reflection.FSharpValue.PreComputeUnionConstructorInfo ci, es) )",55]],"useCount":2064},{"word":"CallingConvention","context":[["[<DllImport(DllName, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)>]",142],["[<DllImport(dll, CallingConvention=calling, ExactSpelling=exact, SetLastError=last)>]",73],["[<DllImport(@\"SDL2.dll\", CallingConvention = CallingConvention.Cdecl)>]",738],["[<DllImport(@\"SDL2.dll\", CallingConvention = CallingConvention.Cdecl)>]",738],["[<DllImport(DllName, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)>]",142],["[<DllImport(\"libzmq\",CallingConvention = CallingConvention.Cdecl)>]",112],["[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]",125],["[<DllImportAttribute(GLFW_DLL, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)>]",75],["[<DllImportAttribute(GLFW_DLL, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)>]",75],["[<DllImport(\"libzmq\",CallingConvention = CallingConvention.Cdecl)>]",112]],"useCount":2908},{"word":"Castle","context":[["Castle.Windsor (2.1)",105],["Castle.Windsor (>= 2.0)",81],["Castle.Core (>= 3.3.0)",109],["nuget Castle.Windsor-log4net ~> 3.2",132],["nuget Castle.Core-log4net",149],["Castle.Windsor (3.3.0)",59],["getVersion resolved.[PackageName \"Castle.Windsor\"] |> shouldEqual \"3.2.1\"",76],["nuget Castle.Core-log4net ~> 3.2",75],["nuget \"Castle.Windsor-log4net\" \"~> 3.2\"",65],["(\"Castle.Core\",\"3.2.0\");",59]],"useCount":3562},{"word":"Category","context":[["[<Trait(\"Category\", \"Skip_CI\")>]",55],["[<Test; Category(\"Clone\")>]",120],["[<Test; Category(\"Generic BCL Types\")>]",112],["[<Category(\"TypeProvider\")>]",86],["[<Category(\"Materials\")>]",72],["[<Test; Category(\"FSharp type tests\")>]",69],["[<Test; Category(\"FsPickler Generic tests\")>]",67],["[<Test ; Category(\"Custom types\")>]",64],["[<Test; Category(\"Primitives\")>]",58],["[<Test; Category(\"Pickler tests\")>]",52]],"useCount":1929},{"word":"Check","context":[["// Check if we have a codepage from the console",40],["// Check the structural dependencies",40],["Check.QuickThrowOnFail(f, maxRuns = __.FsCheckMaxNumberOfTests, shrink = false)",37],["Check.QuickThrowOnFail(f, self.FsCheckMaxNumberOfTests)",139],["Check.QuickThrowOnFail(checker, maxRuns = __.FsCheckMaxTests)",60],["// Check it isn't ruled out by the user",54],["constant bigendian?   ( -- flag = Check for bigendian hardware )",51],["Check.QuickThrowOnFailure <|",50],["// Check the (possibly inferred) structural dependencies",36],["Check.QuickThrowOnFail(f, self.FsCheckMaxNumberOfIOBoundTests)",40]],"useCount":4597},{"word":"Choice1Of2","context":[["Microsoft.FSharp.Core.FSharpChoice`2+Choice1Of2[T1,T2]: Boolean Equals(Microsoft.FSharp.Core.FSharpChoice`2[T1,T2])",28],["Microsoft.FSharp.Core.FSharpChoice`2+Choice1Of2[T1,T2]: Boolean get_IsChoice2Of2()",28],["Microsoft.FSharp.Core.FSharpChoice`2+Choice1Of2[T1,T2]: System.Type GetType()",28],["Choice1Of2 state",30],["| Choice1Of2 _ ->",37],["| Choice1Of2 value ->",38],["| Choice1Of2 () ->",47],["| Choice1Of2 result ->",90],["|> Choice1Of2",126],["Microsoft.FSharp.Core.FSharpChoice`2+Choice1Of2[T1,T2]: Int32 Tag",28]],"useCount":1995},{"word":"Choice2Of2","context":[["| Choice2Of2 e -> raise e",34],["| Choice2Of2 e ->",156],["| Choice2Of2 error ->",111],["| ex -> Choice2Of2 ex.Message",36],["with e -> Choice2Of2 e",53],["| Choice2Of2 result ->",34],["| Choice2Of2 err -> raise err",31],["| Choice2Of2 err ->",94],["|> Choice2Of2",52],["Choice2Of2 error",175]],"useCount":2175},{"word":"Class","context":[["and [<AllowNullLiteral; Class; Sealed>]",40],["let lambda = assemblyMainModule.DefineType(uniqueLambdaTypeName(), TypeAttributes.Class)",50],["| Class",62],["[<Class>]",288],["type Class() =",175],["TypeAttributes.Class |||",121],["[<Class>]",117],["[<AttributeUsage (AttributeTargets.Class,AllowMultiple=false)>]",106],["type Class() = class end",71],["[<AttributeUsage (AttributeTargets.Class,AllowMultiple=false)>]",70]],"useCount":2106},{"word":"Close","context":[["cbox   Close the current box",54],["if con.State = ConnectionState.Open then con.Close()",54],["conn.Close()",51],["x.Close()",48],["let expr = mbuilder.Close(dtree,m,tyOfExpr g e2)",56],["stream.Close ()",71],["stream.Close()",86],["con.Close()",103],["/// Close All Active Connection, to be called when the program gets shutdown.",103],["buf.Close()",112]],"useCount":2105},{"word":"Collections","context":[["open Microsoft.FSharp.Collections",174],["open System.Collections.ObjectModel",173],["open Internal.Utilities.Collections",195],["open FSharpx.Collections",209],["interface System.Collections.IEnumerable with",286],["open System.Collections.Generic",340],["open Microsoft.FSharp.Collections",558],["open System.Collections.Concurrent",780],["open System.Collections",963],["open System.Collections.Generic",5952]],"useCount":23685},{"word":"Color","context":[["vec3 Color;",36],["|> Helpers.ApplyStyles(?Name=Name,?Title=Title,?Color=Color,?AxisXTitle=XTitle,?AxisYTitle=YTitle)",388],["|> Helpers.ApplyStyles(?Name=Name,?Title=Title,?Color=Color,?AxisXTitle=XTitle,?AxisYTitle=YTitle)",388],["type Color =",32],["return Color / Attenuation;",24],["with get() = x.GetCustomProperty<ColorWrapper>(\"PriceUpColor\", ColorWrapper(Color.Empty)).Color",20],["with get() = x.GetCustomProperty<ColorWrapper>(\"PriceUpColor\", ColorWrapper(Color.Empty)).Color",20],["Color = Colors.defaultColorscheme.Foreground",17],["in vec3 Color;",17],["/// <param name=\"Color\">The color for the data.</param>",753]],"useCount":2238},{"word":"ComVisible","context":[["(* Setting ComVisible to false makes the types in this assembly not visible",23],["[<assembly: ComVisible(false)>]",1179],["// COM, set the ComVisible attribute to true on that type.",997],["// Setting ComVisible to false makes the types in this assembly not visible",997],["[<assembly: System.Runtime.InteropServices.ComVisible(false)>]",72],["// ComVisible を false に設定すると、COM コンポーネントがこのアセンブリ内のその型を認識",35],["// その型の ComVisible 属性を true に設定します。",35],["[<assembly:ComVisible(false)>]",30],["COM, set the ComVisible attribute to true on that type. *)",23],["[<assembly: ComVisible (false)>]",18]],"useCount":3449},{"word":"Combine","context":[["let oldWeavers = Path.Combine(originalScenarioPath scenario,\"MyClassLibrary\",\"MyClassLibrary\",\"FodyWeavers.xml\")",42],["let outPath = Path.Combine(scenarioTempPath scenario,\"out\")",30],["let config1Path = Path.Combine(path, \"Project1\", \"app.config\")",30],["/// Combines two path strings using Path.Combine",34],["let path = Path.Combine(Path.GetTempPath(), fName)",39],["let fileName = FileInfo(Path.Combine(Path.GetTempPath(), zippedNuspec.Name)).FullName",42],["let newWeavers = Path.Combine(scenarioTempPath scenario,\"MyClassLibrary\",\"MyClassLibrary\",\"FodyWeavers.xml\")",42],["let newFile = Path.Combine(scenarioTempPath scenario,\"MyClassLibrary\",\"MyClassLibrary\",\"MyClassLibrary.csproj\")",42],["|> Seq.map (fun f -> IO.Path.Combine(f, expectedName))",57],["let config4Path = Path.Combine(path, \"Project4\", \"app.config\")",30]],"useCount":3326},{"word":"Common","context":[["open Yard.Generators.Common.AST",71],["open Common",265],["Common.QueryEvents.PublishSqlQuery cmd.CommandText",168],["open System.Data.Common",159],["open AbstractAnalysis.Common",106],["#load \"../Common/FsUnit.fs\"",103],["open Fooble.Common",96],["#load \"Common.fs\"",81],["open FSharp.Data.Sql.Common",73],["open FSharp.Compiler.Service.Tests.Common",65]],"useCount":2238},{"word":"CompareTo","context":[["(t :> IStructuralComparable).CompareTo(other, (HashCompare.fsComparer :> System.Collections.IComparer))",42],["member x.CompareTo yobj =",78],["override t.CompareTo (other:obj,comparer:System.Collections.IComparer) =",72],["override t.CompareTo(other:obj) =",72],["member this.CompareTo that =",65],["member this.CompareTo other =",58],["Microsoft.FSharp.Core.FSharpChoice`7+Choice5Of7[T1,T2,T3,T4,T5,T6,T7]: Int32 CompareTo(System.Object)",28],["/// Gets any implicit CompareTo methods added to an F# record, union or struct type definition.",34],["member x.CompareTo other =",32],["Microsoft.FSharp.Core.FSharpChoice`6+Choice4Of6[T1,T2,T3,T4,T5,T6]: Int32 CompareTo(System.Object)",28]],"useCount":2465},{"word":"CompilationRepresentation","context":[["// members when usinging CompilationRepresentation.Static, or any non-virtual instance members",19],["﻿[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",19],["[<AutoOpen; CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",24],["[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",55],["[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",1610],["[<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",337],["[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",281],["[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",191],["[<CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)>]",97],["[<RequireQualifiedAccess; CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",58]],"useCount":2702},{"word":"CompilationRepresentationFlags","context":[["[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",191],["[<CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)>]",97],["Microsoft.FSharp.Core.CompilationRepresentationFlags: Microsoft.FSharp.Core.CompilationRepresentationFlags ModuleSuffix",28],["[<RequireQualifiedAccess; CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",58],["[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",281],["[<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",337],["[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",1610],["[<CompilationRepresentationAttribute(CompilationRepresentationFlags.ModuleSuffix)>]",30],["[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",55],["Microsoft.FSharp.Core.CompilationRepresentationFlags: Microsoft.FSharp.Core.CompilationRepresentationFlags None",28]],"useCount":3352},{"word":"CompiledName","context":[["[<CompiledName(\"Fold\")>]",212],["[<CompiledName(\"Map\")>]",277],["[<CompiledName(\"Iterate\")>]",230],["[<CompiledName(\"FoldBack\")>]",143],["[<CompiledName(\"Filter\")>]",142],["[<CompiledName(\"MapIndexed\")>]",126],["[<CompiledName(\"IsEmpty\")>]",108],["[<CompiledName(\"Choose\")>]",116],["[<CompiledName(\"IterateIndexed\")>]",124],["[<CompiledName(\"Exists\")>]",125]],"useCount":11820},{"word":"Compiler","context":[["open Microsoft.FSharp.Compiler.AbstractIL.Diagnostics",606],["open Microsoft.FSharp.Compiler",1015],["open Microsoft.FSharp.Compiler.Range",842],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",835],["open Microsoft.FSharp.Compiler.Ast",729],["open Microsoft.FSharp.Compiler.AbstractIL.IL",701],["open Microsoft.FSharp.Compiler.AbstractIL.Internal",698],["open Microsoft.FSharp.Compiler.AbstractIL",679],["open Microsoft.FSharp.Compiler.SourceCodeServices",637],["open Microsoft.FSharp.Compiler.ErrorLogger",611]],"useCount":17788},{"word":"CompilerServices","context":[["member b.Product (m1,m2) = typedefof<Core.CompilerServices.MeasureProduct<_,_>>.MakeGenericType [| m1;m2 |]",45],["member b.Inverse m = typedefof<Core.CompilerServices.MeasureInverse<_>>.MakeGenericType [| m |]",45],["(typeof<Core.CompilerServices.MeasureOne>.Assembly,",55],["open Microsoft.FSharp.Core.CompilerServices",66],["type CustomAttributeData = Microsoft.FSharp.Core.CompilerServices.IProvidedCustomAttributeData",74],["[<System.Runtime.CompilerServices.Extension>]",325],["member this.RegisterRuntimeAssemblyLocationAsProbingFolder (cfg : Core.CompilerServices.TypeProviderConfig) =",42],["member b.One = typeof<Core.CompilerServices.MeasureOne>",46],["open Microsoft.FSharp.Core.CompilerServices",442],["open System.Runtime.CompilerServices",2445]],"useCount":6757},{"word":"Console","context":[["Console.WriteLine()",83],["Console.ReadLine() |> ignore",162],["System.Console.ReadKey() |> ignore",87],["Console.ResetColor()",86],["System.Console.ReadLine() |> ignore",85],["Console.ReadKey() |> ignore",81],["Console.ReadLine()",52],["Console.ReadLine () |> ignore",37],["Console.ForegroundColor <- ConsoleColor.Red",35],["Console.WriteLine(\"\")",34]],"useCount":2309},{"word":"Const","context":[["| Const.Int32 _",86],["| SynExpr.Const(_,m)",47],["| Expr.Const _ -> ()",39],["| Test.Const c ->",38],["| [] -> SynExpr.Const(SynConst.Unit,m)",38],["| Expr.Const _",38],["| Expr.Const(c,m,ty) ->",38],["PushOnePatternToRhs cenv true (SynPat.Const(SynConst.Unit,m)) rhsExpr,",36],["open FStar.Const",89],["| Const.Zero _",35]],"useCount":11010},{"word":"ConstValue","context":[["| ConstValue(Const.Int16 a1,_),ConstValue(Const.Int16 a2,_) -> mkBoolVal g (a1 < a2)",12],["| ConstValue(Const.Int16 a1,_),ConstValue(Const.Int16 a2,_) -> mkBoolVal g (a1 < a2)",12],["| ConstValue(Const.Int32 a,_),ConstValue(Const.Int32 n,_) when n >= 0 && n <= 31 -> (mkInt32Val g (a >>> n))",12],["| ConstValue(Const.Int32 a,_),ConstValue(Const.Int32 n,_) when n >= 0 && n <= 31 -> (mkInt32Val g (a >>> n))",12],["| ConstValue(Const.SByte  a,_),ConstValue(Const.Int32 n,_) when n >= 0 && n <= 7  -> (mkInt8Val   g (a <<< n))",12],["| ConstValue(Const.UInt32 a,_) -> mkUInt16Val g (Unchecked.uint16 a)",12],["| ConstValue(Const.Int32  a,_) -> mkUInt8Val g (Unchecked.byte a)",12],["| ConstValue _ | CurriedLambdaValue _ | ConstExprValue _ -> false",12],["let mkInt64Val g n = ConstValue(Const.Int64 n, g.int64_ty)",12],["| ConstValue(_,ty) when",24]],"useCount":2244},{"word":"Constants","context":[["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"Newtonsoft.Json\"].Version",37],["dependencies.Groups.[Constants.MainDependencyGroup].RemoteFiles",152],["module Constants =",43],["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"Castle.Windsor\"].Version",47],["let p = cfg.Groups.[Constants.MainDependencyGroup].Packages |> List.find (fun x-> x.Name = PackageName \"Foobar\")",52],["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"NUnit\"].Version",57],["| None -> Constants.MainDependencyGroup",97],["|> LockFileSerializer.serializePackages cfg.Groups.[Constants.MainDependencyGroup].Options",115],["cfg.Groups.[Constants.MainDependencyGroup].Options.Strict |> shouldEqual false",121],["cfg.GetDependenciesInGroup(Constants.MainDependencyGroup).Count |> shouldEqual 4",39]],"useCount":2713},{"word":"Contains","context":[["assumedTycons.Contains tcref.Stamp",40],["let token = results.Contains <@ ConfigArgs.AddToken @>",32],["if unitNamesTypeAbbreviations.Contains mLowerCase then",38],["elif unitSymbolsTypeAbbreviations.Contains m then",38],["(if initialAssumedTycons.Contains tcref.Stamp then",40],["if assumedTyparsActual.Contains(tp.Stamp) then",40],["﻿/// Contains NuGet support.",44],["[<CompiledName(\"Contains\")>]",49],["|> List.filter (fun tcref -> not (tcref.LogicalName.Contains(\",\")))",60],["s1.Contains \"FodyWeavers.xml\" |> shouldEqual true",101]],"useCount":4502},{"word":"ContainsKey","context":[["buckets.[key] <- (rest,v) :: (if buckets.ContainsKey key then buckets.[key] else []);",68],["assert_true (exprCtxt.ContainsKey \"soma_limit\")",36],["let field = match field with :? ProvidedField as pf when fieldMap.ContainsKey pf -> fieldMap.[pf] :> FieldInfo | m -> m",80],["if usedPackages.ContainsKey k |> not then",40],["let n = (if basicNameCounts.ContainsKey basicName then basicNameCounts.[basicName] else 0)",42],["let priorType = if typeMapExtra.ContainsKey(fullName) then Some typeMapExtra.[fullName]  else None",58],["assert ctorMap.ContainsKey pcinfo",64],["| :? ProvidedConstructor as pcinfo when not (ctorMap.ContainsKey pcinfo)  ->",63],["| :? ProvidedMethod as pminfo when not (methMap.ContainsKey pminfo)  ->",63],["if typeMap.ContainsKey ptd then typeMap.[ptd] :> Type else ty",63]],"useCount":2360},{"word":"Control","context":[["open FSharp.Control.Reactive",41],["namespace Microsoft.FSharp.Control",33],["namespace Microsoft.FSharp.Control",36],["open Yaaf.FSharp.Control",36],["inherit Web.Control()",41],["type Microsoft.FSharp.Control.Async with",65],["open ExtCore.Control.Collections",66],["open FSharp.Control",79],["open ExtCore.Control",138],["open Microsoft.FSharp.Control",182]],"useCount":3833},{"word":"Core","context":[["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",195],["Microsoft.FSharp.Core.Operators.box",3597],["open MBrace.Core.Internals",544],["open MBrace.Core",510],["open Microsoft.FSharp.Core",449],["open Microsoft.FSharp.Core.CompilerServices",442],["open Microsoft.FSharp.Core.Operators",304],["open Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators",269],["open Microsoft.FSharp.Core",268],["[<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]",208]],"useCount":74391},{"word":"Count","context":[["if chooseNode.ChildNodes.Count > 0 then",48],["| _ when propertyChooseNode.ChildNodes.Count = 0 -> path",48],["member __.Count",42],["if interfaceImplsDelayed.Count > 0 then",61],["if membersQueue.Count > 0 then",64],["[<CompiledName(\"Count\")>]",63],["if v.Count = 0 then   // if no columns exist in the projection then get everything",46],["elif sqlQuery.Count then ~~(\"SELECT COUNT(1) \")",46],["let singleEntity = sqlQuery.Aliases.Count = 0",46],["marked.Add(obj, marked.Count)",43]],"useCount":3392},{"word":"Create","context":[["entity_tycon_tcaug=TyconAugmentation.Create()",71],[".Create()",355],["let tcConfig = TcConfig.Create(tcConfigB,validate=false)",184],["let checker = FSharpChecker.Create()",69],["TcConfig.Create(tcConfigB,validate=false)",69],["[<CompiledName(\"Create\")>]",68],["/// Create a new provided type. It is not initially associated with any specific provided type definition.",67],["/// Create a new provided field. It is not initially associated with any specific provided type definition.",66],["let props = applySpawnOptions (Props.Create e) options",64],["static member Create() =",63]],"useCount":7060},{"word":"Current","context":[["let first = e.Current",42],["let uiContext = SynchronizationContext.Current",42],["let ctx = System.Threading.SynchronizationContext.Current",47],["checkThrowsInvalidOperationExn(fun () -> enum.Current |> ignore)",48],["body enum.Current)))",63],["member x.Current =",70],["let _ = e.Current",80],["CheckThrowsInvalidOperationExn(fun () -> enum.Current |> ignore)",128],["CleanUp.Current.CleanUpAll()",91],["ContractStoreAtProgram.Current.RegisterContractToDaemon( name, info, bReload,",35]],"useCount":1901},{"word":"CustomAttrs","context":[["CustomAttrs = emptyILCustomAttrs;",76],["CustomAttrs=seekReadCustomAttrs ctxt (TaggedIndex(hca_ExportedType, i)) }",36],["CustomAttrs: ILAttributes;",38],["CustomAttrs=emptyILCustomAttrs }",66],["CustomAttrs = emptyILCustomAttrs }",72],["CustomAttrs=emptyILCustomAttrs;",75],["CustomAttrs: ILAttributes }",85],["CustomAttrs: ILAttributes; }",85],["CustomAttrs: ILAttributes }",95],["CustomAttrs: ILAttributes; }",95]],"useCount":2529},{"word":"DEBUG","context":[["// The following DEBUG code does not currently compile.",15],["stdout-loglevel = DEBUG",16],["#if DEBUG",2517],["// DEBUG layout - types",19],["// DEBUG layout",19],["// DEBUG layout - bind, expr, dtree etc.",19],["ignore exn // use the argument, even in non DEBUG",20],["checkOption options.OtherOptions \"--define:DEBUG\"",22],["//#if DEBUG",36],["#if DEBUG",128]],"useCount":2887},{"word":"Data","context":[["open System.Data.Common",159],["open FSharp.Data",693],["open System.Data",457],["open System.Data.SqlClient",166],["open FSharp.Data.Runtime",150],["type philosophyType = XmlProvider<\"../../FSharp.Data.Tests/Data/Philosophy.xml\">",120],["type AtomSearch = XmlProvider<\"../../FSharp.Data.Tests/Data/search.atom.xml\", SampleIsList=true>",120],["type AtomSearch = XmlProvider<\"../../FSharp.Data.Tests/Data/search.atom.xml\", SampleIsList=true>",120],["type philosophyType = XmlProvider<\"../../FSharp.Data.Tests/Data/Philosophy.xml\">",120],["// FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs",105]],"useCount":10554},{"word":"DateTime","context":[["let _ = DateTime.Now",186],["|> forEntity \"System\" \"System.DateTime\"",102],["let start = System.DateTime.Now",76],["type DateTime() = class end",48],["| _ -> DateTime.MinValue",57],["let bbb = DateTime(2011, 1, 23, 12, 13, 14)",58],["{ F: DateTime }",60],["let t1 = (DateTime.UtcNow)",70],["|> forIdent \"DateTime\"",126],["let t2 = (DateTime.UtcNow)",70]],"useCount":3008},{"word":"Debug","context":[["System.Diagnostics.Debug.Assert(false, \"Error while determining default location of F# compiler\")",36],["// FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs",105],["open Internal.Utilities.Debug",79],["System.Diagnostics.Debug.Assert(false, msg)",78],["/// FSharp.Data addition: this method is used by Debug.fs",73],["System.Diagnostics.Debug.Assert (false, msg)",63],["// FSharp.Data addition: this method is used by Debug.fs and QuotationBuilder.fs",38],["System.Diagnostics.Debug.Assert(false, \"empty list\")",38],["[<assembly: AssemblyConfiguration(\"Debug\")>]",41],["// FSharp.Data addition: this method is used by Debug.fs",38]],"useCount":1838},{"word":"DeclareResourceString","context":[["let IndeterminateTypeE() = DeclareResourceString(\"IndeterminateType\",\"\")",20],["let ConstraintSolverMissingConstraintE() = DeclareResourceString(\"ConstraintSolverMissingConstraint\",\"%s\")",20],["let NONTERM_exconCoreE() = DeclareResourceString(\"NONTERM.exconCore\",\"\")",20],["let NonRigidTypar2E() = DeclareResourceString(\"NonRigidTypar2\",\"%s%s\")",20],["let NONTERM_typeNameInfoE() = DeclareResourceString(\"NONTERM.typeNameInfo\",\"\")",20],["let LetRecEvaluatedOutOfOrderE() = DeclareResourceString(\"LetRecEvaluatedOutOfOrder\",\"\")",20],["let InvalidRuntimeCoercionE() = DeclareResourceString(\"InvalidRuntimeCoercion\",\"%s%s%s\")",20],["let NONTERM_hashDirectiveE() = DeclareResourceString(\"NONTERM.hashDirective\",\"\")",20],["let SeeAlsoE() = DeclareResourceString(\"SeeAlso\",\"%s\")",20],["let NONTERM_hardwhiteLetBindingsE() = DeclareResourceString(\"NONTERM.hardwhiteLetBindings\",\"\")",20]],"useCount":3088},{"word":"DeclaringType","context":[["[| yield Quotations.Var(\"this\", pcinfo.DeclaringType)",51],["let logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);",52],["let tagInfo = Reflection.FSharpValue.PreComputeUnionTagMemberInfo uc.DeclaringType",63],["match convType meth.DeclaringType with",52],["let gdty = convType (meth.DeclaringType.GetGenericTypeDefinition())",53],["yield Quotations.Var(\"this\", pminfo.DeclaringType)",56],["override this.DeclaringType =",57],["(if this.DeclaringType.IsGenericType then this.DeclaringType.GetGenericArguments().Length else 0) < parameters.Length",58],["(if this.DeclaringType.IsGenericType then this.DeclaringType.GetGenericArguments().Length else 0) < parameters.Length",58],["elif meth.DeclaringType.IsGenericType then",59]],"useCount":2132},{"word":"Default","context":[["{ UpdaterOptions.Default with",82],["Default.Int32()",36],["static member Default =",136],["Default.Arrow()",88],["static member Default : ProvidedMeasureBuilder",36],["static member Default = {",39],["let typeNameResInfo = TypeNameResolutionInfo.Default",45],["Default=None;",49],["| Default",59],["static member Default = theBuilder",64]],"useCount":1948},{"word":"DependenciesFile","context":[["let cfg = DependenciesFile.FromCode(after)",100],["let cfg = DependenciesFile.FromCode(config)",200],["let dependencies = DependenciesFile.FromCode(config)",181],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://nuget.org/api/v2",139],["let dependenciesFile = DependenciesFile.ReadFromFile dependenciesFileName",112],["let cfg = DependenciesFile.FromCode(config1)",98],["let dependenciesFile = DependenciesFile.ReadFromFile(dependenciesFileName)",78],["let lockFileName = DependenciesFile.FindLockfile dependenciesFileName",63],["let cfg = DependenciesFile.FromCode(config2)",51],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://www.nuget.org/api/v2",147]],"useCount":2375},{"word":"Deref","context":[["|> List.filter (fun v -> not v.Deref.IsClassConstructor)",33],["let tycon = tcref.Deref",112],["let _,typ = if tcref.Deref.IsExceptionDecl then [],cenv.g.exn_ty else generalizeTyconRef tcref",60],["member x.Tycon = x.TyconRef.Deref",40],["let c = tyconOrder.Compare (tcref1.Deref, tcref2.Deref)",38],["let c = tyconOrder.Compare (tcref1.Deref, tcref2.Deref)",38],["let v = vref.Deref",129],["tcref.Deref",38],["match metadataOfTycon entity.Deref with",35],["match metadataOfTycon tcref.Deref with",35]],"useCount":5297},{"word":"Diagnostics","context":[["let sw = new System.Diagnostics.Stopwatch()",362],["let ptime = System.Diagnostics.Process.GetCurrentProcess()",45],["let watch = new System.Diagnostics.Stopwatch()",43],["let sw = System.Diagnostics.Stopwatch()",39],["open Microsoft.FSharp.Compiler.AbstractIL.Diagnostics",606],["System.Diagnostics.Debug.Assert(false, msg)",78],["open System.Diagnostics.CodeAnalysis",68],["open System.Diagnostics",2178],["let sw = System.Diagnostics.Stopwatch.StartNew()",52],["System.Diagnostics.Debug.Assert (false, msg)",63]],"useCount":5273},{"word":"Dictionary","context":[["let typeMapExtra = Dictionary<string,TypeBuilder>(HashIdentity.Structural)",58],["emitExpr(ilg, new Dictionary<_, _>(), [||]) ExpectedStackState.Empty expr",46],["let copyOfLocals = Dictionary()",46],["/// <param name=\"dictionary\">Dictionary to be updated.</param>",49],["let typeMap = Dictionary<ProvidedTypeDefinition,TypeBuilder>(HashIdentity.Reference)",58],["let locals = Dictionary<Quotations.Var,LocalBuilder>()",105],["let buckets = new Dictionary<_,_>(10)",74],["let ctorMap = Dictionary<ProvidedConstructor, ConstructorBuilder>(HashIdentity.Reference)",63],["let methMap = Dictionary<ProvidedMethod, MethodBuilder>(HashIdentity.Reference)",63],["let theTable = Dictionary<Assembly, Lazy<byte[]>>()",58]],"useCount":2877},{"word":"DisplayEnv","context":[["//solveTypAsError cenv env.DisplayEnv m overallTy",39],["CallExprHasTypeSink cenv.tcSink (m,env.NameEnv,overallTy, env.DisplayEnv,env.eAccessRights)",108],["TcRuntimeTypeTest (*isCast*)false cenv env.DisplayEnv m tgty srcTy",28],["let denv = env.DisplayEnv",158],["let denv = csenv.DisplayEnv",260],["let domainTy,resultTy = UnifyFunctionType None cenv env.DisplayEnv m overallTy",36],["member DisplayEnv : DisplayEnv",31],["member DisplayEnv : DisplayEnv",31],["CallNameResolutionSink cenv.tcSink (id.idRange,env.NameEnv,argItem,argItem,ItemOccurence.Use,env.DisplayEnv,ad)",24],["AddCxMethodConstraint env.DisplayEnv cenv.css m NoTrace traitInfo",36]],"useCount":3864},{"word":"DisplayName","context":[["let nm = bind.Var.DisplayName",40],["| Item.ExnCase tcref -> tcref.DisplayName",36],["mkSynCall methInfo.DisplayName mOpCore",36],["[ for x in wholeProjectResults.AssemblySignature.Entities.[0].MembersFunctionsAndValues -> x.DisplayName ]",38],["member x.DisplayName =",39],["set [ for x in wholeProjectResults.AssemblySignature.Entities -> x.DisplayName ] |> shouldEqual (set [\"M\"])",33],["|> List.choose (fun tyconRef -> if tyconRef.IsILTycon then Some tyconRef.DisplayName else None)",30],["v.DisplayName",80],["|> List.choose (fun (tycon:Tycon) -> if tycon.IsILTycon then Some tycon.DisplayName else None)",30],["v.DisplayName) |> ignore",80]],"useCount":3759},{"word":"Dispose","context":[["member __.Dispose() =",332],["member this.Dispose() = this.Dispose()",63],["override x.Dispose() =",66],["registration.Dispose()",66],["(docEventListener :> IDisposable).Dispose()",86],["member x.Dispose() = x.Dispose()",103],["member x.Dispose() = x.Dispose()",103],["member x.Dispose() = ()",156],["member this.Dispose() =",215],["member x.Dispose() =",647]],"useCount":4347},{"word":"DllImport","context":[["[<DllImport(lib)>]",183],["[<DllImport(lib);SuppressUnmanagedCodeSecurity>]",187],["[<DllImport(@\"SDL2.dll\", CallingConvention = CallingConvention.Cdecl)>]",738],["[<DllImport(DllName, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)>]",142],["[<DllImport(\"nvcuda.dll\")>]",130],["[<DllImport(\"libzmq\",CallingConvention = CallingConvention.Cdecl)>]",112],["[<DllImport(\"kernel32.dll\")>]",84],["[<DllImport(dll, CallingConvention=calling, ExactSpelling=exact, SetLastError=last)>]",73],["[<DllImport(\"Advapi32.dll\", CharSet = CharSet.Unicode, BestFitMapping = false)>]",60],["[<DllImport(\"user32.dll\", SetLastError = true)>]",55]],"useCount":2200},{"word":"DotNetFramework","context":[["FrameworkRestriction.Exactly(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V3_5))",34],["| \"net46\" -> Some (DotNetFramework FrameworkVersion.V4_6)",24],["| \"net451\" -> Some (DotNetFramework FrameworkVersion.V4_5_1)",24],["[FrameworkRestriction.Exactly(DotNetFramework(FrameworkVersion.V4_5))",29],["|> shouldEqual ([FrameworkRestriction.Exactly(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V2))",34],["FrameworkRestriction.AtLeast(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V4_Client))])",34],["| \"net45\" | \"net45-full\" | \"45\" -> Some (DotNetFramework FrameworkVersion.V4_5)",24],["| DotNetFramework FrameworkVersion.V3_5 -> [ DotNetFramework FrameworkVersion.V3 ]",24],["| \"net40-full\" | \"net403\" -> Some (DotNetFramework FrameworkVersion.V4)",24],["| DotNetFramework FrameworkVersion.V3_5 -> [ DotNetFramework FrameworkVersion.V3 ]",24]],"useCount":1875},{"word":"ELSE","context":[["[ELSE]",924],["ELSE                            \\ ELSE",43],["ELSE                            \\ Else",37],["// REVIEW: for IL properties this is getter OR setter. For F# properties it is getter ELSE setter",34],["| ELSE",29],["ELSE                                    \\ ELSE",96],["ELSE                                    \\ ELSE",96],["ELSE                            \\ ELSE",43],["ELSE",3625],["[ [ELSE] ]",64]],"useCount":5583},{"word":"EXTENSIONTYPING","context":[["#if EXTENSIONTYPING",4122],["#if EXTENSIONTYPING",219]],"useCount":4341},{"word":"Emit","context":[["ilg.Emit(OpCodes.Ret)",139],["x.Emit(op,v)",128],["ilg.Emit(OpCodes.Call,cinfo)",116],["ilg.Emit OpCodes.Ret",116],["ilg.Emit(OpCodes.Readonly)",121],["ilg.Emit(OpCodes.Br, before)",122],["ilg.Emit(OpCodes.Ldloc, lb)",122],["ilg.Emit(OpCodes.Stloc, lb)",122],["ilg.Emit(OpCodes.Ldarg_0)",251],["open System.Reflection.Emit",264]],"useCount":7700},{"word":"EmitAndLog","context":[["| BI_bne_un  -> ilG.EmitAndLog(OpCodes.Bne_Un ,envGetLabel emEnv targ)",16],["| AI_cgt                      -> ilG.EmitAndLog(OpCodes.Cgt)",16],["| BI_ble     -> ilG.EmitAndLog(OpCodes.Ble    ,envGetLabel emEnv targ)",16],["| DT_I8  -> ilG.EmitAndLog(OpCodes.Conv_I8)",16],["| I_initobj   typ             -> ilG.EmitAndLog(OpCodes.Initobj  ,convType cenv emEnv  typ)",16],["| DT_U2  -> ilG.EmitAndLog(OpCodes.Ldelem_U2)",16],["| DT_I4  -> ilG.EmitAndLog(OpCodes.Conv_Ovf_I4_Un)",16],["| I_ldloc  u16                -> ilG.EmitAndLog(OpCodes.Ldloc ,int16 u16)",16],["ilG.EmitAndLog(OpCodes.Call,meth)",48],["| DT_I1  -> ilG.EmitAndLog(OpCodes.Conv_I1)",16]],"useCount":2882},{"word":"Empty","context":[["| Empty -> true",74],["viewResult.ViewName =! String.Empty",84],["[<CompiledName(\"Empty\")>]",106],["emit ExpectedStackState.Empty body",112],["static member Empty =",251],["// Empty Seq",132],["| Empty -> ()",126],["| Empty ->",414],["Empty",144],["| Empty",207]],"useCount":7854},{"word":"EnclosingType","context":[["member x.EnclosingType =",72],["member EnclosingType: ILType",34],["member x.IsValueType = isStructTy x.TcGlobals x.EnclosingType",34],["let tgty = rfinfo.EnclosingType",40],["if isSuperInit then CG.EmitInstrs cgbuf (pop 0) (Push [ilMethSpec.EnclosingType]) [ mkLdarg0 ] ;",22],["| P m -> FSharpEntity(cenv,  tcrefOfAppTy cenv.g m.EnclosingType)",22],["mspec.EnclosingType",22],["| E m -> FSharpEntity(cenv,  tcrefOfAppTy cenv.g m.EnclosingType)",22],["member x.EnclosingType = let (OverridesSpec(_mr,ty)) = x in ty",24],["| Item.CtorGroup (_, (cinfo :: _)) -> 1000 + 10 * (tcrefOfAppTy g cinfo.EnclosingType).TyparsNoRange.Length",27]],"useCount":1928},{"word":"EntryPoint","context":[["//[<EntryPoint>]",60],["(*[<EntryPoint>]",15],["[<EntryPoint>]",1991],["[<DllImport(\"mscoree.dll\", SetLastError = true, PreserveSig=false, EntryPoint=\"CreateInterface\")>]",16],["// NOTE: MonoSymbolWriter doesn't need information about entrypoints, so 'info.EntryPoint' is unused here.",15],["fprintfn sw \"ENTRYPOINT\\r\\n  %b\\r\\n\" info.EntryPoint.IsSome",15],["﻿[<EntryPoint>]",33],["match info.EntryPoint with",18],["// Does the function have an explicit [<EntryPoint>] attribute?",16],["Users can (now) annotate their own functions with EntryPoint attributes.",16]],"useCount":2253},{"word":"Environment","context":[["Environment.ExitCode <- 1",83],["traceError (\"  \" + String.Join(\" \",Environment.GetCommandLineArgs()))",47],["let argv = System.Environment.GetCommandLineArgs()",54],["(Environment.NewLine,",34],["|> String.concat Environment.NewLine",36],["String.Join(Environment.NewLine, all |> List.map (fun s -> s.TrimEnd()))",36],["// Environment is needed for completions",38],["| _ -> failwithf \"invalid %s specification:%s     %s\" originTxt Environment.NewLine trimmed",42],["let separator = if asLines then Environment.NewLine else \", \"",43],["match Environment.OSVersion.Platform with",44]],"useCount":2501},{"word":"Equals","context":[["override t.Equals (other:obj,comparer:System.Collections.IEqualityComparer) =",63],["override t.Equals(other:obj) =",72],["override this.Equals(that) =",89],["override this.Equals(that:obj) =",94],["override x.Equals(yobj) =",102],["override x.Equals(obj:obj) =",103],["override x.Equals(other : obj) =",108],["override x.Equals o =",57],["override Equals : obj -> bool",55],["(t :> IStructuralEquatable).Equals(other,HashCompare.fsEqualityComparer)",48]],"useCount":9180},{"word":"Error","context":[["errorR(Error(FSComp.SR.parsInvalidLiteralInType(), m))",54],["Logger.Log( LogLevel.Error, msg )",457],["| _ -> raise <| Error.wrongArity ()",289],["| Error",122],["errorR(Error(FSComp.SR.tcInvalidRelationInJoin(nm.idText),relExpr.Range))",72],["error (Error(FSComp.SR.nrGlobalUsedOnlyAsFirstName(), id.idRange))",68],["if nonNil otherDelayed then error(Error(FSComp.SR.tcInvalidAssignment(),mStmt))",64],["| _ -> raise <| Error.errExpectedX \"symbol\"",63],["| _ -> Command.Error",62],["| Error of string",55]],"useCount":16679},{"word":"Event","context":[["override this.MemberType : MemberTypes = MemberTypes.Event",43],["| Item.Event einfo ->",84],["let invalidateE = new Event<EventHandler,EventArgs>()",64],["let ev = Event<_>()",66],["inherit Event",78],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["[| for m in this.GetMembers bindingAttr do if m.MemberType.HasFlag(MemberTypes.Event) then yield downcast m |]",63],["|> Array.filter(fun m -> m.MemberType.HasFlag(MemberTypes.Event) && (name = null || m.Name = name))",63],["let ev = new Event<_>()",55],["let tagsChanged = Event<_, _>()",50]],"useCount":2321},{"word":"Exception","context":[["| Exception err -> Exception err",31],["raise <| Exception(\"\", e)",98],["| ResultOrException.Exception e -> ResultOrException.Exception e",60],["| ResultOrException.Exception e -> ResultOrException.Exception e",60],["match err.Exception with",59],["inherit Exception",32],["| {Exception = (:? TypeProviderError as tpe)} ->",36],["inherit Exception()",40],["cont.Exception ctx (ExceptionDispatchInfo.Capture se)",44],["Exception = None",50]],"useCount":2677},{"word":"Exists","context":[["if not force && targetFile.Exists && targetFile.Length > 0L then",57],["[<CompiledName(\"Exists\")>]",46],["|> addAttribute \"Condition\" (sprintf \"Exists('%s')\" fileName)",48],["if dir.Exists then",50],["if not di.Exists then",52],["[<CompiledName(\"Exists\")>]",125],["if File.Exists fileName then",99],["if not force && targetFile.Exists then",66],["|> Seq.tryFind IO.File.Exists",59],["if fi.Exists then",43]],"useCount":2046},{"word":"ExpectedStackState","context":[["let s = if e.Type.IsValueType then ExpectedStackState.Address else ExpectedStackState.Value",176],["emit ExpectedStackState.Value a2",92],["emit ExpectedStackState.Value v",100],["emit ExpectedStackState.Empty body",112],["emit ExpectedStackState.Value e",112],["emit ExpectedStackState.Value arr",112],["emit ExpectedStackState.Value pe",112],["emit ExpectedStackState.Value index",112],["emit ExpectedStackState.Value cond",112],["let s = if e.Type.IsValueType then ExpectedStackState.Address else ExpectedStackState.Value",176]],"useCount":1984},{"word":"Expr","context":[["| Expr.Op (c,tyargs,args,m) ->",64],["| Expr.LetRec (binds,e,m,_) ->",66],["override pe.Expr = expr }",72],["with set (q:Quotations.Expr list -> Quotations.Expr) =",104],["let mutable invokeCode    = None : option<Quotations.Expr list -> Quotations.Expr>",104],["with set  (q:Quotations.Expr list -> Quotations.Expr) =",104],["let mutable invokeCode    = None : option<Quotations.Expr list -> Quotations.Expr>",104],["with set (q:Quotations.Expr list -> Quotations.Expr) =",104],["[| for v in parameterVars -> Quotations.Expr.Var v |]",107],["with set  (q:Quotations.Expr list -> Quotations.Expr) =",104]],"useCount":27309},{"word":"Extension","context":[["fi.Name.Replace(fi.Extension, \"\")",32],["/// Describes the sequence order of the introduction of an extension method. Extension methods that are introduced",32],["[<Extension; Inline>]",967],["[<Extension>]",399],["[<System.Runtime.CompilerServices.Extension>]",325],["[<AbstractClass; Sealed; Extension>]",83],["[<Extension;Sealed>]",77],["( Extension words )",57],["[<Extension; EditorBrowsable(EditorBrowsableState.Never)>]",54],["[<Extension>]",3203]],"useCount":5748},{"word":"Extensions","context":[["<Reference Include=\"System.Net.Http.Extensions\">",163],["open Hopac.Extensions",47],["open Brahma.FSharp.OpenCL.Extensions",51],["@\"..\\Microsoft.Net.Http\\lib\\net45\\System.Net.Http.Extensions.dll\"",55],["@\"..\\Microsoft.Net.Http\\lib\\net40\\System.Net.Http.Extensions.dll\"",55],["open Extensions",61],["open Xunit.Extensions",74],["module Extensions =",94],["open Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types",134],["open Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX",180]],"useCount":1967},{"word":"F","context":[["﻿// Learn more about F# at http://fsharp.net",172],["///<code lang=\"F#\">",156],["[<CompilerMessage(\"This method is not intended for use from F#.\", 10001, IsHidden=true, IsError=false)>]",132],["// See the 'F# Tutorial' project for more help.",208],["///<code lang=\"F#\">",220],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234],["[<assembly: AssemblyProductAttribute(\"FAKE - F# Make\")>]",273],["member this.X = \"F#\"",121],["[| (5, 'a'); (3, 'b'); (11, 'f'); (2, 'd'); (17, 'a'); (4, 'g'); (12, 'b'); (14, 'c'); (11, 'F'); (4, 'G'); |]",84],["﻿// Learn more about F# at http://fsharp.org",78]],"useCount":15130},{"word":"FAKE","context":[["(\"FAKE\",\"4.0.0\");",87],["[<assembly: AssemblyProductAttribute(\"FAKE - F# Make\")>]",273],["nuget FAKE",296],["github fsharp/FAKE src/app/FakeLib/Globbing/Globbing.fs",62],["﻿// Auto-Generated by FAKE; do not edit",62],["Name = \"src/app/FAKE/Cli.fs\"",77],["nuget \"FAKE\" \"~> 3.0\"",83],["Project = \"FAKE\"",190],["nuget FAKE\"\"\")",139],["nuget FAKE = 1.1",88]],"useCount":2668},{"word":"FSComp","context":[["errorR(Error(FSComp.SR.tcInvalidRelationInJoin(nm.idText),relExpr.Range))",72],["errorR(Error(FSComp.SR.parsInvalidLiteralInType(), m))",54],["error(Error(FSComp.SR.tcExpectedUnitOfMeasureNotType(), m))",54],["if nonNil otherDelayed then error(Error(FSComp.SR.tcInvalidAssignment(),mStmt))",64],["error(Error(FSComp.SR.tcAttributesInvalidInPatterns(),m))",54],["errorR(Error(FSComp.SR.tcOperatorIncorrectSyntax(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",54],["| [] -> error(Error(FSComp.SR.nrUnexpectedEmptyLongId(),m))",51],["| [] -> raze (UndefinedName(depth,FSComp.SR.undefinedNameType,id,[]))",46],["errorR(Error(FSComp.SR.tcCannotInheritFromErasedType(),m))",54],["error (Error(FSComp.SR.nrGlobalUsedOnlyAsFirstName(), id.idRange))",68]],"useCount":16412},{"word":"FSharp","context":[["(fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->",2648],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",835],["open Microsoft.FSharp.Reflection",744],["open Microsoft.FSharp.Compiler.Ast",729],["open Microsoft.FSharp.Compiler.AbstractIL.IL",701],["open Microsoft.FSharp.Compiler",1015],["open Microsoft.FSharp.Quotations",1072],["open Microsoft.FSharp.Compiler.AbstractIL.Internal",698],["Microsoft.FSharp.Core.Operators.box",3597],["open Microsoft.FSharp.Compiler.Range",842]],"useCount":118153},{"word":"FSharpChoice","context":[["Microsoft.FSharp.Core.FSharpChoice`6[T1,T2,T3,T4,T5,T6]: Boolean get_IsChoice6Of6()",28],["Microsoft.FSharp.Core.FSharpChoice`5+Choice5Of5[T1,T2,T3,T4,T5]: Boolean get_IsChoice3Of5()",28],["Microsoft.FSharp.Core.FSharpChoice`3+Choice1Of3[T1,T2,T3]: Int32 GetHashCode()",28],["Microsoft.FSharp.Core.FSharpChoice`3[T1,T2,T3]: Microsoft.FSharp.Core.FSharpChoice`3+Choice3Of3[T1,T2,T3]",28],["Microsoft.FSharp.Core.FSharpChoice`4+Choice3Of4[T1,T2,T3,T4]: Boolean IsChoice1Of4",28],["Microsoft.FSharp.Core.FSharpChoice`3+Choice1Of3[T1,T2,T3]: Boolean IsChoice1Of3",28],["Microsoft.FSharp.Core.FSharpChoice`5+Choice3Of5[T1,T2,T3,T4,T5]: Int32 Tag",28],["Microsoft.FSharp.Core.FSharpChoice`3[T1,T2,T3]: Microsoft.FSharp.Core.FSharpChoice`3+Choice3Of3[T1,T2,T3]",28],["Microsoft.FSharp.Core.FSharpChoice`4+Tags[T1,T2,T3,T4]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice7Of7[T1,T2,T3,T4,T5,T6,T7]: T7 get_Item()",28]],"useCount":21633},{"word":"FSharpFunc","context":[["let predicate = FSharpFunc<_,_,_>.Adapt predicate",64],["let folder = FSharpFunc<_,_,_>.Adapt folder",100],["let f = OptimizedClosures.FSharpFunc<_,_,_,_>.Adapt(f)",130],["// Eliminate F# function applications to FSharpFunc<_,_>.Invoke calls",64],["let action = FSharpFunc<_,_,_>.Adapt action",120],["let folder = FSharpFunc<_,_,_,_>.Adapt folder",148],["let mapping = FSharpFunc<_,_,_>.Adapt mapping",132],["let mapping = FSharpFunc<_,_,_,_>.Adapt mapping",88],["let f = FSharpFunc<_,_,_>.Adapt(f)",71],["let f = OptimizedClosures.FSharpFunc<_,_,_>.Adapt(f)",305]],"useCount":3245},{"word":"FSharpList","context":[["Microsoft.FSharp.Collections.FSharpList`1[T]: System.Type GetType()",28],["Microsoft.FSharp.Collections.FSharpList`1+Tags[T]: Int32 GetHashCode()",28],["Microsoft.FSharp.Collections.FSharpList`1[T]: Int32 CompareTo(System.Object, System.Collections.IComparer)",28],["Microsoft.FSharp.Collections.ListModule: T Average[T](Microsoft.FSharp.Collections.FSharpList`1[T])",28],["Microsoft.FSharp.Collections.FSharpList`1[T]: Microsoft.FSharp.Collections.FSharpList`1[T] TailOrNull",28],["Microsoft.FSharp.Collections.FSharpList`1[T]: T get_Item(Int32)",28],["Microsoft.FSharp.Collections.FSharpList`1[T]: Microsoft.FSharp.Collections.FSharpList`1[T] get_TailOrNull()",28],["/// The compiled name of the namespace, module or type, e.g. FSharpList`1, ListModule or FailureException",34],["Microsoft.FSharp.Collections.ListModule: Microsoft.FSharp.Collections.FSharpList`1[T] OfArray[T](T[])",28],["Microsoft.FSharp.Collections.ArrayModule: Microsoft.FSharp.Collections.FSharpList`1[T] ToList[T](T[])",28]],"useCount":1918},{"word":"FStar","context":[["module SS = FStar.Syntax.Subst",50],["open FStar.Range",61],["open FStar.Syntax",80],["open FStar.Absyn",83],["open FStar.Const",89],["open FStar.Absyn.Syntax",94],["open FStar.Syntax.Syntax",106],["open FStar.Ident",151],["open FStar",256],["open FStar.Util",258]],"useCount":2079},{"word":"Fact","context":[["//[<Fact>]",160],["[<Fact(Skip=\"No type handy\")>]",15],["[<Fact(Skip=\"cant do right now\")>] //issue 23",21],["//    [<Fact>]",23],["[<Fact>] //issue 23",73],["[<Fact>]",9145],["[<Fact>] member test.",67],["[<Fact>] //issue 30",44],["[<Fact>] //issue 25",25],["//    [<Fact>] member test.",28]],"useCount":9643},{"word":"Fail","context":[["| _ ->  Assert.Fail()",76],["Assert.Fail(log)",178],["| Failure(message, _, _) -> Assert.Fail(message)",168],["| _ -> Assert.Fail()",114],["| Failure s -> Assert.Fail s",90],["Assert.Fail()",86],["if resultEpt <> [| |] then Assert.Fail()",44],["Assert.Fail(\"Expectt overflow exception but not.\")",52],["| _ -> Assert.Fail(\"Expectt overflow exception but not.\")",52],["if e.MoveNext() then Assert.Fail()",60]],"useCount":2104},{"word":"File","context":[["\"\"\"module File",72],["let s2 = File.ReadAllText newFile |> normalizeLineEndings",514],["let assemblyBytes = File.ReadAllBytes assemblyFileName",64],["|> assertSrcAreEqual \"\"\"module File",84],["if File.Exists fileName then",99],["let s2 = File.ReadAllText newWeavers |> normalizeLineEndings",116],["let s1 = File.ReadAllText oldWeavers |> normalizeLineEndings",116],["File:",301],["File.WriteAllText(fileName1, fileSource1)",495],["let s1 = File.ReadAllText oldFile |> normalizeLineEndings",514]],"useCount":5730},{"word":"FileName","context":[["let filename = m.FileName",38],["with exn -> failwithf \"Start of process %s failed. %s\" proc.StartInfo.FileName exn.Message",42],["{ FileName = templateFile.FileName",44],["{ FileName = templateFile.FileName",44],["let root = Path.GetDirectoryName dependenciesFile.FileName",46],["{ FileName: string",47],["member __.FileName = fileName",52],["info.FileName <- parameters.ToolPath",169],["info.FileName <- tool",50],["let m = mkRange m.FileName (mkPos m.StartLine (m.StartColumn + 1)) (mkPos m.EndLine (m.EndColumn + 1) )",54]],"useCount":3107},{"word":"FlatList","context":[["| null -> FlatList.Empty",42],["fsCheck \"FlatList\" (Prop.forAll (Arb.fromGen flatlistIntGen)",24],["match FlatList.toList patvs with",48],["module FlatList =",48],["let evalue' = AbstractExprInfoByVars (FlatList.toList vs,[]) einfo.Info",22],["and Bindings = FlatList<Binding>",18],["and FlatVals = FlatList<Val>",18],["let bindsR = FlatList.zip vsR (binds |> FlatList.map (fun b -> b.Expr |> ConvExpr cenv env))",20],["let bindsR = FlatList.zip vsR (binds |> FlatList.map (fun b -> b.Expr |> ConvExpr cenv env))",20],["let args = List.rev (FlatList.toList args)",20]],"useCount":2120},{"word":"For","context":[["| SynExpr.For (spBind,id,start,dir,finish,innerComp,m) ->",40],["match Visibilities.For (actor conn).Id with",195],["// the first key. For each bucket, call 'nodef' on that head key and the bucket.",79],["// For the further information contact <mailto:david.sorokin@gmail.com>.",62],["// For the further information contact <mailto:david.sorokin@gmail.com>.",57],["/// <remarks>Performs the operation in parallel using System.Threading.Parallel.For.",56],["// For example",48],["For most experiments with the implementation, it should not be",47],["| SynExpr.For (_,_,_,_,_,_,m)",47],["| SynExpr.For _",41]],"useCount":4423},{"word":"Force","context":[["| Force -> \"Forces the download and reinstallation of all packages.\"",92],["[<Parameter>] member val Force = SwitchParameter() with get, set",54],["[| yield! customAttributesOnce.Force()",64],["member __.ConstructorArguments = upcast [| CustomAttributeTypedArgument(typeof<string>, lazyText.Force())  |]",63],["failwith (sprintf \"ProvidedTypeDefinition: static parameters supplied but not expected for %s\" (fullName.Force()))",60],["| true,bytes -> bytes.Force()",59],["| [<AltCommandLine(\"-f\")>] Force",141],["let patvs,_env = varSpace.Force comp.Range",54],["if x.Force.IsPresent then",54],["override this.Namespace = rootNamespace.Force()",46]],"useCount":2584},{"word":"Format","context":[["open FSharp.Compatibility.OCaml.Format",56],["See the documentation for the Format module in the OCaml library for",54],["os.Append(SeeAlsoE().Format (stringOfRange m)) |> ignore)",36],["os.Append(SeeAlsoE().Format (stringOfRange m)) |> ignore )",36],["request.Headers.[HttpRequestHeader.Authorization] <- String.Format(\"Basic {0}\", credentials)",28],["// Format each argument, including its name and type",27],["let hours = notZero (span.Duration().Hours) <| String.Format(\"{0:0} hour{1}, \", span.Hours, pluralize span.Hours)",24],["os.Append(ErrorFromAddingTypeEquation1E().Format t2 t1 tpcs) |> ignore",24],["let formatted = String.Format(\"{0}{1}{2}{3}\", days, hours, minutes, seconds)",24],["static member Format =",62]],"useCount":3812},{"word":"Framework","context":[["open NUnit.Framework",4596],["open Microsoft.Xna.Framework",133],["open Microsoft.Xna.Framework.Graphics",101],["open Microsoft.Build.Framework",93],["open FSharpLint.Framework.Configuration",84],["[<NUnit.Framework.TestFixture>]",69],["open Microsoft.Xna.Framework.Input",66],["open NUnit.Framework.Constraints",51],["open IQ.Core.Framework",49],["﻿[<NUnit.Framework.TestFixture>]",43]],"useCount":5921},{"word":"FrameworkRestriction","context":[["| FrameworkRestriction.Portable _ -> []",51],["FrameworkRestriction.AtLeast(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V4_Client))])",34],["|> List.filter (fun (r:FrameworkRestriction) ->",31],["FrameworkRestriction.Exactly(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V3_5))",34],["FrameworkRestriction.AtLeast r",31],["|> shouldEqual ([FrameworkRestriction.Exactly(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V2))",34],["| FrameworkRestriction.Exactly r ->",43],["| FrameworkRestriction.Exactly r -> r",46],["yield n,v,[FrameworkRestriction.Exactly r]",30],["[FrameworkRestriction.Exactly(DotNetFramework(FrameworkVersion.V4_5))",29]],"useCount":1950},{"word":"FrameworkVersion","context":[["| \"net10\" | \"net1\" | \"10\" -> Some (DotNetFramework FrameworkVersion.V1)",24],["[FrameworkRestriction.Exactly(DotNetFramework(FrameworkVersion.V4_5))",29],["type FrameworkVersion =",30],["| \"net40\" | \"net4\" | \"40\" | \"net40-client\" | \"net4-client\" -> Some (DotNetFramework FrameworkVersion.V4_Client)",24],["| DotNetFramework FrameworkVersion.V4 -> [ DotNetFramework FrameworkVersion.V4_Client ]",24],["| DotNetFramework FrameworkVersion.V4_Client -> [ DotNetFramework FrameworkVersion.V3_5 ]",24],["FrameworkRestriction.Exactly(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V3_5))",34],["|> shouldEqual ([FrameworkRestriction.Exactly(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V2))",34],["FrameworkRestriction.AtLeast(FrameworkIdentifier.DotNetFramework(FrameworkVersion.V4_Client))])",34],["FxTarget = FrameworkVersion \"v4.5\"",32]],"useCount":2298},{"word":"FsUnit","context":[["FsUnit.fs (7623fc13439f0e60bd05c1ed3b5f6dcb937fe468)",20],["remote: forki/FsUnit",20],["#r \"../../packages/FsUnit/lib/net45/FsUnit.NUnit.dll\"",25],["#r \"../../packages/FsUnit/lib/net45/FsUnit.NUnit.dll\"",25],["github forki/FsUnit FsUnit.fs\"\"\"",49],["open FsUnit.Xunit",314],["open FsUnit",2045],["github forki/FsUnit FsUnit.fs\"\"\"",49],["#load \"FsUnit.fs\"",89],["#load \"../Common/FsUnit.fs\"",103]],"useCount":2822},{"word":"FullName","context":[["//printfn \"looking up assembly '%s'\" assembly.FullName",59],["| _ -> failwith (sprintf \"There is more than one nested type called '%s' in type '%s'\" name this.FullName)",60],["override this.ToString() = this.FullName",81],["/// .NET symbolic types made from this type, e.g. when building Nullable<SomeProvidedType[]>.FullName",65],["| SymbolKind.Pointer,[arg] -> arg.FullName + \"*\"",56],["| _ -> failwith (sprintf \"ApplyStaticArguments: static params for type %s are unexpected\" ty.FullName)",62],["member FullName: string",56],["let pk = pkLookup.[entity.Table.FullName]",57],["| TypeContainer.Type declaringType -> declaringType.FullName + \"+\" + className",63],["let tb = assemblyMainModule.DefineType(name=pt.FullName,attr=attributes)",58]],"useCount":4930},{"word":"Generate","context":[["MetadataFormat.Generate",35],["/// Generate an indirect call, converting to an ILX callfunc instruction",32],["expected |> treeDump.Generate |> string |> printfn \"%s\"",24],["///Generate arbitrary uint32 that is uniformly distributed in the whole range of uint32 values.",24],["/// Generate a distributed dataset through customerized seq functional delegates running on each of the machine.",22],["//             // Generate indices into the array (up to the number of elements)",22],["// Generate the (value,expr) pairs for the implicit",20],["// Generate extra bindings fo object expressions with bindings using the CLIEvent attribute",20],["assemblyGenerator.Generate(theTypes |> Seq.toList)",58],["member __.Generate(providedTypeDefinitions:(ProvidedTypeDefinition * string list option) list) =",58]],"useCount":2052},{"word":"Generic","context":[["open System.Collections.Generic",5952],["| SymbolKind.Generic gty,_ -> gty",56],["| Generic of System.Type",63],["Generic (Id \"list\",[Var (Normal \"a\")]))",64],["[<Test; Category(\"FsPickler Generic tests\")>]",67],["{ new System.Collections.Generic.IEqualityComparer<_> with",72],["raise <| System.Collections.Generic.KeyNotFoundException ()",98],["| Generic gtd ->",104],["open System.Collections.Generic",340],["[<Test; Category(\"Generic BCL Types\")>]",112]],"useCount":10003},{"word":"Get","context":[["/// Get the syntactic range of source code covered by this construct.",38],["let tcConfig = tcConfigP.Get()",181],["/// Get or set a flag indicating if the property is static.",108],["/// Get ParameterInfo[] for the parametric type parameters (//s GetGenericParameters)",83],["/// Get the type parameters for an entity that is a type declaration, otherwise return the empty list.",68],["/// Get a blob of data indicating how this type is nested inside other namespaces, modules and types.",63],["[<CompiledName(\"Get\")>]",63],["let name = if isAddress expectedState then \"Address\" else \"Get\"",60],["// Get or set instance IL field",40],["/// Get the flags as included in the F# binary metadata",40]],"useCount":9666},{"word":"GetCustomAttributes","context":[["override this.GetCustomAttributes(_inherit)                  = notRequired \"GetCustomAttributes\" this.Name",169],["override this.GetCustomAttributes(_attributeType, _inherit)   = notRequired \"GetCustomAttributes\" this.Name",169],["override __.GetCustomAttributes(_inherit) = ignore(_inherit); notRequired \"GetCustomAttributes\" parameterName",63],["override __.GetCustomAttributes(_inherit) = ignore(_inherit); notRequired \"GetCustomAttributes\" parameterName",63],["override this.GetCustomAttributes(_attributeType, _inherit)      =  notRequired \"GetCustomAttributes\" this.Name",85],["override this.GetCustomAttributes(_inherit)                     = notRequired \"GetCustomAttributes\" this.Name",85],["override this.GetCustomAttributes(_inherit)                     = notRequired \"GetCustomAttributes\" this.Name",85],["override this.GetCustomAttributes(_attributeType, _inherit)      =  notRequired \"GetCustomAttributes\" this.Name",85],["override this.GetCustomAttributes(_attributeType, _inherit)   = notRequired \"GetCustomAttributes\" this.Name",169],["override this.GetCustomAttributes(_inherit)                  = notRequired \"GetCustomAttributes\" this.Name",169]],"useCount":2341},{"word":"GetCustomAttributesData","context":[["override this.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",311],["override __.GetCustomAttributesData() = p.GetCustomAttributesData()",59],["member __.GetCustomAttributesDataImpl() = customAttributesImpl.GetCustomAttributesData()",476],["override __.GetCustomAttributesData() = p.GetCustomAttributesData()",59],["override __.GetCustomAttributesData() = customAttributesImpl.GetCustomAttributesData()",61],["override __.GetCustomAttributesData() = customAttributesImpl.GetCustomAttributesData()",61],["member __.GetCustomAttributesData() =",64],["override __.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",129],["override __.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",129],["override this.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",311]],"useCount":1831},{"word":"GetEnumerator","context":[["let enum = ie.GetEnumerator()",88],["use e1 = source1.GetEnumerator()",46],["seq { use e = source.GetEnumerator()",46],["this.Using (sequence.GetEnumerator (), fun enum ->",46],["member this.GetEnumerator() =",130],["use ie = source.GetEnumerator()",102],["member this.GetEnumerator () =",64],["member x.GetEnumerator(): System.Collections.IEnumerator =",46],["member x.GetEnumerator() =",154],["use e = source.GetEnumerator()",308]],"useCount":2242},{"word":"GetHashCode","context":[["override t.GetHashCode() =",76],["override x.GetHashCode() =",156],["override __.GetHashCode() = assert false; x.GetHashCode()",104],["override __.GetHashCode() = assert false; x.GetHashCode()",104],["override this.GetHashCode() = rootNamespace.GetHashCode() ^^^ className.GetHashCode()",48],["override this.GetHashCode() =",91],["(t :> IStructuralEquatable).GetHashCode(HashCompare.fsUnlimitedHasher)",48],["override this.GetHashCode() = rootNamespace.GetHashCode() ^^^ className.GetHashCode()",48],["override x.GetHashCode() = hashCode",58],["override t.GetHashCode(comparer:System.Collections.IEqualityComparer) =",72]],"useCount":7484},{"word":"GetType","context":[["let rty = right.GetType()",30],["typeof<TypeBuilder>.Assembly.GetType(typeName)",32],["typedefof<list<int>>.Assembly.GetType(\"Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.\" + mLowerCase)",37],["let ty = x.GetType()",38],["let tyOfValue = value.GetType()",61],["Microsoft.FSharp.Core.MatchFailureException: System.Type GetType()",56],["let runningOnMono = try System.Type.GetType(\"Mono.Runtime\") <> null with e -> false",44],["| _ when aty.IsAssignableFrom(obj.GetType())  ->",42],["let ty = obj.GetType()",40],["let LanguagePrimitivesType = typedefof<list<_>>.Assembly.GetType(\"Microsoft.FSharp.Core.LanguagePrimitives\")",45]],"useCount":6382},{"word":"Groups","context":[["match dependenciesFile.Groups |> Map.tryFind groupName with",67],["match lockFile.Groups |> Map.tryFind groupName with",99],["|> LockFileSerializer.serializePackages cfg.Groups.[Constants.MainDependencyGroup].Options",115],["cfg.Groups.[Constants.MainDependencyGroup].Options.Strict |> shouldEqual false",121],["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"NUnit\"].Version",57],["let p = cfg.Groups.[Constants.MainDependencyGroup].Packages |> List.find (fun x-> x.Name = PackageName \"Foobar\")",52],["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"Castle.Windsor\"].Version",47],["referenceFile.Groups",45],["dependenciesFile.Groups",164],["dependencies.Groups.[Constants.MainDependencyGroup].RemoteFiles",152]],"useCount":2285},{"word":"Guid","context":[["override this.GUID                                                                                   = Guid.Empty",45],["sprintf \"Lambda%O\" (Guid.NewGuid())",45],["Id : Guid",47],["let guid2 = Guid.NewGuid().ToString(\"D\")",42],["] |> List.map Guid.Parse |> Set.ofList",85],["let notFoundId = Guid.NewGuid()",42],["let guid1 = Guid.NewGuid().ToString(\"D\")",38],["let guid = Guid.NewGuid().ToString(\"D\")",178],["let guid = Guid.NewGuid()",36],["let id = Guid.NewGuid()",229]],"useCount":2394},{"word":"Http","context":[["open System.Web.Http",193],["@\"..\\Microsoft.Net.Http\\lib\\net40\\System.Net.Http.Primitives.dll\"",55],["@\"..\\Microsoft.Net.Http\\lib\\net40\\System.Net.Http.Extensions.dll\"",55],["open Suave.Http.Successful",62],["<Reference Include=\"System.Net.Http\">",80],["open System.Net.Http",239],["<Reference Include=\"System.Net.Http.Extensions\">",163],["<Reference Include=\"System.Net.Http.Primitives\">",163],["open Suave.Http.Applicatives",81],["open Suave.Http",148]],"useCount":4163},{"word":"IDisposable","context":[["// 'T * ('T -> M<'U>) -> M<'U> when 'U :> IDisposable",44],["{ new System.IDisposable with",109],["interface System.IDisposable with",578],["interface IDisposable with",1224],["(docEventListener :> IDisposable).Dispose()",86],["interface System.IDisposable",47],["| :? System.IDisposable as e -> e.Dispose()",37],["// 'T * ('T -> M<'U>) -> M<'U> when 'T :> IDisposable",36],["{ new IDisposable with",242],["inherit IDisposable",132]],"useCount":3116},{"word":"IEnumerable","context":[["interface System.Collections.IEnumerable with",286],["interface IEnumerable with",288],["Microsoft.FSharp.Core.ExtraTopLevelOperators: T[,] CreateArray2D[?,T](System.Collections.Generic.IEnumerable`1[?])",28],["Microsoft.FSharp.Collections.SeqModule: T Average[T](System.Collections.Generic.IEnumerable`1[T])",28],["interface System.Collections.Generic.IEnumerable<'T> with",35],["interface IEnumerable<'T>",40],["fun v -> transList (v :?> System.Collections.IEnumerable, ty, nil, cons)",55],["interface System.Collections.IEnumerable",74],["interface IEnumerable<'T> with",195],["{ new IEnumerable<'T> with",48]],"useCount":2405},{"word":"IF","context":[["dup IF",133],["state @ IF",68],["2dup = IF",60],["?dup IF",68],["debug-client-interface? IF",71],["0= IF",72],["dup nil<> IF",89],["[IF]",98],["nil<>? IF",118],["IF",895]],"useCount":4649},{"word":"IL","context":[["(fun _ -> None) // We do not respect this attribute for IL methods",54],["// Instance IL event (fake up event-as-value)",60],["/// emits given expression to corresponding IL",64],["mdCodeKind=MethodCodeKind.IL;",95],["open Yard.Core.IL.Production",97],["do! IL.ret",44],["if IL.runningOnMono then",112],["open Yard.Core.IL",144],["open Microsoft.FSharp.Compiler.AbstractIL.IL",179],["open Microsoft.FSharp.Compiler.AbstractIL.IL",701]],"useCount":7838},{"word":"ILAttribElem","context":[["[ILAttribElem.Array (g.ilg.typ_Int32, List.map (fun n -> ILAttribElem.Int32(n)) nums)],",19],["ILAttribElem.UInt64 n, sigptr",19],["| Some ([ILAttribElem.Int32 validOn; ILAttribElem.Bool _allowMultiple; ILAttribElem.Bool inherited ],_) ->",20],["| Some ([ILAttribElem.Int32 validOn; ILAttribElem.Bool _allowMultiple; ILAttribElem.Bool inherited ],_) ->",20],["| Some ([ILAttribElem.Int32 validOn; ILAttribElem.Bool _allowMultiple; ILAttribElem.Bool inherited ],_) ->",20],["(function ([ILAttribElem.String (Some(msg)) ],_) -> Some msg | _ -> None)",22],["ILAttribElem.Int32 n, sigptr",38],["| Some ([ILAttribElem.Int32 validOn ],named) ->",20],["|  [ILAttribElem.String s],_ -> s",38],["ILAttribElem.Byte n, sigptr",19]],"useCount":2885},{"word":"ILFieldInit","context":[["/// Convert an Abstract IL ILFieldInit value read from .NET metadata to a TAST constant",20],["ILFieldInit.String (s)",21],["| _ -> ILFieldInit.Null",22],["| ILFieldInit.Char    c -> Const.Char (char (int c))",20],["| ILFieldInit.UInt16  x -> Const.UInt16 x",20],["| ILFieldInit.Null       -> Const.Zero",20],["/// Compute the ILFieldInit for the given provided constant value for a provided enum type.",34],["| ILFieldInit.Single f -> Const.Single f",20],["type ILFieldInit =",24],["| x when x = uint16 et_CLASS || x = uint16 et_OBJECT ->  ILFieldInit.Null",22]],"useCount":2241},{"word":"ILMemberAccess","context":[["Access: ILMemberAccess;",57],["Access: ILMemberAccess;",51],["elif f = 0x00000006 then ILTypeDefAccess.Nested ILMemberAccess.FamilyAndAssembly",22],["ILMemberAccess.Public,",25],["Access=ILMemberAccess.Private;",30],["elif f = 0x00000005 then ILTypeDefAccess.Nested ILMemberAccess.Assembly",22],["elif f = 0x00000003 then ILTypeDefAccess.Nested ILMemberAccess.Private",22],["if mdef.Access <> ILMemberAccess.Private then",32],["| Nested of ILMemberAccess",24],["type ILMemberAccess =",24]],"useCount":1991},{"word":"ILScopeRef","context":[["| ILScopeRef.Assembly aref -> aref.Name",31],["| ILScopeRef.Assembly aref -> aref",32],["ILScopeRef = ilScopeRef;",32],["| ILScopeRef.Module mref -> mref.Name",31],["| ILScopeRef.Assembly aref -> aref.QualifiedName",42],["member Scope: ILScopeRef",34],["ILScopeRef = ilScopeRef",58],["let tref = mkRefForNestedILTypeDef ILScopeRef.Local (nesting,tdef)",80],["let ilScopeRef = dllinfo.ILScopeRef",36],["| ILScopeRef.Local -> \"\"",42]],"useCount":4283},{"word":"ILType","context":[["| ILType.Boxed  tspec | ILType.Value tspec ->",33],["member EnclosingType: ILType",34],["| ILType.Ptr _ty -> failwith \"unexpected pointer type\"",46],["// REVIEW: this uses equality on ILType.  For CMOD_OPTIONAL this is not going to be correct",34],["| ILType.Byref _ty -> failwith \"unexpected byref type\"",46],["| ILType.FunctionPointer _mref -> failwith \"unexpected function pointer type\"",46],["| ILType.Boxed  tspec | ILType.Value tspec ->",33],["Type: ILType;",80],["Type: ILType;",68],["let aty = convType cenv emEnv  (ILType.Array(shape,typ))",64]],"useCount":10634},{"word":"ILTypeRef","context":[["| Some s -> Some (ILTypeRef.Create(s,x.Enclosing,x.Name))",22],["| Modified of bool * ILTypeRef * ILType",23],["member TypeRef : ILTypeRef",33],["/// Get the cache of the compiled ILTypeRef representation of this module or type.",34],["{ mrefParent: ILTypeRef;",20],["{ tspecTypeRef: ILTypeRef;",20],["| TExnAsmRepr of ILTypeRef",20],["member EnclosingTypeRef: ILTypeRef",68],["ILTypeRef.Create(sref, (outerTypeName :: List.map (fun (nm,_) -> nm) t),item)",20],["let y = (yobj :?> ILTypeRef)",40]],"useCount":2254},{"word":"IO","context":[["open System.IO.Compression",131],["open System.IO",7314],["let! m = IO<int>.Input",66],["|> IO.Path.GetDirectoryName",61],["let bytes = System.IO.File.ReadAllBytes assembly.ManifestModule.FullyQualifiedName",61],["let assemblyBytes = System.IO.File.ReadAllBytes fileName",61],["ignore(IO.Path.GetFullPath folder)",60],["|> Seq.tryFind IO.File.Exists",59],["|> Seq.map (fun f -> IO.Path.Combine(f, expectedName))",57],["open System.IO",120]],"useCount":9285},{"word":"IParseState","context":[["member ParseState : IParseState",13],["type internal IParseState =",12],["let lhs (parseState: IParseState) =",12],["reductions: (IParseState -> obj) array ;",13],["(fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->",2648],["(fun (parseState : Internal.Utilities.Text.Parsing.IParseState) ->",1046],["type IParseState with",19],["{ new IParseState with",11],["parseState: IParseState,",16],["let rhs2 (parseState: IParseState) i j =",12]],"useCount":3824},{"word":"Id","context":[["{ [<Id(IdKind.Identity)>]",115],["{ [<Id>]",221],["match Visibilities.For (actor conn).Id with",195],["Id : string",175],["let id = tycon.Id",60],["abstract Id : string",79],["Id = \"\"",86],["Id : int",80],["Generic (Id \"list\",[Var (Normal \"a\")]))",64],["if parameters.Id = \"\" then",73]],"useCount":5232},{"word":"Ident","context":[["| SynExpr.Ident id -> id.idRange",65],["| SynExpr.Ident id ->",42],["Target: Ident option",23],["Ident *",75],["open FStar.Ident",151],["let mkSynId m s = Ident(s,m)",23],["| Ident of Ident",24],["| Ident of Ident",24],["let textOfId (id:Ident) = id.idText",23],["| SynExpr.Ident _",39]],"useCount":2758},{"word":"If","context":[["// to COM components.  If you need to access a type in this assembly from",997],["/// <param name=\"Enabled\">If false, disables the axis</param>",56],["// If an error was encountered, return None.",52],["/// remote execution behavior. If successfully imported, the function will be cached for faster reimporting.",84],["///   - If this is a property then this is 'Foo'",72],["/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>",57],["///  - `outputPath` - If it is null or empty then the project settings are used.",60],["* If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.",56],["// If the error was set, return it.",52],["/// * recurseOnMatch - If a match is found continues down the tree matching child elements",60]],"useCount":7566},{"word":"Ignore","context":[["[<Ignore>]",61],["[<Test; Ignore(\"Not Supported\")>]",61],["| _ -> Ignore",35],["do! con.OpenAsync() |> Async.AwaitIAsyncResult |> Async.Ignore",29],["Assert.Ignore \"Test not yet implemented.\"",592],["[<Ignore(\"Remove to run test\")>]",799],["|> Async.Ignore",246],["Ignore",34],["[<Test; Ignore(\"\")>]",30],["do! cmd.ExecuteNonQueryAsync() |> Async.AwaitTask |> Async.Ignore",30]],"useCount":2294},{"word":"Import","context":[["open Fable.Import",72],["/// Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control",84],["amap: Import.ImportMap;",65],["ImportProvidedType = (fun ty -> Import.ImportProvidedType (tcImports.GetImportMap()) m ty)",54],["open Fable.Import.Node",48],["open Fable.Import.vscode",46],["[<Import; DefaultValue>]",43],["open Microsoft.FSharp.Compiler.Import",38],["|> getDescendants \"Import\"",116],["[<Import; MI (MIO.NoInlining)>]",98]],"useCount":2315},{"word":"In","context":[["// In this case, we don't want any of the fallback logic, rather, we want to produce zero results.",24],["// In principle the JIT should be able to do good liveness analysis to clean things up, but the",48],["// In F# this only defines a new type if A is not in scope",40],["// and we erase array of provided type to array of base type. In the",38],["[<In; MarshalAs(UnmanagedType.U4)>] cbKeyBlob : uint32 *",32],["// In other words, the free type variables get divided into two sets",32],["[<In; MarshalAs(UnmanagedType.LPWStr)>] pwzFilePath : string *",32],["[<In; MarshalAs(UnmanagedType.LPWStr)>] pwzKeyContainer : string *",32],["/// and we erase array of provided type to array of base type. In the",23],["| FSharp.Data.Sql.In ->",34]],"useCount":2762},{"word":"Include","context":[["<Reference Include=\"System.Net.Http\">",80],["<Reference Include=\"System.Reactive.Windows.Threading\">",84],["<Reference Include=\"System.Net.Http.Extensions\">",163],["<Reference Include=\"System.Net.Http.Primitives\">",163],["<Reference Include=\"System.Net.Http.WebRequest\">",46],["<Reference Include=\"System.Data.SQLite\">",44],["match node |> getAttribute \"Include\" with",40],["<Reference Include=\"FantomasLib\">",39],["<Compile Include=\"File1.fs\" />",32],["<Compile Include=\"File6.fs\" />",32]],"useCount":2056},{"word":"Indicates","context":[["/// Indicates the type prefers the \"tycon<a,b>\" syntax for display etc.",38],["/// Indicates if this is an F#-defined struct or enum type definition , i.e. a value type definition",34],["/// Indicates if we have pre-determined that a type definition has a default constructor.",34],["/// Indicates the \"tycon blob\" is actually a module",37],["/// Indicates that this DLL was compiled using the F# compiler and has F# metadata",38],["/// Indicates a reference to something bound in another CCU",40],["{ /// Indicates a reference to something bound in this CCU",40],["/// Indicates if this entity is an F# type abbreviation definition",46],["/// Indicates if the entity is a provided namespace fragment",51],["/// Indicates if the entity is an F# module definition",34]],"useCount":5938},{"word":"Inline","context":[["[<Extension; Inline; JavaScript>]",22],["[<Inline; JavaScript>]",52],["[<Extension; Inline>]",967],["[<Inline>]",2192],["[<JavaScript; Inline>]",3020],["[<Inline \"$this.bind($thisArg)\">]",28],["[<Inline \"$0\">]",38],["errorR(Error((193,\"Inline IL not valid in a hosted environment\"),m))",38],["[<Inline \"$wsruntime.ThisFunc($del)\">]",14],["[<Extension; Inline \"$0\">]",17]],"useCount":6486},{"word":"Instance","context":[["XmlConfig.Instance.UseAttributes <- true",63],["let cconv = if isStatic then ILCallingConv.Static else ILCallingConv.Instance",32],["CallingConv=ILThisConvention.Instance;",41],["static member Instance = instance",45],["bindingAttr.HasFlag(if isStatic then BindingFlags.Static else BindingFlags.Instance) &&",50],["let ALL = BindingFlags.Public ||| BindingFlags.NonPublic ||| BindingFlags.Static ||| BindingFlags.Instance",51],["CallingConv=ILCallingConv.Instance;",57],["// Instance IL event (fake up event-as-value)",60],["|+> Instance [",338],["|+> Instance",178]],"useCount":1831},{"word":"Int32","context":[["| Int32",47],["| Const.Int32 _",86],["| \"System.Int32\"",32],["| Int32",34],["Default.Int32()",36],["type System.Int32 with",45],["ILAttribElem.Int32 n, sigptr",38],["| Int32 of int32",36],["| TypeCode.Int32",53],["| Int32 of int32",73]],"useCount":19409},{"word":"Internal","context":[["open Internal.Utilities.Collections",195],["open Internal.Utilities.Text.Lexing",116],["open Microsoft.FSharp.Compiler.AbstractIL.Internal",194],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",87],["open Internal.Utilities",220],["open Microsoft.FSharp.Compiler.AbstractIL.Internal",698],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",835],["open Internal.Utilities",835],["(fun (parseState : Internal.Utilities.Text.Parsing.IParseState) ->",1046],["open Internal.Utilities.Debug",79]],"useCount":5614},{"word":"InternalError","context":[["| None -> error(InternalError(\"PartitionValTypars: not a top value\", v.Range))",36],["warning(InternalError(msg,m));",52],["| _ -> error(InternalError(\"should have inferred tycon kind\",m))",40],["if isSome ctorThisValOpt then errorR(InternalError(\"skipping ctorThisValOpt\", e.Range));",34],["if isSome baseValOpt then errorR(InternalError(\"skipping baseValOpt\", e.Range));",34],["| SynMemberDefn.Member (_,m)       :: _ -> errorR(InternalError(\"List.takeUntil is wrong, have binding\",m))",20],["error(InternalError(\"Unexpected missing 'this' variable in MakeValueGetAddress\",m))",20],["| ParentNone -> error(InternalError(\"TopValActualParent: does not have a parent\",x.Range))",20],["| InternalError (s,_)",20],["| SynMemberDefn.Interface (_,_,m)          :: _ -> errorR(InternalError(\"List.takeUntil is wrong, have interface\",m))",20]],"useCount":2093},{"word":"InteropServices","context":[["System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(E_FAIL)",112],["open System.Runtime.InteropServices",2660],["open System.Runtime.InteropServices;",59],["let ctor = typeof<System.Runtime.InteropServices.DefaultParameterValueAttribute>.GetConstructor([|typeof<obj>|])",34],["let ctor = typeof<System.Runtime.InteropServices.OptionalAttribute>.GetConstructor([||])",34],["[System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()]",28],["open System.Runtime.InteropServices",22],["\"System.Runtime.InteropServices.WindowsRuntime.dll\";",33],["let systemRuntimeInteropServicesRef = mkReference \"System.Runtime.InteropServices\"",18],["[<assembly: System.Runtime.InteropServices.ComVisible(false)>]",72]],"useCount":3355},{"word":"Invoke","context":[["f.Invoke()",46],["override this.Invoke(_invokeAttr, _binder, _parameters, _culture)      = notRequired \"Invoke\" (nameText())",45],["override this.Invoke(_obj, _invokeAttr, _binder, _parameters, _culture) = notRequired \"Invoke\" (nameText())",45],["override this.Invoke(_obj, _invokeAttr, _binder, _parameters, _culture) = notRequired \"Invoke\" this.Name",85],["override this.Invoke(_invokeAttr, _binder, _parameters, _culture)      = notRequired \"Invoke\" (nameText())",45],["let decl = baseType.GetMethod \"Invoke\"",51],["trans (Quotations.Expr.Call(trans f, f.Type.GetMethod \"Invoke\", [ e ]) )",55],["// Eliminate F# function applications to FSharpFunc<_,_>.Invoke calls",64],["override this.Invoke(_obj, _invokeAttr, _binder, _parameters, _culture) = notRequired \"Invoke\" this.Name",85],["override this.Invoke(_obj, _invokeAttr, _binder, _parameters, _culture) = notRequired \"Invoke\" (nameText())",45]],"useCount":2859},{"word":"IsEmpty","context":[["not stack.IsEmpty",40],["member IsEmpty : bool",61],["member m.IsEmpty = imap.IsEmpty",38],["member m.IsEmpty = imap.IsEmpty",38],["if not arginfos.IsEmpty && not arginfos.Head.IsEmpty then",38],["member this.IsEmpty() =",48],["not i.stack.IsEmpty",42],["assert preGeneralizationRecBinds.IsEmpty",40],["[<CompiledName(\"IsEmpty\")>]",108],["if freeInBinding.IsEmpty then true else",100]],"useCount":2533},{"word":"IsNone","context":[["member __.ShouldSerializetype() = not _type.IsNone",70],["//member __.ShouldSerializerole() = not _role.IsNone",95],["member __.ShouldSerializestream() = not _stream.IsNone",48],["member __.ShouldSerializeshowlegend() = not _showlegend.IsNone",49],["member __.ShouldSerializey() = not _y.IsNone",64],["query.TakeCount.IsNone |> should equal true",58],["member __.ShouldSerializeopacity() = not _opacity.IsNone",62],["override __.Attributes = if parameterDefaultValue.IsNone then enum 0 else ParameterAttributes.Optional",63],["member __.ShouldSerializevisible() = not _visible.IsNone",63],["member __.ShouldSerializex() = not _x.IsNone",64]],"useCount":2424},{"word":"IsStatic","context":[["m.IsStatic, m.IsPublic",102],["member this.IsStatic",89],["member x.IsStatic =",76],["if minfo.IsStatic then",69],["if tagMeth.IsStatic then trans (Quotations.Expr.Call(tagMeth, [e]))",55],["x.IsStatic = statics &&",51],["| :? MethodInfo as m -> m.IsStatic, m.IsPublic",51],["| :? ConstructorInfo as c -> c.IsStatic, c.IsPublic",51],["if field.IsStatic then",116],["[| if not pminfo.IsStatic then",64]],"useCount":2578},{"word":"Item","context":[["member this.Item",196],["| Item.Value vref ->",73],["| Item.RecdField rfinfo ->",75],["| Item.Property(_,pinfos) ->",83],["| Item.Event einfo ->",84],["| Item.FakeInterfaceCtor _",95],["| Item.ILField finfo ->",112],["member x.Item",175],["|> List.map Item.RecdField",60],["/// <param name=\"item\">Item to be inserted into queue</param>",59]],"useCount":12071},{"word":"JavaScript","context":[["open WebSharper.JavaScript",289],["[<JavaScript>]",2122],["[<JavaScript; Inline>]",3020],["[<Inline; JavaScript>]",52],["[<Extension; Inline; JavaScript>]",22],["open WebSharper.JavaScript",12],["[<Sealed; JavaScript>]",12]],"useCount":5529},{"word":"Key","context":[["|> Seq.map (fun kv -> kv.Key)",87],["let groupName,packageName = kv.Key",36],["match lockFile.Groups |> Map.tryFind kv.Key with",32],["|> Seq.map (fun k -> k.Key)",38],["let dt = data.ToDataTable([\"Key\"])",40],["/// <param name=\"key\">Key to entry.</param>",43],["let comparer = LanguagePrimitives.FastGenericComparer<'Key>",30],["|> Seq.filter (fun kv -> usedPackages.ContainsKey kv.Key)",29],["let del = pair.Key",28],["|> Seq.filter (fun kv -> normalizedDependencies |> Seq.exists ((=) kv.Key))",72]],"useCount":2225},{"word":"Lambda","context":[["| Lambda(_, Invoke(Call(null, Method \"ToFSharpFunc\", Ar [| Lambda(_, p) |]))) ->",28],["let lambda = Expression.Lambda(body, pL, pR).Compile()",30],["| SynExpr.Lambda (_,_,_,e,_) ->",36],["| Quotations.ExprShape.ShapeLambda(v, body) -> Quotations.Expr.Lambda(v, expand body)",38],["| Expr.Lambda _",42],["| Quotations.Patterns.Lambda(v, body) ->",43],["| SynExpr.Lambda (_,_,_,_,m)",44],["sprintf \"Lambda%O\" (Guid.NewGuid())",45],["Quotations.Expr.Lambda(v, trans body)",56],["| Expr.Lambda (_,_,_,_,_,m,_)",32]],"useCount":2148},{"word":"LanguagePrimitives","context":[["open Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions",37],["Microsoft.FSharp.Core.LanguagePrimitives: Microsoft.FSharp.Core.LanguagePrimitives+HashCompare",28],["Microsoft.FSharp.Core.LanguagePrimitives+HashCompare: Int32 GetHashCode()",28],["let mutable acc = LanguagePrimitives.GenericZero< (^U) >",29],["let comparer = LanguagePrimitives.FastGenericComparer<'Key>",30],["let inline (===) a b = LanguagePrimitives.PhysicalEquality a b",37],["open Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators",269],["open LanguagePrimitives",96],["open Microsoft.FSharp.Core.LanguagePrimitives",84],["let LanguagePrimitivesType = typedefof<list<_>>.Assembly.GetType(\"Microsoft.FSharp.Core.LanguagePrimitives\")",45]],"useCount":4733},{"word":"Lazy","context":[["GlobalProvidedAssemblyElementsTable.theTable.[assembly] <- Lazy<_>.CreateFromValue bytes",30],["| SynExpr.Lazy (_, m)",44],["|> Lazy.force",44],["| SynExpr.Lazy (e, _)",43],["GlobalProvidedAssemblyElementsTable.theTable.Add(assembly, Lazy<_>.CreateFromValue assemblyBytes)",30],["let notlazy v = Lazy.CreateFromValue v",49],["let theTable = Dictionary<Assembly, Lazy<byte[]>>()",58],["let mkXmlDocCustomAttributeDataLazy(lazyText: Lazy<string>) =",63],["GlobalProvidedAssemblyElementsTable.theTable.[assembly] <- Lazy.CreateFromValue bytes",29],["/// Lazy logging adapter. It won't be initialized until logging function will be called.",30]],"useCount":2350},{"word":"Length","context":[["let refMap = Map.ofSeq [for c in [\".\"; \"..\"; \"...\"; \"....\"] do yield (c, c.Length) ]",126],["assert_equal 1 ps.Parameters.Length",124],["let lenx = x.Length",99],["let leny = y.Length",99],["let len = array.Length",372],["if staticParams.Length>0 then",82],["if staticParams.Length <> args.Length then",83],["if staticParams.Length <> args.Length then",83],["if input.Length <= index",95],["wholeProjectResults.Errors.Length |> shouldEqual 0",310]],"useCount":21114},{"word":"Library","context":[["module Library =",77],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",835],["[<assembly: AssemblyDescriptionAttribute(\"Library of F# type providers and data access tools\")>]",29],["/*  This file is part of Visualization Library                                        */",98],["open MBrace.Library",87],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",87],["| Reference.Library lib ->",61],["let result = Library.hello 42",63],["///     let h = Library.hello 1",75],["| Library",75]],"useCount":2189},{"word":"Linq","context":[["open Microsoft.FSharp.Linq",80],["open System.Linq",1372],["open System.Xml.Linq",581],["open System.Linq.Expressions",346],["open Microsoft.FSharp.Linq.RuntimeHelpers",116],["open System.Reactive.Linq",109],["open Newtonsoft.Json.Linq",127],["open System.Linq.Expressions",57],["open System.Data.Linq",45],["open Microsoft.FSharp.Linq.QuotationEvaluation",43]],"useCount":7409},{"word":"List","context":[["|> List.ofSeq",791],["// empty List",359],["module List =",230],["// string List",383],["// integer List",387],["|> List.rev",501],["|> List.concat",509],["List.foldBack",229],["|> List.unzip",276],["|> List.toArray",359]],"useCount":63807},{"word":"Literal","context":[["let [<Literal>] Version = \"0.0.1\"",59],["let [<Literal>] Version = \"0.1.0\"",46],["let [<Literal>] InformationalVersion = \"1.0\"",41],["override this.Attributes = FieldAttributes.Static ||| FieldAttributes.Literal ||| FieldAttributes.Public",42],["let [<Literal>] InformationalVersion = \"0.1.0.1\"",35],["let [<Literal>] Version = \"0.1.0.1\"",35],["let [<Literal>] Version = \"1.0\"",238],["[<Literal>]",4059],["let [<Literal>] Version = \"0.3.0.0\"",33],["let [<Literal>] Version = \"0.0.1.7\"",38]],"useCount":5722},{"word":"Local","context":[["| Local _ -> None",32],["yield Local.makeProvidedNamespace namespaceName types",63],["| Local",29],["| ILResourceLocation.Local b -> b()",31],["| ILResourceLocation.Local bf ->",31],["| ILScopeRef.Local -> \"\"",42],["// Local action is not identified with a guid in execution",44],["module Local =",63],["yield Local.makeProvidedNamespace namespaceName types |]",63],["let tref = mkRefForNestedILTypeDef ILScopeRef.Local (nesting,tdef)",80]],"useCount":1829},{"word":"Logging","context":[["use l = Logging.LogScope()",880],["if Logging.verbose then",35],["member __.Log = lazy (Akka.Event.Logging.GetLogger(context))",39],["Ninject.Extensions.Logging.Log4net (2.2.0.4)",40],["module Logging =",41],["(\"Ninject.Extensions.Logging\",\"3.2.3\");",44],["Logging.logException e",62],["open Yaaf.Logging",77],["open Logging",83],["open Paket.Logging",381]],"useCount":2243},{"word":"LogicalName","context":[["let nm = minfo.LogicalName",97],["member __.LogicalName =",24],["let propName = PrettyNaming.ChopPropertyName(m.LogicalName)",24],["let availPriorOverridesKeyed = availPriorOverrides |> NameMultiMap.initBy (fun ov -> ov.LogicalName)",28],["let sigtyconOpt = (NameMap.tryFind entity.LogicalName msigty.AllEntitiesByCompiledAndLogicalMangledNames)",34],["member x.LogicalName =",40],["override x.ToString() = x.LogicalName",40],["| None -> x.LogicalName",54],["[<StructuredFormatDisplay(\"{LogicalName}\")>]",60],["|> List.filter (fun tcref -> not (tcref.LogicalName.Contains(\",\")))",60]],"useCount":3638},{"word":"M","context":[["// M<'T> -> M<'T> -> M<'T>",110],["// M<'T> -> M<'T> -> M<'T>",110],["// (unit -> M<'T>) -> M<'T>",82],["// M<'T> -> M<'T>",82],["// (unit -> M<'T>) -> M<'T>",82],["M {",109],["// M<'T> -> M<'T> -> M<'T>",110],["module M",135],["open M",148],["module M =",289]],"useCount":5913},{"word":"MANone","context":[["],MANone);",2092]],"useCount":2092},{"word":"MBrace","context":[["open MBrace.Core.Internals",544],["﻿namespace MBrace.Runtime",86],["open MBrace.Runtime.Utils.PrettyPrinters",67],["open MBrace.Azure",75],["open MBrace.FsPickler",77],["﻿namespace MBrace.Thespian.Runtime",81],["open MBrace.Library",87],["open MBrace.Runtime.Utils",218],["open MBrace.Runtime",237],["open MBrace.Core",510]],"useCount":3141},{"word":"Make","context":[["[<assembly: AssemblyTitleAttribute(\"FAKE - F# Make Lib\")>]",36],["// Make sure we don't print the usage information twice.",23],["[<assembly: AssemblyTitleAttribute(\"FAKE - F# Make Deploy tool\")>]",36],["[<assembly: AssemblyTitleAttribute(\"FAKE - F# Make Command line tool\")>]",36],["[<assembly: AssemblyTitleAttribute(\"FAKE - F# Make Experimental Lib\")>]",36],["[<assembly: AssemblyTitleAttribute(\"FAKE - F# Make Deploy Lib\")>]",36],["[<assembly: AssemblyTitleAttribute(\"FAKE - F# Make SQL Lib\")>]",36],["[<assembly: AssemblyTitleAttribute(\"FAKE - F# Make Deploy Web\")>]",36],["Make sure each method works on:",111],["[<assembly: AssemblyProductAttribute(\"FAKE - F# Make\")>]",273]],"useCount":1987},{"word":"Map","context":[["Map.empty",247],["|> Map.toSeq",268],["|> Map.ofArray",128],["match groups |> Map.tryFind groupName with",132],["let valueKeyMap = Map.ofSeq [(2,\"b\"); (3,\"c\"); (4,\"d\"); (5,\"e\")]",133],["// empty Map",133],["// One-element Map",154],["|> Map.ofList",426],["|> Map.ofSeq",597],["[<CompiledName(\"Map\")>]",277]],"useCount":9911},{"word":"Match","context":[["| SynExpr.Match (_,_,_,_,m)",47],["| SynExpr.Match _",41],["|> Seq.cast<Match>",55],["| Expr.Match (_,_,dtree,targets,_,_) ->",38],["| SynExpr.Match(_sequencePointInfoForBinding, synExpr, synMatchClauseList, _, _range) ->",30],["| Expr.Match(spBind,exprm,dtree,targets,m,ty) ->",29],["Microsoft.FSharp.Core.CLIEventAttribute: Boolean Match(System.Object)",28],["Microsoft.FSharp.Core.RequireQualifiedAccessAttribute: Boolean Match(System.Object)",28],["Microsoft.FSharp.Core.ReflectedDefinitionAttribute: Boolean Match(System.Object)",28],["Microsoft.FSharp.Core.StructuredFormatDisplayAttribute: Boolean Match(System.Object)",28]],"useCount":2461},{"word":"MemberInfo","context":[["member this.AddMembersDelayed(makeMS : unit -> list<#MemberInfo>) =",46],["member this.AddMembers(ms:list<#MemberInfo>) = (* strict *)",45],["let membInfo,topValInfo = checkMemberVal v.MemberInfo v.ValReprInfo v.Range",57],["member x.MemberInfo = memb",61],["let mutable membersQueue   = ResizeArray<(unit -> list<MemberInfo>)>()",63],["let patchUpAddedMemberInfo (this:Type) (m:MemberInfo) =",63],["let mutable membersKnown   = ResizeArray<MemberInfo>()",63],["match x.MemberInfo with",162],["match vref.MemberInfo with",236],["match v.MemberInfo with",254]],"useCount":2244},{"word":"MemberKind","context":[["| MemberKind.Constructor",102],["| MemberKind.PropertyGetSet ->",76],["| MemberKind.PropertyGet ->",90],["match memberFlags.MemberKind with",184],["| MemberKind.ClassConstructor",137],["| MemberKind.PropertyGet",121],["| MemberKind.PropertySet",114],["| MemberKind.PropertySet ->",110],["match membInfo.MemberFlags.MemberKind with",109],["| MemberKind.Member ->",101]],"useCount":4239},{"word":"Message","context":[["member x.Message = message",36],["printfn \"%s\" ex.Message",116],["type Message =",76],["override this.Message =",74],["| None -> parse_error ctxt.Message);",52],["with exn -> failwithf \"Start of process %s failed. %s\" proc.StartInfo.FileName exn.Message",42],["Message : string",41],["| ex -> failwith ex.Message",39],["e.Message",38],["| ex -> Choice2Of2 ex.Message",36]],"useCount":2629},{"word":"Method","context":[["codedBigness 5 TableNames.Method ||",33],["[<AttributeUsage(AttributeTargets.Method,AllowMultiple=false)>]",35],["(result.Method,result.AssociatedPropertyInfo) |> callSink",36],["codedBigness 3 TableNames.Method ||",66],["override this.ToString() = \"Method \" + this.Name",87],["codedBigness 1 TableNames.Method",66],["[<AttributeUsage (AttributeTargets.Method,AllowMultiple=false)>]",36],["|> Array.filter (fun m -> m.MemberType.HasFlag(MemberTypes.Method))",64],["if m.MemberType.HasFlag(MemberTypes.Method) && m.Name = name then",64],["override this.MemberType = MemberTypes.Method",46]],"useCount":2901},{"word":"Microsoft","context":[["open Microsoft.FSharp.Compiler.AbstractIL.Internal",698],["open Microsoft.FSharp.Compiler.AbstractIL.IL",701],["open Microsoft.FSharp.Compiler.Ast",729],["Microsoft.FSharp.Core.Operators.box",3597],["(fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->",2648],["open Microsoft.FSharp.Quotations",1072],["open Microsoft.FSharp.Compiler",1015],["open Microsoft.FSharp.Compiler.Range",842],["open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library",835],["open Microsoft.FSharp.Reflection",744]],"useCount":114801},{"word":"Module","context":[["module Module =",75],["let log, success = TestUtil.TryCompileOpenCL((insideResult.KFGRoot :?> KFGKernelNode).Module)",64],["let log, success = TestUtil.TryCompileOpenCL((outsideResult.KFGRoot :?> KFGKernelNode).Module)",58],["let log, success = TestUtil.TryCompileOpenCL((result.KFGRoot :?> KFGKernelNode).Module)",38],["[<Trait (Traits.Names.Module, ModuleName)>]",58],["| Module",55],["override this.Module : Module = notRequired \"Module\" this.Name",47],["override this.Module : Module = notRequired \"Module\" this.Name",47],["override this.Module : Module = notRequired \"Module\" this.Name",47],["open Module",39]],"useCount":2079},{"word":"ModuleOrNamespaceType","context":[["let mty = modref.ModuleOrNamespaceType",83],["entity.ModuleOrNamespaceType.AddProvidedTypeEntity(newEntity)",35],["member x.ModuleOrNamespaceType = x.Data.entity_modul_contents.Force()",20],["match modref.ModuleOrNamespaceType.ModulesAndNamespacesByDemangledName.TryFind(id.idText) with",34],["let mtyp = modref.ModuleOrNamespaceType",34],["ModuleOrNamespaceType(mkind, QueueList.ofList vals, QueueList.ofList tycons)",31],["modref.ModuleOrNamespaceType.AllEntities",40],["let implModType = implModRef.ModuleOrNamespaceType",28],["let mtype = mspec.ModuleOrNamespaceType",38],["member x.ModuleOrNamespaceType = x.Deref.ModuleOrNamespaceType",20]],"useCount":2056},{"word":"ModuleSuffix","context":[["﻿[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",19],["[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",55],["[<RequireQualifiedAccess; CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",58],["Microsoft.FSharp.Core.CompilationRepresentationFlags: Microsoft.FSharp.Core.CompilationRepresentationFlags ModuleSuffix",28],["[<AutoOpen; CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",24],["[<CompilationRepresentationAttribute(CompilationRepresentationFlags.ModuleSuffix)>]",30],["[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",191],["[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",281],["[<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",337],["[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",1610]],"useCount":2664},{"word":"MoveNext","context":[["let! moven = ie.MoveNext()",44],["Assert.AreEqual(enum.MoveNext(), false)",68],["if not (e.MoveNext()) then",77],["enum.MoveNext,",82],["Assert.AreEqual(enum.MoveNext(), true)",102],["member x.MoveNext() =",162],["if e.MoveNext() then",180],["while e.MoveNext() do",257],["if e.MoveNext() then Assert.Fail()",60],["if not (e.MoveNext()) then Assert.Fail()",40]],"useCount":2087},{"word":"NET","context":[["/// Indicates if this is a .NET-defined enum type definition",34],["/// Indicates if this is a .NET-defined struct or enum type definition , i.e. a value type definition",34],["// Math.NET Numerics, part of the Math.NET Project",41],["// Math.NET Numerics, part of the Math.NET Project",41],["// Aivika for .NET",57],["// This file is a part of Aivika for .NET",57],["// Aivika for .NET",62],["// This file is a part of Aivika for .NET",62],["/// .NET symbolic types made from this type, e.g. when building Nullable<SomeProvidedType[]>.FullName",65],["// Allow 'fake' nested types that are actually real .NET types",67]],"useCount":3594},{"word":"NUnit","context":[["open NUnit.Framework",4596],["﻿[<NUnit.Framework.TestFixture>]",43],["// to the NUnit console/log so we'll know this function has been executed.",40],["open NUnit.Framework.Constraints",51],["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"NUnit\"].Version",57],["[<NUnit.Framework.TestFixture>]",69],["#r \"../../packages/NUnit.2.6.3/lib/nunit.framework.dll\"",71],["open FsCheck.NUnit",137],["nuget NUnit",151],["#r \"../../packages/NUnit/lib/nunit.framework.dll\"",184]],"useCount":5860},{"word":"Name","context":[["override this.GetCustomAttributes(_inherit)                  = notRequired \"GetCustomAttributes\" this.Name",169],["Name = name",169],["{ Name : string",224],["member Name: string",226],["Name: string",262],["override this.GetCustomAttributes(_attributeType, _inherit)   = notRequired \"GetCustomAttributes\" this.Name",169],["/// <param name=\"Name\">The name of the data set.</param>",753],["Name : string",395],["|> Helpers.ApplyStyles(?Name=Name,?Title=Title,?Color=Color,?AxisXTitle=XTitle,?AxisYTitle=YTitle)",388],["|> Helpers.ApplyStyles(?Name=Name,?Title=Title,?Color=Color,?AxisXTitle=XTitle,?AxisYTitle=YTitle)",388]],"useCount":28936},{"word":"NameMap","context":[["|> NameMap.range",89],["||> NameMap.suball2",70],["let m1 = implFields |> NameMap.ofKeyedList (fun rfld -> rfld.Name)",42],["let m2 = sigFields |> NameMap.ofKeyedList (fun rfld -> rfld.Name)",42],["match NameMap.tryFind assemblyName t.CcuTable with",20],["match NameMap.range nameToPrelimValSchemeMap with",40],["// REVIEW: this could be faster, e.g. by storing the index in the NameMap",34],["let sigtyconOpt = (NameMap.tryFind entity.LogicalName msigty.AllEntitiesByCompiledAndLogicalMangledNames)",34],["module NameMap =",31],["let mutable dllTable: NameMap<ImportedBinary> = NameMap.empty",20]],"useCount":2083},{"word":"Net","context":[["@\"..\\Microsoft.Net.Http\\lib\\net40\\System.Net.Http.Primitives.dll\"",55],["@\"..\\Microsoft.Net.Http\\lib\\net45\\System.Net.Http.Extensions.dll\"",55],["@\"..\\Microsoft.Net.Http\\lib\\net40\\System.Net.Http.WebRequest.dll\"",55],["open OpenCL.Net",57],["<Reference Include=\"System.Net.Http\">",80],["<Reference Include=\"System.Net.Http.Primitives\">",163],["<Reference Include=\"System.Net.Http.Extensions\">",163],["open System.Net.Sockets",221],["open System.Net.Http",239],["open System.Net",1020]],"useCount":5354},{"word":"NicePrint","context":[["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",72],["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv t1 t2",54],["let t1,t2,tpcs = NicePrint.minimalStringsOfTwoTypes denv t1 t2",54],["os.Append(f((NicePrint.stringOfRecdField denv v1), (NicePrint.stringOfRecdField denv v2))) |> ignore",20],["os.Append(FunctionValueUnexpectedE().Format (NicePrint.stringOfTy denv ty)) |> ignore",20],["NicePrint.outputQualifiedValOrMember denv os fx",24],["NicePrint.outputTy denv os rty)",30],["NicePrint.outputTy denv os rty",34],["let t1,t2,tpcs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",36],["(NicePrint.stringOfQualifiedValOrMember denv v)",72]],"useCount":1954},{"word":"No","context":[["| No",74],["// No input",55],["// No dotting through type generators to get to a nested type!",45],["| BulkAdd.No ->",45],["s\" No data available\"  exception constant exp-no-data            ( -- n = No data available exception number )",44],["s\" No data available\"  exception constant exp-no-data            ( -- n = No data available exception number )",44],["/// Layout a function pointer signature using type-only-F#-style. No argument names are printed.",36],["/// No exception is raised if the element is not present.",34],["[ \"B\", VersionRequirement(VersionRange.Exactly \"1.1\",PreReleaseStatus.No)",33],["let message = \"No matching member could be found.\"",32]],"useCount":2560},{"word":"NoComparison","context":[["[<NoEquality; NoComparison>]",2615],["[<NoEquality; NoComparison; Sealed>]",85],["[<NoComparison; NoEquality>]",461],["[<NoEquality; NoComparison; RequireQualifiedAccess>]",424],["[<NoComparison>]",382],["[<NoComparison; NoEquality>]",111],["[<StructuralEquality; NoComparison>]",126],["[<NoEquality; NoComparison;RequireQualifiedAccess>]",148],["[<NoEquality; NoComparison>]",287],["[<NoEquality;NoComparison>]",71]],"useCount":5519},{"word":"NoEquality","context":[["[<NoEquality; NoComparison; Sealed>]",85],["[<NoEquality; NoComparison>]",2615],["[<NoComparison; NoEquality>]",461],["and [<NoEquality; NoComparison>]",46],["[<NoComparison; NoEquality>]",111],["[<NoEquality; NoComparison;RequireQualifiedAccess>]",148],["[<NoEquality; NoComparison>]",287],["[<NoEquality; NoComparison; RequireQualifiedAccess>]",424],["[<NoEquality;NoComparison>]",71],["[<Struct; NoEquality; NoComparison>]",47]],"useCount":4803},{"word":"None","context":[["else None",2235],["| _ -> None",9290],["| None -> false",1531],["| _ -> None)",916],["| None -> []",889],["| None -> None",3643],["| None -> None",3643],["| None -> ()",4467],["None",6558],["| None ->",10839]],"useCount":101170},{"word":"Note","context":[["/// Note that because of signatures, there are situations where in a single compilation the \"same\"",34],["/// Note that using this function in a job workflow is not optimal and you",36],["/// Note: result is alphabetically sorted, then for each name the results are in declaration order",37],["/// Note: result is a indexed table, and for each name the results are in reverse declaration order",37],["// Note: static calls never mutate a struct object argument",40],["// Note: only the nominal type counts",40],["// Note this modifies the real honest-to-goodness settings for the current shell.",42],["// Note: We suppress the first sequence point in the body of this method since it is the initial state machine jump",48],["/// Note that the type provider specification does not require us to implement pointer-equality for provided types.",68],["// Note: Relies on 'compare' respecting true > false",84]],"useCount":3595},{"word":"Now","context":[["// Now return the new block, the remaining blocks and the new set",30],["module Now =",32],["DateTime.Now",32],["module Now =",39],["// Now that we know what we've generalized we can adjust the recursive references",40],["// Now report them",40],["let now = DateTime.Now",45],["let start = System.DateTime.Now",76],["currentIdent = \"Now\"",84],["let _ = DateTime.Now",186]],"useCount":2074},{"word":"Nullable","context":[["/// This overloaded operator adds Nullable values by non-Nullable values",24],["/// .NET symbolic types made from this type, e.g. when building Nullable<SomeProvidedType[]>.FullName",65],["| None -> Nullable()",31],["(Nullable())",29],["col.Nullable |> Claim.isTrue",25],["/// This overloaded operator adds Nullable values by non-Nullable values",24],["Microsoft.FSharp.Core.OptionModule: System.Nullable`1[T] ToNullable[T](Microsoft.FSharp.Core.FSharpOption`1[T])",19],["/// Indicates a constraint that a type is a non-Nullable value type",21],["member x.n = Nullable x",24],["Microsoft.FSharp.Core.OptionModule: Microsoft.FSharp.Core.FSharpOption`1[T] OfNullable[T](System.Nullable`1[T])",19]],"useCount":1922},{"word":"Numerics","context":[["///open Fmat.Numerics",216],["open System.Numerics",301],["﻿namespace Fmat.Numerics",52],["///open Fmat.Numerics.BasicStat",168],["///open Fmat.Numerics",153],["open MathNet.Numerics",115],["open MathNet.Numerics.LinearAlgebra",94],["///open Fmat.Numerics.BasicStat32",47],["///open Fmat.Numerics.GenericBasicStat",47],["///open Fmat.Numerics.BasicStat",47]],"useCount":2703},{"word":"O","context":[["sprintf \"Lambda%O\" (Guid.NewGuid())",45],["(* NOTE: O(n)! *)",44],["[ O; O; A ]",45],["[ O; O; A ]",45],["///O(1). Returns the count of elememts.",34],["[ A; O; O ]",47],["[ A; O; O ]",47],["| _ -> failwith (sprintf \"Member %O is of unexpected type\" mem)",54],["[ O; A; O ]",58],["[ O; A; O ]",58]],"useCount":3540},{"word":"Object","context":[["let executor( jobID: Guid, timeBudget: int, o: Object, token: CancellationToken, observer: IObserver<Object> ) =",32],["value : Object *",32],["/// Suppress System.Object entries in intellisense menus in instances of this provided type",32],["let executor( jobID: Guid, timeBudget: int, o: Object, token: CancellationToken, observer: IObserver<Object> ) =",32],["| EOF  -> (null : System.Object)",32],["type System.Object with",35],["if System.Object.ReferenceEquals(s,null) then",36],["open FSharp.Object.Diff",36],["| :? ProvidedTypeDefinition as ti -> System.Object.ReferenceEquals(this,ti)",63],["new IObserver<Object> with",65]],"useCount":13374},{"word":"Op","context":[["| Expr.Op (c,tyargs,args,m) ->",64],["| Expr.Op(TOp.ILAsm([ I_isinst _ ],_),[ty],[e],_) ->",22],["| Expr.Op(TOp.UnionCaseProof _,_,[e],_) ->",22],["| Op(s, args) ->",25],["(Expr.Op(TOp.Label noDisposeContinuationLabel,[],[],m))",27],["(Expr.Op(TOp.Label innerDisposeContinuationLabel,[],[],m))",27],["Expr.Op(op1, tinst1,List.map2 (CombineRefutations g) flds1 flds2,m1)",30],["(Expr.Op(TOp.Label label,[],[],m))",36],["| Expr.Op (op,tinst,args,_) ->",38],["| Expr.Op(op,tyargs,args,m) ->",60]],"useCount":2818},{"word":"OpCodes","context":[["ilg.Emit(OpCodes.Ldnull)",76],["il.Emit(OpCodes.Ldarg_0)",78],["ilg.Emit OpCodes.Ret",116],["ilg.Emit(OpCodes.Call,cinfo)",116],["ilg.Emit(OpCodes.Readonly)",121],["ilg.Emit(OpCodes.Stloc, lb)",122],["ilg.Emit(OpCodes.Ldloc, lb)",122],["ilg.Emit(OpCodes.Ret)",139],["ilg.Emit(OpCodes.Ldarg_0)",251],["ilg.Emit(OpCodes.Br, before)",122]],"useCount":9317},{"word":"Operators","context":[["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",195],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : SynExpr)) in",63],["open Operators",65],["(\"( + )\", \"Microsoft.FSharp.Core.Operators.( + )\", \"file2\",",77],["module Operators =",89],["Microsoft.FSharp.Core.Operators.box",3597],["/// [category:Operators]",379],["open Microsoft.FSharp.Core.Operators",304],["let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",115],["open Suave.Operators",91]],"useCount":12422},{"word":"Option","context":[["Option.ofString",77],["|> Option.map fst",72],["with get () = Option.get _type",70],["with get () = Option.get _visible",63],["with get () = Option.get _y",64],["with get () = Option.get _x",64],["//        with get () = Option.get _role",66],["|> Option.isSome",97],["|> Option.get",129],["module Option =",169]],"useCount":8040},{"word":"Options","context":[["/// <param name=\"Options\">The chart's options.</param>",159],["let options = defaultArg Options <| Configuration.Options()",119],["let options = defaultArg Options <| Configuration.Options()",119],["|> LockFileSerializer.serializePackages cfg.Groups.[Constants.MainDependencyGroup].Options",115],["if debug env <| Options.Other \"Rel\"",55],["lockFile.Options.Strict |> shouldEqual false",48],["if Env.debug env Options.High",36],["cfg.Groups.[Constants.MainDependencyGroup].Options.Strict |> shouldEqual false",121],["cfg.Groups.[Constants.MainDependencyGroup].Options.Settings.OmitContent |> shouldEqual None",33],["if debug env Options.Low",32]],"useCount":2200},{"word":"PackageName","context":[["getVersion resolved.[PackageName \"Castle.Windsor\"] |> shouldEqual \"3.2.1\"",76],["InstallModel.CreateFromLibs(PackageName \"Fantomas\", SemVer.Parse \"1.5.0\", [],",57],["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"NUnit\"].Version",57],["{ Name : PackageName",82],["getVersion resolved.[PackageName \"Nancy.Bootstrappers.Windsor\"] |> shouldEqual \"0.23\"",107],["let p = cfg.Groups.[Constants.MainDependencyGroup].Packages |> List.find (fun x-> x.Name = PackageName \"Foobar\")",52],["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"Castle.Windsor\"].Version",47],["getVersion resolved.[PackageName \"Castle.Windsor-NLog\"] |> shouldEqual \"3.3.0\"",43],["details.Dependencies |> List.map (fun (x,_,_) -> x) |> shouldContain (PackageName \"MySql.Data\")",42],["getVersion resolved.[PackageName \"Castle.Core\"] |> shouldEqual \"3.3.1\"",41]],"useCount":2873},{"word":"Paket","context":[["open Paket.PackageSources",240],["open Paket.Logging",381],["open Paket.Requirements",549],["<Paket>True</Paket>",856],["<Paket>True</Paket>",856],["open Paket.Domain",952],["open Paket",986],["open Paket.PackageResolver",152],["﻿namespace Paket",158],["open Paket.TestHelpers",217]],"useCount":7783},{"word":"Parameters","context":[["Parameters= mkILParametersRaw actual_args;",30],["assert_equal DBNull.Value ps.Parameters.[0].Value",27],["assert_equal 2 ps.Parameters.Length",36],["cmd.Parameters.Add pkParam |> ignore",26],["sqlCmd.Parameters.Add(new SQLiteParameter(name,value)) |> ignore",31],["/// [category:Parameters and results of various operations]",31],["printfn \"%A\" ps.Parameters",84],["assert_equal 1 ps.Parameters.Length",124],["/// Parameters:",139],["/// ## Parameters",2369]],"useCount":3863},{"word":"Parse","context":[["this.Parse \"\"\"",656],["this.Parse(\"\"\"",240],["let lockFile = LockFile.Parse(\"\",toLines lockFileData)",100],["] |> List.map Guid.Parse |> Set.ofList",85],["use unwindBuildPhase = PushThreadBuildPhaseUntilUnwind (BuildPhase.Parse)",71],["p.VersionRequirement.Range |> shouldEqual (VersionRange.Specific (SemVer.Parse \"1.2.3\"))",64],["static member Parse =",62],["InstallModel.CreateFromLibs(PackageName \"Fantomas\", SemVer.Parse \"1.5.0\", [],",57],["use unwindBP = PushThreadBuildPhaseUntilUnwind (BuildPhase.Parse)",57],["|> JsonValue.Parse",56]],"useCount":4597},{"word":"Parser","context":[["| Parser.Success (mAst) ->",34],["| Parser.Success(mAst) ->",34],["open Parser",76],["open Microsoft.FSharp.Compiler.Parser",67],["module Parser =",58],["| Parser.EOF _ -> false",52],["| Parser.Success (mAst, _, errors) ->",38],["open FStar.Parser",34],["| Parser.Success (mAst, _, _) ->",32],["| Parser.Error (num, tok, err) -> printErr (num, tok, err)",34]],"useCount":9807},{"word":"Parsing","context":[["with Parsing.RecoverableParseError ->",27],["info |> Parsing.isContentAutomaticArchiving |> should be False",28],["info |> Parsing.isContentReplication |> should be False",27],["let tables () : Microsoft.FSharp.Text.Parsing.Tables<_> =",38],["module Parsing =",38],["parseError = (fun (ctxt:Microsoft.FSharp.Text.Parsing.ParseErrorContext<_>) ->",38],["raise (Microsoft.FSharp.Text.Parsing.Accept(Microsoft.FSharp.Core.Operators.box _1))",45],["open Microsoft.FSharp.Text.Parsing.ParseHelpers",49],["(fun (parseState : Internal.Utilities.Text.Parsing.IParseState) ->",1046],["(fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->",2648]],"useCount":4483},{"word":"Path","context":[["/// <param name=\"path\">Path to file.</param>",68],["/// <param name=\"path\">Path to input file.</param>",85],["let projFileName = Path.ChangeExtension(base2, \".fsproj\")",436],["let dllName = Path.ChangeExtension(base2, \".dll\")",436],["let assemblyShortName = Path.GetFileNameWithoutExtension assemblyFileName",64],["assembly.DefineDynamicModule(\"MainModule\", Path.GetFileName assemblyFileName)",64],["assembly.Save (Path.GetFileName assemblyFileName)",64],["let base2 = Path.GetTempFileName()",436],["let fileName1 = Path.ChangeExtension(Path.GetTempFileName(), \".fs\")",503],["let fileName1 = Path.ChangeExtension(Path.GetTempFileName(), \".fs\")",503]],"useCount":9229},{"word":"Patterns","context":[["open Microsoft.FSharp.Quotations.Patterns",300],["| Quotations.Patterns.NewRecord(ci, es) ->",56],["| Quotations.Patterns.NewUnionCase(ci, es) ->",56],["| Quotations.Patterns.IfThenElse(cond, ifTrue, ifFalse) ->",56],["| Quotations.Patterns.Sequential(e1, e2) ->",56],["| Quotations.Patterns.Var v ->",56],["| Quotations.Patterns.Call (objOpt,meth,args) ->",55],["| Quotations.Patterns.VarSet(v,e) ->",55],["| Quotations.Patterns.PropertySet(obj,propInfo,args,v) ->",55],["| Quotations.Patterns.Let(v,e,b) ->",55]],"useCount":2955},{"word":"Position","context":[["let! point = buffer.GetSnapshotPoint view.Caret.Position",71],["override __.Position = 0",64],["vec3 Position;",32],["let lineStart = snapshot.GetLineNumberFromPosition(span.Span.Start.Position) + 1",31],["let pos = ms.Position",58],["let smblEOF = Smbl(char 65535,  Unchecked.defaultof<Position<_>>)",32],["let handlerStart = codebuf.code.Position",52],["match buffer.GetSnapshotPoint view.Caret.Position, currentWord with",45],["let handlerFinish = codebuf.code.Position",52],["stream.Position <- 0L",46]],"useCount":2281},{"word":"Preconditions","context":[["// Preconditions checked by the target method.",20],["// Preconditions checked by the member.",20],["// Preconditions are checked by the member.",78],["// Preconditions",3429]],"useCount":3547},{"word":"Private","context":[["let mutable fieldAttrs = FieldAttributes.Private",52],["<Private>True</Private>",699],["( Private words )",220],["<Private>True</Private>",699],["let typeInitializerAttributes = MethodAttributes.Static ||| MethodAttributes.Private",50],["tb.DefineField(ctorArg.Name, convType ctorArg.ParameterType, FieldAttributes.Private) ]",53],["| Private",54],["if mdef.Access <> ILMemberAccess.Private then",32],["with get() = ctorAttributes.HasFlag(MethodAttributes.Static) && ctorAttributes.HasFlag(MethodAttributes.Private)",32],["| Private",115]],"useCount":2700},{"word":"Project","context":[["Project = project",75],["// Math.NET Numerics, part of the Math.NET Project",41],["Project : string",45],["|> addAttribute \"Project\" fileName",48],["Project = \"\"",209],["| [<CustomCommandLine(\"project\")>] Project of string",59],["Project = \"FAKE\"",190],["<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",113],["</Project>",85],["</Project>\"\"\"",67]],"useCount":2524},{"word":"Property","context":[["Some(Item.Property (nm,pinfos))",34],["codedBigness 1 TableNames.Property",33],["[| for m in this.GetMembers bindingAttr do if m.MemberType.HasFlag(MemberTypes.Property) then yield downcast m |]",63],["override this.MemberType : MemberTypes = MemberTypes.Property",49],["codedBigness 2 TableNames.Property",33],["| Item.Property (nm,pinfos) ->",40],["codedBigness 5 TableNames.Property ||",33],["[<Property>]",1409],["[<Property(QuietOnSuccess = true)>]",89],["| Item.Property(_,pinfos) ->",83]],"useCount":3220},{"word":"ProvidedTypeDefinition","context":[["let otherNamespaces = ResizeArray<string * list<ProvidedTypeDefinition>>()",63],["| :? ProvidedTypeDefinition as ti -> System.Object.ReferenceEquals(this,ti)",63],["| :? ProvidedTypeDefinition  as t -> t.DeclaringTypeImpl <- this",63],["let rec typeMembers (tb:TypeBuilder)  (td : ProvidedTypeDefinition) =",63],["let rec typeMembers (ptd : ProvidedTypeDefinition) =",64],["| :? ProvidedTypeDefinition as pntd -> typeMembers pntd",64],["| :? ProvidedTypeDefinition as ptd ->",64],["| :? ProvidedTypeDefinition as pntd ->",64],["| None -> failwith \"ProvidedTypeDefinition: DefineStaticParameters was not called\"",79],["| :? ProvidedTypeDefinition as t ->",80]],"useCount":2163},{"word":"Public","context":[["| Public",106],["TypeAttributes.Public |||",118],["let ALL = BindingFlags.Public ||| BindingFlags.NonPublic ||| BindingFlags.Static ||| BindingFlags.Instance",51],["﻿// This Source Code Form is subject to the terms of the Mozilla Public",58],["| Public",52],["let bindingFlags = defaultArg bindingFlags BindingFlags.Public",115],["let mutable methodAttrs   = MethodAttributes.Public",63],["| TypeAttributes.Public when isNested -> TypeAttributes.NestedPublic",67],["let ctor = lambda.DefineDefaultConstructor(MethodAttributes.Public)",51],["| TypeAttributes.NestedPublic when not isNested -> TypeAttributes.Public",67]],"useCount":2293},{"word":"Push","context":[["// Push the children onto the stack.",28],["stack.Push(CompileTarget expr)",30],["CG.EmitInstr cgbuf (pop 1) (Push [cenv.g.ilg.typ_Exception]) (I_castclass cenv.g.ilg.typ_Exception);",33],["stack.Push r",56],["// Push the non-empty child onto the stack.",28],["stack.Push <| MapTree.Singleton kvp",28],["stack.Push z",28],["stack.Push l",56],["stack.Push(Compiling (fun gen ->",61],["CG.EmitInstr cgbuf (pop args.Length) (Push [typ])",28]],"useCount":1875},{"word":"Quotations","context":[["open Microsoft.FSharp.Quotations.DerivedPatterns",125],["open Microsoft.FSharp.Quotations.Patterns",300],["let mutable invokeCode    = None : option<Quotations.Expr list -> Quotations.Expr>",104],["[| for v in parameterVars -> Quotations.Expr.Var v |]",107],["yield Quotations.Var(p.Name, p.ParameterType) |]",107],["let locals = Dictionary<Quotations.Var,LocalBuilder>()",105],["open Microsoft.FSharp.Quotations",1072],["let mutable invokeCode    = None : option<Quotations.Expr list -> Quotations.Expr>",104],["with set  (q:Quotations.Expr list -> Quotations.Expr) =",104],["with set  (q:Quotations.Expr list -> Quotations.Expr) =",104]],"useCount":9904},{"word":"REVIEW","context":[["// REVIEW: for IL properties this is getter OR setter. For F# properties it is getter ELSE setter",34],["// REVIEW: write into an accumuating buffer",78],["// REVIEW: consider if we need to show _cxs (the type parameter constrants)",204],["// REVIEW: this could be faster, e.g. by storing the index in the NameMap",34],["// REVIEW: need a better test for this",34],["// REVIEW: this uses equality on ILType.  For CMOD_OPTIONAL this is not going to be correct",34],["// REVIEW: systematically eliminate foldMap/mapFold duplication",33],["override this.ReturnParameter = null // REVIEW: Give it a name and type?",45],["// REVIEW: fold this into ILMethodDef",47],["if ty.Name = t.Name (* REVIEW: use equality? *) then",62]],"useCount":2648},{"word":"Range","context":[["let m = expr.Range",265],["let m = e.Range",79],["dive synExpr2 synExpr2.Range traverseSynExpr]",90],["if AstTraversal.rangeContainsPosLeftEdgeInclusive synExpr.Range pos then",90],["[dive synExpr synExpr.Range traverseSynExpr",90],["Range.range0",146],["open Microsoft.FSharp.Compiler.Range",183],["member this.Range =",203],["let m = tycon.Range",330],["open Microsoft.FSharp.Compiler.Range",842]],"useCount":14086},{"word":"Read","context":[["use fileStream = new FileStream (path, FileMode.Open, FileAccess.Read, FileShare.Read)",24],["[ while reader.Read() do",95],["reader.Read() |> ignore",31],["match reader.Read() with",52],["let n = stream.Read(buf, 0, int rem)",59],["use zip = new ZipArchive(zipToCreate,ZipArchiveMode.Read)",28],["let cts = Volatile.Read( ctsRef )",24],["while reader.Read() do",101],["jsonReader.Read() |> ignore",26],["use fileStream = new FileStream (path, FileMode.Open, FileAccess.Read, FileShare.Read)",24]],"useCount":2069},{"word":"Reference","context":[["<Reference Include=\"System.Net.Http.Extensions\">",163],["</Reference>",823],["<Reference Include=\"System.Net.Http.Primitives\">",163],["/// Reference implementation:",110],["<Reference Include=\"System.Reactive.Windows.Threading\">",84],["<Reference Include=\"System.Net.Http\">",80],["let methMap = Dictionary<ProvidedMethod, MethodBuilder>(HashIdentity.Reference)",63],["let ctorMap = Dictionary<ProvidedConstructor, ConstructorBuilder>(HashIdentity.Reference)",63],["| Reference.TargetsFile targetsFile ->",61],["| Reference.Library lib ->",61]],"useCount":3027},{"word":"Reflection","context":[["| :? System.Reflection.MethodInfo as minfo ->",69],["open Microsoft.FSharp.Reflection",744],["inherit System.Reflection.PropertyInfo()",67],["open System.Reflection",6185],["open System.Reflection.Emit",264],["inherit System.Reflection.ParameterInfo()",131],["inherit System.Reflection.MethodInfo()",126],["inherit System.Reflection.FieldInfo()",120],["| :? System.Reflection.TargetInvocationException as e ->",99],["open System.Reflection",94]],"useCount":12144},{"word":"Remove","context":[["updateHasReported.Remove (HttpLink \"\") |> ignore",41],["updateHasReported.Remove GistLink |> ignore",41],["updateHasReported.Remove GitHubLink |> ignore",41],["map.Remove(id) |> ignore",30],["Microsoft.FSharp.Collections.FSharpSet`1[T]: Microsoft.FSharp.Collections.FSharpSet`1[T] Remove(T)",28],["// Remove all duplicates. We've put the types first, so this removes the DelegateCtor and DefaultStructCtor's.",27],["member this.Remove() =",25],["member Remove : key:'TKey -> unit",24],["[<CompiledName(\"Remove\")>]",66],["[<Ignore(\"Remove to run test\")>]",799]],"useCount":2083},{"word":"Replace","context":[["match trimmed.Replace(\":\",\"\").Trim().ToLowerInvariant() with",68],["let file = file.Replace('/',System.IO.Path.DirectorySeparatorChar)",36],["let file = file.Replace(\"/\",\"\\\\\")",36],["let path = path.Replace(\"\\\\\", \"/\").ToLower()",38],["let propertyName = \"__paket__\" + fi.Name.ToString().Replace(\" \",\"_\").Replace(\".\",\"_\")",29],["fi.Name.Replace(fi.Extension, \"\")",32],["let group = line.Replace(\"group\",\"\").Trim()",30],["|> addAttribute \"Include\" (fi.Name.Replace(fi.Extension,\"\"))",29],["let propertyName = \"__paket__\" + fi.Name.ToString().Replace(\" \",\"_\").Replace(\".\",\"_\")",29],["let locationFromAppConfig = locationFromAppConfig.Replace(\"{exepath}\", exeAssemblyFolder)",29]],"useCount":1931},{"word":"Represents","context":[["/// Represents the type constructor in a provided symbol type.",68],["/// Represents an erased provided property.",75],["/// Represents data about resolved packages",26],["/// Represents package details",26],["/// Represents a provided static parameter.",34],["/// Represents a provided type definition.",34],["/// Represents an array or other symbolic type involving a provided type as the argument.",68],["/// Represents an erased provided field.",66],["/// Represents an erased provided parameter",40],["/// Represents an erased provided constructor.",37]],"useCount":2082},{"word":"RequireQualifiedAccess","context":[["[<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]",337],["[<RequireQualifiedAccess; StructuralEquality; StructuralComparison>]",54],["[<RequireQualifiedAccess; CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]",58],["and [<RequireQualifiedAccess>]",63],["[<StructuralEquality; StructuralComparison; RequireQualifiedAccess>]",68],["[<StructuralEquality; StructuralComparison; RequireQualifiedAccess>]",84],["[<RequireQualifiedAccess>]",3072],["[<RequireQualifiedAccess>]",818],["[<NoEquality; NoComparison; RequireQualifiedAccess>]",424],["[<NoEquality; NoComparison;RequireQualifiedAccess>]",148]],"useCount":5470},{"word":"ResizeArray","context":[["let li = ResizeArray<_>()",72],["let probingFolders = ResizeArray()",60],["let mutable interfaceImplsDelayed = ResizeArray<unit -> list<Type>>()",61],["let otherNamespaces = ResizeArray<string * list<ProvidedTypeDefinition>>()",63],["let elements = ResizeArray ()",131],["let mutable membersKnown   = ResizeArray<MemberInfo>()",63],["let mutable membersQueue   = ResizeArray<(unit -> list<MemberInfo>)>()",63],["let mutable interfaceImpls = ResizeArray<Type>()",64],["let customAttributes = ResizeArray<CustomAttributeData>()",64],["let mutable methodOverrides = ResizeArray<ProvidedMethod * MethodInfo>()",64]],"useCount":3778},{"word":"Result","context":[["(fun (env : unit -> PrintfEnv<'State, 'Residue, 'Result>) ->",110],["type Result =",66],["| Result _ as res ->",34],["Result   = \"☒\"",34],["| Result _ as res -> ForceRaise res",34],["| Result (res :: _) -> success res",33],["Display.Print \"Solution #1 Result\"",81],["Display.Print \"Solution #2 Result\"",81],["[<ProcedureParam(Direction = Direction.Result)>]",86],["static member Result : ('T -> 'T) = result",153]],"useCount":2191},{"word":"Return","context":[["// Return the final state value.",42],["|> async.Return",42],["/// Return <c>None</c> if no such element exists.</summary>",47],["/// Return the index of the first element in the array",48],["// Return the completed results.",72],["// Return the disposable object that cleans up",76],["/// Return:",83],["// Return the set of structural type definitions which support the relation",40],["| Return",38],["Return=actual_ret;",38]],"useCount":2704},{"word":"Returns","context":[["/// <summary>Returns a new collection containing only the elements of the collection",32],["///O(1). Returns the count of elememts.",34],["/// Returns the installed version of the given package.",40],["/// Returns a supervisor strategy appliable only to child actor which faulted during execution.",41],["/// Returns a supervisor strategy appliable to each supervised actor when any of them had faulted during execution.",41],["/// <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>",44],["/// Returns a data frame that contains the same data as the input,",45],["/// Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)",45],["/// Returns 42",73],["/// Returns a new map made from the given bindings.",72]],"useCount":2190},{"word":"Revision","context":[["// The assembly version has the format {Major}.{Minor}.{Build}.{Revision}",300],["//      Revision",129],["\\  $Date: 2009-05-28 17:35:58 $ $Revision: 1.11 $",32],["// The assembly version has the format \"{Major}.{Minor}.{Build}.{Revision}\".",26],["You can specify all the values or you can default the Build and Revision Numbers",25],["Revision",25],["//       Revision",924],["| v -> Some (uint16 v.Major,uint16 v.Minor,uint16 v.Build,uint16 v.Revision)",19],["let minorRevision = if version.Revision = -1 then 0us else uint16(version.MinorRevision)",16],["// You can specify all the values or you can default the Build and Revision Numbers",1037]],"useCount":2556},{"word":"RunSynchronously","context":[["let wholeProjectResults = checker.ParseAndCheckProject(Project3.options) |> Async.RunSynchronously",44],["Async.RunSynchronously",46],["let wholeProjectResults = checker.ParseAndCheckProject(Project31.options) |> Async.RunSynchronously",50],["let wholeProjectResults = checker.ParseAndCheckProject(Project4.options) |> Async.RunSynchronously",55],["let wholeProjectResults = checker.ParseAndCheckProject(Project25.options) |> Async.RunSynchronously",44],["let wholeProjectResults = checker.ParseAndCheckProject(Project5.options) |> Async.RunSynchronously",44],["let wholeProjectResults = checker.ParseAndCheckProject(Project2.options) |> Async.RunSynchronously",55],["let wholeProjectResults = checker.ParseAndCheckProject(Project1.options) |> Async.RunSynchronously",127],["} |> Async.RunSynchronously",195],["|> Async.RunSynchronously",2171]],"useCount":3949},{"word":"Runtime","context":[["[<MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)>]",128],["System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(E_FAIL)",112],["open FSharp.Data.Runtime",150],["static do Android.Runtime.ResourceIdManager.UpdateIdValues()",189],["open MBrace.Runtime.Utils",218],["open MBrace.Runtime",237],["[<System.Runtime.CompilerServices.Extension>]",325],["open System.Runtime.InteropServices",2660],["open System.Runtime.CompilerServices",2445],["open System.Runtime.Serialization",590]],"useCount":10828},{"word":"RuntimeHelpers","context":[["module RuntimeHelpers =",22],["// RuntimeHelpers.SaveIt has type ('a -> unit), and fetches the System.Type for 'a by using a typeof<'a> call.",21],["System.Runtime.CompilerServices.RuntimeHelpers.Equals(h1,h2) && check t1 t2",19],["Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`2[T1,T2]: System.Type GetType()",18],["| e when System.Runtime.CompilerServices.RuntimeHelpers.Equals(e, NaNException) -> false",36],["Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers: Int32 GetHashCode()",28],["open Microsoft.FSharp.Linq.RuntimeHelpers",116],["Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers: System.Type GetType()",28],["Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers: System.String ToString()",28]],"useCount":2611},{"word":"SR","context":[["if nonNil otherDelayed then error(Error(FSComp.SR.tcInvalidAssignment(),mStmt))",64],["errorR(Error(FSComp.SR.tcOperatorIncorrectSyntax(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",54],["error(Error(FSComp.SR.tcExpectedUnitOfMeasureNotType(), m))",54],["error (Error(FSComp.SR.nrGlobalUsedOnlyAsFirstName(), id.idRange))",68],["if count < 0 then invalidArg \"count\" (SR.GetString(SR.inputMustBeNonNegative))",69],["if count < 0 then invalidArg \"count\" (SR.GetString(SR.inputMustBeNonNegative))",69],["errorR(Error(FSComp.SR.tcInvalidRelationInJoin(nm.idText),relExpr.Range))",72],["errorR(Error(FSComp.SR.parsInvalidLiteralInType(), m))",54],["error(Error(FSComp.SR.tcAttributesInvalidInPatterns(),m))",54],["errorR(Error(FSComp.SR.tcCannotInheritFromErasedType(),m))",54]],"useCount":18753},{"word":"Sealed","context":[["[<Extension;Sealed>]",77],["TypeAttributes.Sealed",53],["TypeAttributes.Sealed |||",66],["[<AbstractClass; Sealed; Extension>]",83],["[<NoEquality; NoComparison; Sealed>]",85],["[<Sealed; DataContract>]",87],["and [<AllowNullLiteral; Sealed>]",91],["[<Sealed>]",1532],["[<Sealed>]",2093],["[<Sealed; AutoSerializable(false)>]",161]],"useCount":4966},{"word":"Seq","context":[["|> Seq.toArray",1381],["|> Seq.toList",2561],["|> Seq.concat",755],["|> Seq.distinct",526],["|> Seq.sortBy fst",500],["// null Seq",474],["Seq.empty",367],["// integer Seq",353],["|> Seq.head",352],["// string Seq",431]],"useCount":26396},{"word":"Sequential","context":[["| Quotations.Patterns.Sequential(e1, e2) ->",56],["| Quotations.Patterns.Sequential(e',vexpr') ->",50],["Quotations.Expr.Sequential(e', inlineByref v vexpr' bexpr)",50],["[<Struct; StructLayout(LayoutKind.Sequential)>]",46],["Expr.Sequential(recdExpr,setExpr,ThenDoSeq,SuppressSequencePointOnExprOfSequential,m)",36],["/// Sequential application",100],["[<StructLayout (LayoutKind.Sequential)>]",100],["[<StructLayout(LayoutKind.Sequential)>]",554],["Expr.Sequential(",34],["| SynExpr.Sequential (_,_,_,_,m)",31]],"useCount":2111},{"word":"Set","context":[["/// Set the quotation used to compute the implementation of gets of this property.",68],["Set.empty",76],["] |> List.map Guid.Parse |> Set.ofList",85],["|> Set.toList",97],["/// Set the function used to compute the implementation of sets of this property.",68],["|> Set.ofList",459],["|> Set.ofArray",148],["Dependencies = Set.empty",145],["|> Set.unionMany",110],["|> Set.ofSeq",563]],"useCount":7292},{"word":"Single","context":[["// Single",54],["| Single of single",73],["| TypeCode.Single",52],["| Single",43],["| Single of single",36],["| Single",35],["| Const.Single _",35],["| \"System.Single\"",31],["FSharpToolTipElement.Single(text, xml)",115],["| Const.Single d      ->",31]],"useCount":1908},{"word":"Some","context":[["| Some info ->",318],["| Some x -> x",759],["| Some x ->",237],["| Some group ->",309],["| Some v -> v",311],["| Some e ->",361],["| Some v ->",401],["|> Some",582],["| Some res -> res",582],["| Some _ ->",599]],"useCount":79260},{"word":"Stamp","context":[["assumedTycons.Contains tcref.Stamp",40],["let graph = Graph<Tycon, Stamp> ((fun tc -> tc.Stamp), tycons, edges)",40],["if assumedTyparsActual.Contains(tp.Stamp) then",40],["let rec loop (assumedTycons : Set<Stamp>) (assumedTypars: Set<Stamp>) =",40],["let rec loop (assumedTycons : Set<Stamp>) (assumedTypars: Set<Stamp>) =",40],["let graph = Graph<Tycon, Stamp> ((fun tc -> tc.Stamp), tycons, edges)",40],["let tpn = tp.Stamp",42],["Stamp = newStamp()",54],["yield tycon.Stamp ]",40],["(if initialAssumedTycons.Contains tcref.Stamp then",40]],"useCount":2464},{"word":"Start","context":[["sw.Start()",489],["|> Async.Start",117],["timer.Start()",87],["member this.Start() =",47],["stopwatch.Start()",61],["} |> Async.Start",117],["watch.Start()",60],["member __.Init () = session.Start()",58],["stopWatch.Start()",50],["MailboxProcessor.Start(fun inbox ->",47]],"useCount":2834},{"word":"State","context":[["// State",311],["if con.State <> ConnectionState.Open then con.Open()",118],["member x.State = state",99],["(fun (env : unit -> PrintfEnv<'State, 'Residue, 'Result>) ->",110],["(* State 0 *)",58],["(* State 2 *)",58],["(* State 1 *)",58],["(* State 3 *)",58],["(* State 4 *)",58],["(* State 5 *)",57]],"useCount":5822},{"word":"String","context":[["let lower = String.lowercase filename",88],["|> String.concat \"\"",130],["viewResult.ViewName =! String.Empty",84],["|> String.concat \", \"",80],["|> String.concat \"\\n\"",102],["if String.forall (fun c -> System.Char.IsDigit(c) || c = '-')  s",69],["module String =",139],["| String of string",118],["|> String.concat \",\"",108],["|> String.concat \" \"",102]],"useCount":17748},{"word":"StringBuilder","context":[["let sb = Text.StringBuilder()",80],["let sb = new StringBuilder()",195],["let sb = StringBuilder()",173],["new StringBuilder()",128],["let sb = System.Text.StringBuilder()",109],["System.Text.StringBuilder()",105],["let sb = new System.Text.StringBuilder()",82],["let sb = StringBuilder ()",49],["let os = System.Text.StringBuilder()",54],["let os = StringBuilder()",49]],"useCount":1986},{"word":"SymbolKind","context":[["| SymbolKind.Pointer,[arg] -> arg.FullName + \"*\"",56],["| SymbolKind.Array _ -> typeof<System.Array>",57],["type SymbolKind =",70],["override this.MakeArrayType arg = ProvidedSymbolType(SymbolKind.Array arg, [this]) :> Type",73],["override this.MakeArrayType() = ProvidedSymbolType(SymbolKind.SDArray, [this]) :> Type",74],["| SymbolKind.Pointer -> typeof<System.ValueType>",57],["| SymbolKind.SDArray -> typeof<System.Array>",57],["| SymbolKind.ByRef -> typeof<System.ValueType>",57],["| SymbolKind.Generic gty,_ -> gty",56],["| SymbolKind.ByRef,[arg] -> arg",56]],"useCount":3100},{"word":"SynExpr","context":[["| SynExpr.Ident id -> id.idRange",65],["| SynExpr.LetOrUseBang _",62],["| SynExpr.ImplicitZero m ->",58],["| SynExpr.LibraryOnlyStaticOptimization _",58],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : SynExpr)) in",63],["| SynExpr.YieldOrReturnFrom (_,_,m)",64],["| SynExpr.YieldOrReturn (_,_,m)",64],[": SynExpr));",115],[": Ast.SynExpr));",102],["| SynExpr.ImplicitZero _",77]],"useCount":15588},{"word":"SynMemberDefn","context":[["| SynMemberDefn.ImplicitCtor _",88],["| SynMemberDefn.ValField _",43],["| SynMemberDefn.Inherit _",42],["| SynMemberDefn.ImplicitInherit _ -> true",40],["| SynMemberDefn.ImplicitInherit _",40],["| SynMemberDefn.AutoProperty _",54],["| SynMemberDefn.LetBindings _",74],["| SynMemberDefn.ImplicitCtor _ -> true",40],["| SynMemberDefn.Member _",38],["| SynMemberDefn.Open _",125]],"useCount":2376},{"word":"SynPat","context":[["SynPat *",35],["PushOnePatternToRhs cenv true (SynPat.Const(SynConst.Unit,m)) rhsExpr,",36],["| SynPat.Paren(SynPat.Const (SynConst.Unit,m),_)",23],["| SynPat.Paren(SynPat.Const (SynConst.Unit,m),_)",23],["| SynPat.Paren(SynPat.Tuple (ps,m),_) ->",23],["| SynPat.Typed(p',ty,m) ->",46],["| SynPat.Paren(SynPat.Tuple (ps,m),_) ->",23],["| SynPat.Const (SynConst.Unit,m) ->",23],["SynPat =",23],["| SynPat.Tuple (ps,m)",23]],"useCount":2675},{"word":"System","context":[["open System.IO",7314],["open System.Runtime.InteropServices",2660],["open System.Collections.Generic",5952],["open System.Diagnostics",2178],["open System.Text",2206],["open System",18368],["open System.Threading",2129],["open System.Runtime.CompilerServices",2445],["﻿namespace System",1402],["open System.Reflection",6185]],"useCount":144001},{"word":"T","context":[["type T() =",102],["// M<'T> -> M<'T> -> M<'T>",110],["static member Result : ('T -> 'T) = result",153],["static member Result : ('T -> 'T) = result",153],["// M<'T> -> M<'T> -> M<'T>",110],["// M<'T> -> M<'T> -> M<'T>",110],["static let result : ('T -> 'T) =",153],["static let result : ('T -> 'T) =",153],["interface IEnumerable<'T> with",195],["let aty = typeof<'T>",274]],"useCount":58197},{"word":"T1","context":[["Microsoft.FSharp.Core.FSharpChoice`4+Choice3Of4[T1,T2,T3,T4]: Int32 Tag",28],["member Item1 : 'T1 with get",72],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1,T2][] Zip[T1,T2](T1[], T2[])",28],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1,T2][] Zip[T1,T2](T1[], T2[])",28],["Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4]: Boolean Equals(Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4])",28],["Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4]: Boolean Equals(Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4])",28],["Microsoft.FSharp.Core.FSharpChoice`6+Choice3Of6[T1,T2,T3,T4,T5,T6]: Boolean get_IsChoice3Of6()",28],["Microsoft.FSharp.Core.FSharpChoice`4+Choice2Of4[T1,T2,T3,T4]: System.Type GetType()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice5Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean IsChoice3Of7",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice4Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean IsChoice2Of7",28]],"useCount":27725},{"word":"T2","context":[["Microsoft.FSharp.Core.FSharpChoice`5+Choice5Of5[T1,T2,T3,T4,T5]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`5+Choice1Of5[T1,T2,T3,T4,T5]: Int32 Tag",28],["Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4]: Boolean Equals(Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4])",28],["Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4]: Boolean Equals(Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4])",28],["member Item2 : 'T2 with get",63],["Microsoft.FSharp.Core.FSharpChoice`3+Choice3Of3[T1,T2,T3]: Boolean get_IsChoice1Of3()",28],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1,T2][] Zip[T1,T2](T1[], T2[])",28],["Microsoft.FSharp.Core.FSharpChoice`6+Choice2Of6[T1,T2,T3,T4,T5,T6]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1,T2][] Zip[T1,T2](T1[], T2[])",28],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1,T2][] Zip[T1,T2](T1[], T2[])",28]],"useCount":27323},{"word":"T3","context":[["Microsoft.FSharp.Core.FSharpChoice`3+Tags[T1,T2,T3]: Boolean Equals(System.Object)",28],["member Item3 : 'T3 with get",54],["Microsoft.FSharp.Core.FSharpChoice`5+Tags[T1,T2,T3,T4,T5]: Int32 Choice2Of5",28],["Microsoft.FSharp.Core.FSharpChoice`4+Choice3Of4[T1,T2,T3,T4]: Boolean get_IsChoice3Of4()",28],["Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4]: Microsoft.FSharp.Core.FSharpChoice`4[T1,T2,T3,T4] NewChoice2Of4(T2)",28],["Microsoft.FSharp.Core.FSharpChoice`5+Tags[T1,T2,T3,T4,T5]: Int32 GetHashCode()",28],["Microsoft.FSharp.Core.FSharpChoice`3+Choice3Of3[T1,T2,T3]: T3 get_Item()",28],["Microsoft.FSharp.Core.FSharpChoice`3[T1,T2,T3]: Microsoft.FSharp.Core.FSharpChoice`3+Tags[T1,T2,T3]",28],["Microsoft.FSharp.Core.FSharpChoice`6+Choice3Of6[T1,T2,T3,T4,T5,T6]: Int32 Tag",28],["Microsoft.FSharp.Core.FSharpChoice`3[T1,T2,T3]: Microsoft.FSharp.Core.FSharpChoice`3+Tags[T1,T2,T3]",28]],"useCount":23870},{"word":"T4","context":[["Microsoft.FSharp.Core.FSharpChoice`5[T1,T2,T3,T4,T5]: Boolean get_IsChoice3Of5()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice6Of7[T1,T2,T3,T4,T5,T6,T7]: System.String ToString()",28],["Microsoft.FSharp.Core.FSharpChoice`5[T1,T2,T3,T4,T5]: Microsoft.FSharp.Core.FSharpChoice`5+Choice4Of5[T1,T2,T3,T4,T5]",28],["Microsoft.FSharp.Core.FSharpChoice`5[T1,T2,T3,T4,T5]: Microsoft.FSharp.Core.FSharpChoice`5+Choice4Of5[T1,T2,T3,T4,T5]",28],["Microsoft.FSharp.Core.FSharpChoice`4+Choice2Of4[T1,T2,T3,T4]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice4Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice4Of7()",28],["Microsoft.FSharp.Core.FSharpChoice`6+Choice3Of6[T1,T2,T3,T4,T5,T6]: System.Type GetType()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice3Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice3Of7()",28],["Microsoft.FSharp.Core.FSharpChoice`4+Choice4Of4[T1,T2,T3,T4]: Boolean IsChoice2Of4",28],["member Item4 : 'T4 with get",45]],"useCount":19689},{"word":"T5","context":[["Microsoft.FSharp.Core.FSharpChoice`5+Choice4Of5[T1,T2,T3,T4,T5]: Int32 GetHashCode()",28],["member Item5 : 'T5 with get",36],["Microsoft.FSharp.Core.FSharpChoice`6+Choice2Of6[T1,T2,T3,T4,T5,T6]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice5Of7[T1,T2,T3,T4,T5,T6,T7]: T5 Item",28],["Microsoft.FSharp.Core.FSharpChoice`5+Choice4Of5[T1,T2,T3,T4,T5]: Boolean IsChoice1Of5",28],["Microsoft.FSharp.Core.FSharpChoice`5+Choice5Of5[T1,T2,T3,T4,T5]: System.String ToString()",28],["Microsoft.FSharp.Core.FSharpChoice`5+Choice1Of5[T1,T2,T3,T4,T5]: Boolean IsChoice4Of5",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice7Of7[T1,T2,T3,T4,T5,T6,T7]: T7 get_Item()",28],["Microsoft.FSharp.Core.FSharpChoice`6+Tags[T1,T2,T3,T4,T5,T6]: Int32 Choice1Of6",28],["Microsoft.FSharp.Core.FSharpChoice`5+Choice3Of5[T1,T2,T3,T4,T5]: Int32 Tag",28]],"useCount":15700},{"word":"T6","context":[["Microsoft.FSharp.Core.FSharpChoice`6+Choice4Of6[T1,T2,T3,T4,T5,T6]: Boolean IsChoice5Of6",28],["Microsoft.FSharp.Core.FSharpChoice`6+Choice6Of6[T1,T2,T3,T4,T5,T6]: Int32 Tag",28],["Microsoft.FSharp.Core.FSharpChoice`6[T1,T2,T3,T4,T5,T6]: Boolean get_IsChoice1Of6()",28],["Microsoft.FSharp.Core.FSharpChoice`6+Choice2Of6[T1,T2,T3,T4,T5,T6]: Boolean get_IsChoice1Of6()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice3Of7[T1,T2,T3,T4,T5,T6,T7]: Int32 CompareTo(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`6+Choice5Of6[T1,T2,T3,T4,T5,T6]: Boolean get_IsChoice1Of6()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice4Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice5Of7()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice7Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean IsChoice2Of7",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice1Of7[T1,T2,T3,T4,T5,T6,T7]: System.Type GetType()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice7Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice3Of7()",28]],"useCount":11283},{"word":"T7","context":[["Microsoft.FSharp.Core.FSharpChoice`7+Choice3Of7[T1,T2,T3,T4,T5,T6,T7]: Int32 GetHashCode()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice6Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice7Of7()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Tags[T1,T2,T3,T4,T5,T6,T7]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice5Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice5Of7()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice4Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice1Of7()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice6Of7[T1,T2,T3,T4,T5,T6,T7]: T6 get_Item()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice5Of7[T1,T2,T3,T4,T5,T6,T7]: T5 Item",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice2Of7[T1,T2,T3,T4,T5,T6,T7]: System.Type GetType()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice7Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean IsChoice3Of7",28],["Microsoft.FSharp.Core.FSharpChoice`7+Choice4Of7[T1,T2,T3,T4,T5,T6,T7]: Boolean get_IsChoice6Of7()",28]],"useCount":6370},{"word":"THEN","context":[["THEN",7615],["[ [THEN] ]",187],["|> THEN <| ASM_REWRITE_TAC []",174],["|> THEN <| DISCH_TAC",139],["|> THEN",286],["THEN ;",639],["THEN                                    \\ FI",132],["|> THEN <| GEN_TAC",103],["[THEN]",2639],["|> THEN <| CONJ_TAC",113]],"useCount":14496},{"word":"TOKEN","context":[["| Parser.TOKEN_INTERFACE -> getErrorString(\"Parser.TOKEN.INTERFACE\")",20],["| Parser.TOKEN_YIELD_BANG  -> getErrorString(\"Parser.TOKEN.YIELD.BANG\")",20],["| Parser.TOKEN_WHITESPACE -> getErrorString(\"Parser.TOKEN.WHITESPACE\")",20],["| Parser.TOKEN_YIELD -> getErrorString(\"Parser.TOKEN.YIELD\")",20],["| Parser.TOKEN_KEYWORD_STRING -> getErrorString(\"Parser.TOKEN.KEYWORD_STRING\")",20],["| Parser.TOKEN_RARROW -> getErrorString(\"Parser.TOKEN.RARROW\")",20],["| Parser.TOKEN_NULL   -> getErrorString(\"Parser.TOKEN.NULL\")",20],["| Parser.TOKEN_REC   -> getErrorString(\"Parser.TOKEN.REC\")",20],["| Parser.TOKEN_EXCEPTION   -> getErrorString(\"Parser.TOKEN.EXCEPTION\")",20],["| Parser.TOKEN_INFIX_STAR_DIV_MOD_OP -> getErrorString(\"Parser.TOKEN.INFIX.STAR.DIV.MOD.OP\")",20]],"useCount":3050},{"word":"TOp","context":[["| TOp.For _",31],["| TOp.Bytes bytes,[],[] ->",28],["| TOp.ExnFieldSet _",28],["| TOp.Coerce",31],["(Expr.Op(TOp.Label label,[],[],m))",36],["| TOp.RefAddrGet",35],["| TOp.Bytes _",35],["| TOp.UInt16s _",35],["| TOp.Array",35],["| TOp.TryCatch _",31]],"useCount":7871},{"word":"TResult","context":[["Microsoft.FSharp.Collections.ArrayModule: T MinBy[T,TResult](Microsoft.FSharp.Core.FSharpFunc`2[T,TResult], T[])",28],["Microsoft.FSharp.Collections.ArrayModule: T MinBy[T,TResult](Microsoft.FSharp.Core.FSharpFunc`2[T,TResult], T[])",28],["Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult]: Int32 GetHashCode()",28],["Microsoft.FSharp.Collections.ArrayModule: T MaxBy[T,TResult](Microsoft.FSharp.Core.FSharpFunc`2[T,TResult], T[])",28],["Microsoft.FSharp.Core.LanguagePrimitives: TResult CheckedMultiplyDynamic[T1,T2,TResult](T1, T2)",28],["Microsoft.FSharp.Core.LanguagePrimitives: TResult CheckedMultiplyDynamic[T1,T2,TResult](T1, T2)",28],["Microsoft.FSharp.Collections.ArrayModule: T MaxBy[T,TResult](Microsoft.FSharp.Core.FSharpFunc`2[T,TResult], T[])",28],["Microsoft.FSharp.Core.Operators: TResult ToEnum[TResult](Int32)",28],["Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult]: TResult Invoke(T1, T2)",28],["Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult]: TResult Invoke(T1, T2)",28]],"useCount":3081},{"word":"TType","context":[["TType *",62],["exception CoercionTargetSealed of DisplayEnv * TType * range",20],["let rec checkIfFieldTypeSupportsComparison (tycon: Tycon) (ty: TType) =",20],["isinstVals: ValMap<TType * Expr>",22],["member HasOverride : TcGlobals -> string -> TType list -> bool",34],["member HasInterface : TcGlobals -> TType -> bool",34],["exception RuntimeCoercionSourceSealed of DisplayEnv * TType * range",20],["exception UnitTypeExpected of DisplayEnv * TType * bool * range",20],["exception Recursion of DisplayEnv * Ident * TType * TType  * range",20],["exception IndeterminateRuntimeCoercion of DisplayEnv * TType * TType * range",20]],"useCount":8924},{"word":"TType_app","context":[["| TType_app (tc1,l1)  ,TType_app (tc2,l2) when tyconRefEq g tc1 tc2  ->",56],["| TType_app (tc1,l1)  ,TType_app (tc2,l2) when tyconRefEq g tc1 tc2  ->",56],["| TType_app (tc,tinst) ->",39],["| TType_app (tcref,tinst)   ->",38],["| TType_app (_,l)",36],["| TType_app (tcref,tinst) ->",35],["| TType_app (tcref,_) -> Some tcref",28],["| Item.Types (_,(TType_app(tcref,_) :: _)) -> 1 + tcref.TyparsNoRange.Length",27],["| Item.FakeInterfaceCtor (TType_app(tcref,_))",27],["| Item.DelegateCtor (TType_app(tcref,_)) -> 1000 + tcref.TyparsNoRange.Length",27]],"useCount":2074},{"word":"Table","context":[["open Microsoft.WindowsAzure.Storage.Table",67],["kindIllegal         (* Table 49 *);",19],["e.SetPkColumnOptionSilent(pkLookup.[e.Table.FullName], None)",30],["module Table =",28],["let pk = pkLookup.[entity.Table.FullName]",57],["(tableMeta.Table.TableName)",43],["let haspk = pkLookup.ContainsKey(entity.Table.FullName)",31],["let pk = if haspk then pkLookup.[entity.Table.FullName] else []",31],["entities |> List.map(fun e -> e.Table)",22],["entity.Table.FullName",25]],"useCount":2865},{"word":"TableNames","context":[["let tidx = readUntaggedIdx TableNames.TypeDef ctxt",35],["codedBigness 1 TableNames.Method",66],["codedBigness 1 TableNames.Field ||",66],["codedBigness 3 TableNames.Method ||",66],["codedBigness 2 TableNames.TypeDef ||",66],["let tidx = seekReadUntaggedIdx TableNames.TypeDef ctxt &addr",55],["AddUnsharedRow cenv TableNames.FieldMarshal",45],["seekReadIndexedRow (ctxt.getNumRows TableNames.TypeDef,",36],["codedBigness 1 TableNames.Method ||",33],["elif tab = TableNames.MemberRef then",36]],"useCount":4827},{"word":"Tags","context":[["Microsoft.FSharp.Core.FSharpChoice`5+Tags[T1,T2,T3,T4,T5]: Int32 Choice4Of5",28],["Microsoft.FSharp.Core.FSharpOption`1[T]: Microsoft.FSharp.Core.FSharpOption`1+Tags[T]",28],["Microsoft.FSharp.Core.FSharpChoice`6+Tags[T1,T2,T3,T4,T5,T6]: Int32 Choice2Of6",28],["Microsoft.FSharp.Core.FSharpChoice`4+Tags[T1,T2,T3,T4]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`2+Tags[T1,T2]: Int32 GetHashCode()",28],["Microsoft.FSharp.Core.FSharpChoice`5+Tags[T1,T2,T3,T4,T5]: System.String ToString()",28],["Microsoft.FSharp.Core.FSharpChoice`7+Tags[T1,T2,T3,T4,T5,T6,T7]: Int32 Choice6Of7",28],["Microsoft.FSharp.Collections.FSharpList`1+Tags[T]: Boolean Equals(System.Object)",28],["Microsoft.FSharp.Core.FSharpChoice`3[T1,T2,T3]: Microsoft.FSharp.Core.FSharpChoice`3+Tags[T1,T2,T3]",28],["Microsoft.FSharp.Collections.FSharpList`1+Tags[T]: Int32 Empty",28]],"useCount":2261},{"word":"TcGlobals","context":[["open Microsoft.FSharp.Compiler.TcGlobals",291],["open Microsoft.FSharp.Compiler.TcGlobals",129],["member x.TcGlobals =",53],["g: TcGlobals;",36],["tcGlobals: TcGlobals,",36],["member x.IsValueType = isStructTy x.TcGlobals x.EnclosingType",34],["member HasOverride : TcGlobals -> string -> TType list -> bool",34],["{ g: TcGlobals",32],["member HasInterface : TcGlobals -> TType -> bool",34],["/// Get the TcGlobals associated with the object",34]],"useCount":7023},{"word":"Test","context":[["Assert.Ignore \"Test not yet implemented.\"",592],["type Test() =",101],["[<Test; Category(\"Generic BCL Types\")>]",112],["[Test Strategy]",119],["[<Test; Category(\"Clone\")>]",120],["group Test",127],["let file = \"/home/user/Test.fsx\"",153],["//    [<Test>]",198],["//[<Test>]",257],["[<Test>]",54659]],"useCount":61340},{"word":"TestFixture","context":[["[<TestFixture; AbstractClass>]",33],["[<TestFixture>]",1699],["[<NUnit.Framework.TestFixture>]",69],["[<TestFixture(Category = \"Acceptance Tests\")>]",11],["[<TestFixture; Category(\"Remote Cluster\")>]",11],["[<TestFixture; Category(\"Standalone Cluster\")>]",14],["[<AbstractClass; TestFixture>]",26],["﻿[<NUnit.Framework.TestFixture>]",43],["[<TestFixture; Category(\"Unit\")>]",29]],"useCount":1935},{"word":"Text","context":[["(fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->",2648],["open Internal.Utilities.Text.Lexing",116],["open Microsoft.FSharp.Text",123],["open Microsoft.VisualStudio.Text.Tagging",174],["open Microsoft.VisualStudio.Text.Editor",231],["open Microsoft.FSharp.Text.Lexing",269],["open Microsoft.VisualStudio.Text",376],["(fun (parseState : Internal.Utilities.Text.Parsing.IParseState) ->",1046],["open System.Text.RegularExpressions",1144],["open System.Text",2206]],"useCount":12139},{"word":"The","context":[["/// <param name=\"value\">The input value.</param>",584],["/// <param name=\"source\">The input sequence.</param>",562],["/// <returns>The result sequence.</returns>",414],["/// <param name=\"array\">The input array.</param>",657],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753],["/// <param name=\"Color\">The color for the data.</param>",753],["/// <param name=\"YTitle\">The title of the Y-axis.</param>",753],["/// <param name=\"Name\">The name of the data set.</param>",753],["/// <param name=\"Title\">The title of the chart.</param>",753],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998]],"useCount":42988},{"word":"These","context":[["// These are some constant expressions which can be accessed from context",85],["// These don't have to return fully accurate results - they are used",60],["/// These options follow the FsiCoreCompilerOptions in the help blocks",21],["/// These options preceed the FsiCoreCompilerOptions in the help blocks",21],["// These are the results of parsing + folding in the implicit file name",21],["// Primitives to help read signatures.  These do not use the file cursor",22],["/// comments eliminated by the lexer.  These carry a specification of",22],["// These occur in the F# quotation form of F# sequence expressions",24],["// These come through as an empty plid and residue \"\". Otherwise we try an environment lookup",24],["/// a true body. These cases are often causes of bugs in the compiler.",60]],"useCount":2019},{"word":"This","context":[["(\"This\",AThis);",2174],["// This file is subject to the terms and conditions defined in",233],["// This file was autogenerated by running the script in this directory",170],["// This file is part of WebSharper",342],["[<CompilerMessage(\"This method is not intended for use from F#.\", 10001, IsHidden=true, IsError=false)>]",132],["// optimized mutation-based implementation. This code is only valid in fslib, where mutation of private",114],["/*  This file is part of Visualization Library                                        */",98],["/// This operation is only supported on ordered series. The method throws",96],["\\ * This program and the accompanying materials",436],["\\ This file is part of Gforth.",664]],"useCount":17781},{"word":"Threading","context":[["let nctx = System.Threading.SynchronizationContext.Current",35],["let cancellationToken = defaultArg cancellationToken (System.Threading.CancellationToken())",35],["let ctx = System.Threading.SynchronizationContext.Current",47],["open System.Threading",2129],["open System.Threading.Tasks",965],["let cts = new System.Threading.CancellationTokenSource()",91],["/// <remarks>Performs the operation in parallel using System.Threading.Parallel.For.",56],["System.Threading.Thread.Sleep 1000",67],["open System.Windows.Threading",76],["<Reference Include=\"System.Reactive.Windows.Threading\">",84]],"useCount":4706},{"word":"Thrown","context":[["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",66],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518],["/// <exception cref=\"System.ArgumentException\">Thrown when the input arrays differ in length.</exception>",71],["/// <exception cref=\"System.ArgumentException\">Thrown when the input sequence is empty.</exception>",73],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["/// <exception cref=\"System.ArgumentException\">Thrown when the list is empty.</exception>",60],["/// <exception cref=\"System.ArgumentException\">Thrown when the input type is not a record type.</exception>",52],["/// <exception cref=\"System.ArgumentException\">Thrown when the input array is empty.</exception>",50],["/// <exception cref=\"Soma.Core.NoAffectedRowException\">Thrown when there is no affected row.</exception>",48],["/// <exception cref=\"System.ArgumentNullException\">Thrown when either of the input sequences is null.</exception>",46]],"useCount":2152},{"word":"Title","context":[["|> Helpers.ApplyStyles(?Name=Name,?Title=Title,?Color=Color,?AxisXTitle=XTitle,?AxisYTitle=YTitle)",388],["Title : string",94],["/// <param name=\"Title\">The title of the axis</param>",56],["Title = title",35],["///                                            Title = \"Title which is shown\"",18],["|> Helpers.ApplyStyles(?Name=Name,?Title=Title,?Color=Color,?AxisXTitle=XTitle,?AxisYTitle=YTitle)",388],["Title = \"\"",25],[".With(\"title\", fun x -> x.Title)",28],["Title: string",33],["/// <param name=\"Title\">The title of the chart.</param>",753]],"useCount":2406},{"word":"ToString","context":[["override this.ToString() = \"Method \" + this.Name",87],["cmd.CommandText <- sb.ToString()",102],[".ToString()",142],["override x.ToString() =",1024],["override this.ToString() =",631],["sb.ToString()",358],["override this.ToString () =",84],["override x.ToString () =",155],["let guid = Guid.NewGuid().ToString(\"D\")",178],["cfg.ToString()",258]],"useCount":16463},{"word":"True","context":[["/// <returns>True if the type check succeeds.</returns>",38],["<Private>True</Private>",699],["<Paket>True</Paket>",856],["Assert.True(result)",108],["Assert.True(EQ expected actual)",66],["|> addChild (this.CreateNode(\"Paket\",\"True\"))",53],["| True",33],["z == x |> should be True",40],["|> should be True",133],["|> addChild (createNodeSet \"Paket\" \"True\" project)",47]],"useCount":2785},{"word":"Tuple","context":[["results <- (curResults |> Tuple.toList) @ results",38],["// convert NewTuple to the call to the constructor of the Tuple type (only for generated types)",60],["// Tuple",59],["| SynExpr.Tuple (_,_,m)",45],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1,T2][] Zip[T1,T2](T1[], T2[])",28],["Microsoft.FSharp.Reflection.FSharpType: System.Tuple`2[System.Type,System.Type] GetFunctionElements(System.Type)",28],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1[],T2[]] Unzip[T1,T2](System.Tuple`2[T1,T2][])",28],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`2[T1[],T2[]] Unzip[T1,T2](System.Tuple`2[T1,T2][])",28],["Microsoft.FSharp.Core.Operators: T1 Fst[T1,T2](System.Tuple`2[T1,T2])",28],["Microsoft.FSharp.Collections.ArrayModule: System.Tuple`3[T1[],T2[],T3[]] Unzip3[T1,T2,T3](System.Tuple`3[T1,T2,T3][])",28]],"useCount":2140},{"word":"Tycon","context":[["let edgesFrom (tycon:Tycon) =",40],["let graph = Graph<Tycon, Stamp> ((fun tc -> tc.Stamp), tycons, edges)",40],["member x.Tycon = x.TyconRef.Deref",40],["Tycon.New \"tycon\"",38],["|> List.choose (fun (tycon:Tycon) -> if tycon.IsILTycon then Some tycon.DisplayName else None)",30],["let addTyconByMangledName (x:Tycon) tab = NameMap.add x.LogicalName x tab",20],["let AddGenericCompareBindings cenv (tycon:Tycon) =",20],["let AddGenericCompareWithComparerBindings cenv (tycon:Tycon) =",20],["let rec checkIfFieldTypeSupportsComparison (tycon: Tycon) (ty: TType) =",20],["///    On entry: the Tycon for the type definition has been created but many of its fields are not",20]],"useCount":2260},{"word":"TyconRef","context":[["/// Tycons available by unqualified, demangled names (i.e. (List,1) --> TyconRef)",34],["let typR = ConvType cenv (mkAppTy rfref.TyconRef tyargs)",32],["let typR = ConvType cenv (mkAppTy ucref.TyconRef tyargs)",32],["// Record the details so we can map System.Type --> TyconRef",36],["CheckEntityAttributes g x.TyconRef m ++ (fun () ->",36],["let tcref = ctorInfo.TyconRef",40],["member x.Tycon = x.TyconRef.Deref",40],["checkEntityIsResolved v.TyconRef",46],["let tcref = tinfo.TyconRef",72],["override x.ToString() = x.TyconRef.ToString() + \"::\" + x.Name",38]],"useCount":4906},{"word":"Typar","context":[["| Typar(id,_,_) ->",20],["type SyntacticUnscopedTyparEnv = UnscopedTyparEnv of NameMap<Typar>",20],["let allConstraints = List.collect (fun (tp:Typar) -> tp.Constraints) generalizedTypars",20],["| TType_var of Typar",20],["let SetTyparRigid _g denv m (tp:Typar) =",20],["Typar =",20],["let rec TrimUngeneralizableTypars genConstrainedTyparFlag inlineFlag (generalizedTypars:Typar list) freeInEnv =",20],["UnscopedTyparEnv (List.fold (fun acc (tp:Typar) -> Map.remove tp.Name acc) tab typars)",20],["let IsCondensationTypar (tp:Typar) =",20],["exception ValueRestriction of DisplayEnv * bool * Val * Typar * range",20]],"useCount":1975},{"word":"TyparConstraint","context":[["| TyparConstraint.MayResolveMember(traitInfo,_) ->",46],["| TyparConstraint.IsNonNullableStruct _",99],["| TyparConstraint.IsReferenceType _",99],["| TyparConstraint.IsUnmanaged _",82],["| TyparConstraint.SupportsNull _ ->",46],["| TyparConstraint.IsNonNullableStruct _ ->",46],["| TyparConstraint.SupportsEquality _",65],["| TyparConstraint.IsReferenceType _ ->",46],["| TyparConstraint.SupportsComparison _",65],["| TyparConstraint.SupportsNull _",82]],"useCount":4289},{"word":"Typars","context":[["let tps = tcref.Typars m",36],["for tp in tycon.Typars(tycon.Range) do",40],["type ExplicitTyparInfo = ExplicitTyparInfo of Tast.Typars * Tast.Typars * bool",20],["member x.Typars                     = x.Deref.Typars",20],["type ExplicitTyparInfo = ExplicitTyparInfo of Tast.Typars * Tast.Typars * bool",20],["let ttps = thisTyconRef.Typars(m)",20],["let env = AddDeclaredTypars CheckForDuplicateTypars (tycon.Typars(m)) env",20],["let tps = tycon.Typars(tycon.Range)",24],["// Typars for F# method or value",32],["let envinner = AddDeclaredTypars CheckForDuplicateTypars (tycon.Typars(m)) envinner",76]],"useCount":2414},{"word":"Type","context":[["inherit Type()",141],["| :? Type as ty ->",101],["let s = if e.Type.IsValueType then ExpectedStackState.Address else ExpectedStackState.Value",176],["Type=ty;",85],["Type: ILType;",80],["override this.MakeArrayType() = ProvidedSymbolType(SymbolKind.SDArray, [this]) :> Type",74],["override this.MakeArrayType arg = ProvidedSymbolType(SymbolKind.Array arg, [this]) :> Type",73],["let ty = v.Type",73],["(t :> Type))",71],["Type: ILType;",68]],"useCount":23254},{"word":"Types","context":[["// Nested Types",64],["open FSharp.Data.GraphQL.Types",63],["module Types =",87],["open Suave.Types",89],["nuget \"Microsoft.SqlServer.Types\"",97],["open Types",245],["open Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types",134],["open VSSonarPlugins.Types",43],["| Item.Types _",44],["[<Test; Category(\"Generic BCL Types\")>]",112]],"useCount":2385},{"word":"U","context":[["// seq<'T> * ('T -> M<'U>) -> seq<M<'U>>",80],["and  ^U : (static member Zero : ^U)",44],["// 'T * ('T -> M<'U>) -> M<'U> when 'U :> IDisposable",44],["let bty = typeof<'U>",47],["// 'T * ('T -> M<'U>) -> M<'U> when 'U :> IDisposable",44],["// seq<'T> * ('T -> M<'U>) -> M<'U>",80],["// seq<'T> * ('T -> M<'U>) -> seq<M<'U>>",80],["// M<'T> * ('T -> M<'U>) -> M<'U>",82],["// M<'T> * ('T -> M<'U>) -> M<'U>",82],["// seq<'T> * ('T -> M<'U>) -> M<'U>",80]],"useCount":3370},{"word":"Unchecked","context":[["let f3hole = ref (Unchecked.defaultof<_>)",54],["let tuple = ref Unchecked.defaultof<_>",56],["let mutable res = Unchecked.defaultof<'res>",62],["let mutable res = Unchecked.defaultof<'Value>",45],["let f4hole = ref (Unchecked.defaultof<_>)",45],["let mutable res = Unchecked.defaultof<_>",250],["let refValue = ref Unchecked.defaultof<_>",126],["Unchecked.defaultof<_>",123],["let f2hole = ref (Unchecked.defaultof<_>)",63],["let f1hole = ref (Unchecked.defaultof<_>)",63]],"useCount":4259},{"word":"UnionCase","context":[["| Item.UnionCase(uci,_) -> uci.Name",30],["| (Item.UnionCase _ | Item.ExnCase _) as item ->",40],["| Item.UnionCase(uci,_) -> Some(ArgumentContainer.UnionCase(uci))",30],["| Item.UnionCase _",32],["let item = Item.UnionCase(GeneralizeUnionCaseRef ucref,false)",36],["| Item.UnionCase(uci,_) -> Some(ArgumentContainer.UnionCase(uci))",30],["| Item.UnionCase(ucinfo,_) ->",36],["Microsoft.FSharp.Core.SourceConstructFlags: Microsoft.FSharp.Core.SourceConstructFlags UnionCase",28],["| [Item.UnionCase _] -> IsOpName nm",27],["| UnionCase uc ->",26]],"useCount":2119},{"word":"Utilities","context":[["(fun (parseState : Internal.Utilities.Text.Parsing.IParseState) ->",1046],["open Microsoft.Build.Utilities",93],["open Internal.Utilities.Debug",79],["open Alea.CUDA.Utilities",68],["open Microsoft.VisualStudio.Utilities",57],["open MBrace.Azure.Runtime.Utilities",55],["open Internal.Utilities.Text.Lexing",116],["open Internal.Utilities.Collections",195],["open Internal.Utilities",220],["open Internal.Utilities",835]],"useCount":3741},{"word":"Utils","context":[["open MBrace.Runtime.Utils.PrettyPrinters",67],["if Utils.IsNull func then",60],["Utils.RunInLockedAccessMode(",390],["open MBrace.Runtime.Utils",218],["open Utils",138],["module Utils =",136],["if Utils.IsNull obj then",113],["Utils.Run q",69],["if Utils.IsNull jobAction then",75],["if Utils.IsNotNull queue && queue.CanSend then",84]],"useCount":4061},{"word":"Val","context":[["| Expr.App(Expr.Val(vf,_,_),_,[tyarg],[startExpr;finishExpr],_)",39],["| ApplicableExpr(_, Expr.App(Expr.Val(vf,_,_),_,_,[],_),_), _",40],["| Expr.Val _ when bind.Var.IsCompilerGenerated ->",22],["// v, dereferencing it to find the corresponding signature Val, and adding an entry for the signature val.",28],["| Expr.Val(vref,flags,m) ->",28],["member TryFind : Val -> 'T option",34],["let exprForVal = Expr.Val (vref,vrefFlags,m)",38],["let addValByName (x:Val) tab =",40],["let freeInBinding = (freeInType CollectAllNoCaching pgrbind.RecBindingInfo.Val.TauType).FreeTypars",40],["Val option *",40]],"useCount":7174},{"word":"ValRef","context":[["let mutable prevIt : ValRef option = None",21],["type ValRef with",38],["| APElemRef of ActivePatternInfo * ValRef * int",20],["let ddg = Graph<ValRef, Stamp>((fun v -> v.Stamp), ddgNodes, !definiteDependencies )",20],["let AdjustAndForgetUsesOfRecValue cenv (vrefTgt: ValRef) (valScheme : ValScheme) =",20],["exception ValNotLocal of DisplayEnv * ValRef * range",20],["ValRef =",20],["| FSAttrib of ValRef",20],["/// Construct a record or object-model value. The ValRef is for self-referential class constructors, otherwise",20],["let RecordUseOfRecValue cenv vrec (vrefTgt: ValRef) vexp m =",20]],"useCount":2801},{"word":"ValReprInfo","context":[["let topValInfo = ValReprInfo ([],[argvs |> List.map (fun _ -> ValReprInfo.unnamedTopArg1)],ValReprInfo.unnamedRetVal)",39],["let topValInfo = ValReprInfo ([],[argvs |> List.map (fun _ -> ValReprInfo.unnamedTopArg1)],ValReprInfo.unnamedRetVal)",39],["let (ValReprInfo(tpNames,args,ret)) = topValInfo",40],["let topValInfo = ValReprInfo ([],[argvs |> List.map (fun _ -> ValReprInfo.unnamedTopArg1)],ValReprInfo.unnamedRetVal)",39],["match vref.ValReprInfo with",119],["match v.ValReprInfo with",188],["let topValInfo = ValReprInfo (ValReprInfo.InferTyparInfo tps,[],ValReprInfo.unnamedRetVal)",39],["let topValInfo = ValReprInfo (ValReprInfo.InferTyparInfo tps,[],ValReprInfo.unnamedRetVal)",39],["let topValInfo = ValReprInfo (ValReprInfo.InferTyparInfo tps,[],ValReprInfo.unnamedRetVal)",39],["let membInfo,topValInfo = checkMemberVal v.MemberInfo v.ValReprInfo v.Range",57]],"useCount":2284},{"word":"Value","context":[["emit ExpectedStackState.Value v",100],["emit ExpectedStackState.Value a1",92],["emit ExpectedStackState.Value pe",112],["emit ExpectedStackState.Value index",112],["emit ExpectedStackState.Value cond",112],["let fsi = FsiSession.Value",138],["let s = if e.Type.IsValueType then ExpectedStackState.Address else ExpectedStackState.Value",176],["emit ExpectedStackState.Value arr",112],["emit ExpectedStackState.Value e",112],["emit ExpectedStackState.Value a2",92]],"useCount":13179},{"word":"Var","context":[["yield Quotations.Var(\"this\", pminfo.DeclaringType)",56],["let expr = qexprf ([for v in vars -> Quotations.Expr.Var v])",52],["[| yield Quotations.Var(\"this\", pcinfo.DeclaringType)",51],["| Quotations.Patterns.Var _ ->",51],["| Quotations.Patterns.Var v ->",56],["Generic (Id \"list\",[Var (Normal \"a\")]))",64],["let locals = Dictionary<Quotations.Var,LocalBuilder>()",105],["[| for v in parameterVars -> Quotations.Expr.Var v |]",107],["yield Quotations.Var(p.Name, p.ParameterType) |]",107],["let v = bind.Var",137]],"useCount":2890},{"word":"Version","context":[["//       Major Version",918],["//       Minor Version",918],["// Version information for an assembly consists of the following four values:",1046],["[<Version>]",245],["let [<Literal>] Version = \"1.0\"",238],["//      Minor Version",129],["//      Major Version",129],["|> Seq.map (fun (KeyValue (_,resolved)) -> (string resolved.Name, string resolved.Version))",112],["Version : string",86],["|> Seq.map (fun (_,r) -> (string r.Name, string r.Version))",77]],"useCount":7775},{"word":"VisualStudio","context":[["open Microsoft.VisualStudio.Text",376],["open Microsoft.VisualStudio.Text.Editor",231],["open Microsoft.VisualStudio.Shell.Interop",230],["open Microsoft.VisualStudio.Text.Tagging",174],["open Microsoft.VisualStudio.Text.Operations",76],["open Microsoft.VisualStudio.OLE.Interop",88],["open Microsoft.VisualStudio.Language.Intellisense",99],["open Microsoft.VisualStudio.TestTools.UnitTesting",132],["open Microsoft.VisualStudio",139],["open Microsoft.VisualStudio.Shell",141]],"useCount":2132},{"word":"Void","context":[["| Void",75],["let returnTypeIsVoid = mappedMeth.ReturnType = typeof<System.Void>",59],["| Void",52],["open Void.Core",31],["Microsoft.FSharp.Core.FSharpOption`1[T]: Void .ctor(T)",28],["Microsoft.FSharp.Control.FSharpEvent`1[T]: Void Trigger(T)",28],["Microsoft.FSharp.Collections.ArrayModule: Void Set[T](T[], Int32, T)",28],["Microsoft.FSharp.Core.DefaultAugmentationAttribute: Void .ctor(Boolean)",28],["Microsoft.FSharp.Core.FSharpRef`1[T]: Void set_Value(T)",28],["Microsoft.FSharp.Core.AutoSerializableAttribute: Void .ctor(Boolean)",28]],"useCount":4644},{"word":"We","context":[["// construct arising out the compilation of pattern matching. We decode these back to the form",44],["// We need a signature in terms of the values' type parameters.",40],["// Note: We suppress the first sequence point in the body of this method since it is the initial state machine jump",48],["// We record the ones for which we have made this assumption.",40],["// actual (erased) type. We erase ProvidedTypes to their base type",38],["(fun _ -> None) // We do not respect this attribute for provided methods",36],["// We only count one argument block for these.",36],["(fun _ -> None) // We do not respect this attribute for IL methods",54],["// We expect accessing the value 'x' will _not_ trigger initialization of this module",57],["// This should be the only call to Thread.Start in this library. We must always install a trampoline.",34]],"useCount":4418},{"word":"WebSharper","context":[["// This file is part of WebSharper",76],["open WebSharper.UI.Next.Html",68],["// This file is part of WebSharper",342],["open WebSharper.UI.Next",95],["open WebSharper.JavaScript",289],["open WebSharper.Sitelets",63],["open WebSharper",404],["open WebSharper.InterfaceGenerator",62],["open WebSharper.UI.Next.Client",63],["open IntelliFactory.WebSharper",63]],"useCount":2334},{"word":"When","context":[["<When Condition=\"$(TargetFrameworkIdentifier) == '.NETFramework' And ($(TargetFrameworkVersion) == 'v4.0')\">",45],["// When we cannot resolve NullableOps, recommend the relevant namespace to be added",36],["|> When testMessageMD5",34],["// When",100],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>",28],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["</When>",459],["/// and you can also specify the separator (use `\\t` for writing TSV files). When specifying",30],["createNode \"When\" project",30]],"useCount":2449},{"word":"Windows","context":[["match System.Windows.Application.GetResourceStream(System.Uri(\"FSharp.Core.dll\",System.UriKind.Relative)) with",58],["open System.Windows.Media",143],["open System.Windows.Input",148],["open System.Windows.Controls",227],["open System.Windows.Forms",292],["open System.Windows.Data",104],["open System.Windows",422],["<Reference Include=\"System.Reactive.Windows.Threading\">",84],["open System.Windows.Threading",76],["open FSharp.Windows",62]],"useCount":3514},{"word":"Write","context":[["target.Write(ptr)",31],["stderr.Write\" NO: \"",33],["writer.Write(v)",36],["// Write a special value in that we check later when applying the fixup",45],["target.Write(op1)",47],["target.Write(op2)",47],["env.Write s1",50],["target.Write(v)",50],["target.Write(result)",242],["target.Write(resultType)",218]],"useCount":2644},{"word":"WriteLine","context":[["writer.WriteLine ()",82],["log'.WriteLine(LogLevel.Verbose, @\"Organization: \" + org.ToString())",35],["log'.WriteLine(LogLevel.Verbose, @\"Domain: \" + domain)",35],["with ex -> log'.WriteLine(LogLevel.Error, getFullException ex)",37],["log'.WriteLine(LogLevel.Info, daxifVersion)",40],["stdout.WriteLine \"Test Failed\"",41],["stdout.WriteLine \"Test Passed\"",42],["log'.WriteLine",54],["Console.WriteLine()",83],["log'.WriteLine(LogLevel.Verbose, @\"User: \" + usr)",35]],"useCount":1936},{"word":"X","context":[["\"...X....\";",48],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753],["member this.X = \"F#\"",121],["\"X.......\";",56],["\".......X\";",54],["\"X......X\";",53],["\"X......X\";",53],["ta.Name ta.VersionString ta.SignatureName (ta.SignatureVersion.ToString(\"X\")) ))",35],["module X",33],["| ('d' | 'i' | 'o' | 'u' | 'x' | 'X') ->",28]],"useCount":2492},{"word":"Xml","context":[["\"System.Runtime.Serialization.Xml.dll\"; \"System.Runtime.Serialization.dll\";",33],["open System.Xml.Serialization",28],["open Yaaf.Xml",35],["open System.Xml.XPath",38],["let ``should generate Xml for System.Net.Http 2.2.8``() =",43],["yield \"System.Xml\"",48],["open Paket.Xml",104],["open System.Xml",519],["open System.Xml.Linq",581],["AssemblyReferences = [ AssemblyId.from \"System\" ; AssemblyId.from \"System.Xml\"; AssemblyId.from \"System.Data\" ] |> set",26]],"useCount":2206},{"word":"XmlDoc","context":[["let xml = GetXmlComment (XmlDoc [||]) infoReader m d",30],["member x.XmlDoc =",72],["member __.XmlDoc =",59],["member XmlDoc: IList<string>",54],["if isUnresolved() then XmlDoc.Empty  |> makeXmlDoc else",48],["if lines.Length = 0 then XmlDoc.Empty",42],["XmlDoc *",40],["| XmlDoc [| |] -> \"\"",34],["let xml = GetXmlComment (if minfo.HasDirectXmlComment then minfo.XmlDoc else XmlDoc [||]) infoReader m d",30],["let xml = GetXmlComment (if minfo.HasDirectXmlComment then minfo.XmlDoc else XmlDoc [||]) infoReader m d",30]],"useCount":2100},{"word":"Zset","context":[["if not tycon.IsTypeAbbrev && Zset.contains tycon freeInEnv then",20],["Zset.isEmpty (List.fold (fun acc v -> Zset.remove v acc)",20],["{ mhi with mhiTyconReprs = Zset.add tycon mhi.mhiTyconReprs }",21],["let free = Zset.diff freeInDeclaringType.FreeTypars  freeInArgsAndRetType.FreeTypars",30],["let forwardReferenceSet = Zset.remove bind.Var forwardReferenceSet",32],["if Zset.contains typar env.singletons then",33],["let mhi = { mhi with mhiTycons = Zset.add entity mhi.mhiTycons }",34],["if Zset.contains qualNameOfFile rootImpls then",40],["else Zset.union s1 s2",95],["Zset.union freeInBinding freeInEnv)",20]],"useCount":3062},{"word":"_","context":[["| _ -> true",594],["| _ -> None",9290],["| _ -> false",6597],["| _ -> ()",5489],["with _ ->",1085],["| _ -> []",948],["| _ -> None)",916],["| _ -> false)",909],["| Some _ ->",599],["| _ ->",19227]],"useCount":306187},{"word":"__","context":[["member __.AddXmlDocComputed xmlDocFunction            = customAttributesImpl.AddXmlDocComputed xmlDocFunction",126],["member __.GetCustomAttributesDataImpl() = customAttributesImpl.GetCustomAttributesData()",476],["member __.Dispose() =",332],["member __.NamedArguments = upcast [| |] }",272],["member __.ConstructorArguments = upcast [| |]",190],["member __.Handle = x",143],["override __.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",129],["member __.AddXmlDocDelayed xmlDocFunction             = customAttributesImpl.AddXmlDocDelayed xmlDocFunction",126],["member __.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",126],["override __.GetHashCode() = assert false; x.GetHashCode()",104]],"useCount":24772},{"word":"a","context":[["let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"",343],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"",343],["// to COM components.  If you need to access a type in this assembly from",997],["match a with",529]],"useCount":109455},{"word":"a1","context":[["emit ExpectedStackState.Value a1",92],["\"a1\",",20],["let a1 = head r1",128],["vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;",22],["| Quotations.DerivedPatterns.SpecificCall <@ (/) @> (None, [t1; t2; _], [a1; a2]) ->",24],["| Quotations.DerivedPatterns.SpecificCall <@ (-) @>(None, [t1; t2; _], [a1; a2]) ->",24],["vec3 p2 = vec3(a1.xy, h.z);",26],["vec3 p3 = vec3(a1.zw, h.w);",26],["| (a1,k1)::rest1, (a2,k2)::rest2 -> (a1=a2) && (k1=k2) && loop rest1 rest2",31],["| (a1,k1)::rest1, (a2,k2)::rest2 -> (a1=a2) && (k1=k2) && loop rest1 rest2",31]],"useCount":2127},{"word":"a2","context":[["let a2 = head r2",112],["let combineAccess (TAccess a1) (TAccess a2) = TAccess(a1@a2)",19],["let combineAccess (TAccess a1) (TAccess a2) = TAccess(a1@a2)",19],["let c = compare a2 b2",19],["let compareILVersions (a1,a2,a3,a4) ((b1,b2,b3,b4) : ILVersionInfo) =",19],["| Quotations.DerivedPatterns.SpecificCall <@ (/) @> (None, [t1; t2; _], [a1; a2]) ->",24],["| Quotations.DerivedPatterns.SpecificCall <@ (-) @>(None, [t1; t2; _], [a1; a2]) ->",24],["| (a1,k1)::rest1, (a2,k2)::rest2 -> (a1=a2) && (k1=k2) && loop rest1 rest2",31],["| (a1,k1)::rest1, (a2,k2)::rest2 -> (a1=a2) && (k1=k2) && loop rest1 rest2",31],["emit ExpectedStackState.Value a2",92]],"useCount":1979},{"word":"about","context":[["\\ See the file \"COPYING\" for further information about",89],["﻿// Learn more about F# at http://fsharp.org",78],["// Report information about the whole expression including type arguments to VS",38],["// 'delayed' is about to be dropped on the floor, first do rudimentary checking to get name resolutions in its body",36],["/// Is this a member, if so some more data about the member.",35],["/// The information about the r.h.s. of an F# exception definition, if any.",34],["/// The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.",34],["// General Information about an assembly is controlled through the following",1065],["﻿// Learn more about F# at http://fsharp.net",172],["///    information about the schema format.",30]],"useCount":3854},{"word":"abstract","context":[["abstract member ResolveAssembly : args : System.ResolveEventArgs -> Assembly",59],["abstract name: string with get, set",76],["abstract x: float with get, set",62],["abstract y: float with get, set",62],["abstract toString: unit -> string",62],["abstract addEventListener: ``type``: string * listener: EventListenerOrEventListenerObject * ?useCapture: bool -> unit",208],["abstract length: float with get, set",111],["abstract Name : string",93],["abstract Id : string",79],["abstract ``type``: string with get, set",78]],"useCount":8513},{"word":"acc","context":[["acc",843],["acc <- curr",108],["| SetEmpty -> acc",109],["let mutable res = acc",114],["match acc with",124],["| None -> acc",156],["| [] -> acc",247],["let acc =",256],["| _ -> acc",277],["else acc",297]],"useCount":17921},{"word":"access","context":[["match access with",61],["System.AppDomain.CurrentDomain.DefineDynamicAssembly(name=assemblyName,access=AssemblyBuilderAccess.Run)",58],["Access=access;",76],["// This is a value we can access from the outside to definitely force initialziation of the module",85],["entity_accessiblity=access",59],["// This is a value we will access from the outside.",85],["Access = access;",51],["let access =",99],["access",37],["// to COM components.  If you need to access a type in this assembly from",997]],"useCount":4355},{"word":"action","context":[["let action =",58],["let action = FSharpFunc<_,_,_,_>.Adapt action",56],["/// <param name=\"name\"> Name of the action to be exported </param>",54],["let nextState = actionValue action",48],["// Local action is not identified with a guid in execution",44],["let action = FSharpFunc<_,_,_,_>.Adapt action",56],["/// <param name=\"domainID\"> ID of the particular function/action </param>",70],["let action = FSharpFunc<_,_,_>.Adapt action",120],["let action = FSharpFunc<_,_,_>.Adapt action",120],["match action with",191]],"useCount":3255},{"word":"actor","context":[["/// <param name=\"actorFactory\">Either actor system or parent actor</param>",71],["/// The actor can only be used locally.",59],["/// Returns a supervisor strategy appliable only to child actor which faulted during execution.",41],["/// <param name=\"options\">List of options used to configure actor creation</param>",41],["actor {",286],["| Hidden -> Do.Unhide(actor conn)",195],["match Visibilities.For (actor conn).Id with",195],["/// <param name=\"actorFactory\">Either actor system or parent actor</param>",71],["/// <param name=\"name\">Name of spawned child actor</param>",71],["/// <param name=\"decider\">Used to determine a actor behavior response depending on exception occurred.</param>",82]],"useCount":2315},{"word":"actual","context":[["do! assertEquals expected actual",41],["test <@ expected = actual @>",56],["actual |> should equal expected",387],["actual",407],["Assert.True(EQ expected actual)",66],["actual.[\"data\"] |> equals (upcast expected)",72],["noErrors actual",72],["Assert.AreEqual(expected, actual)",129],["actual |> shouldEqual expected",283],["let actual =",387]],"useCount":3927},{"word":"ad","context":[["let ad = AccessRightsOfEnv env",64],["ad",93],["match ad with",105],["|> List.filter (IsTyconUnseen ad g ncenv.amap m >> not)",120],["|> List.filter (EntityRefContainsSomethingAccessible ncenv m ad)",64],["| Some(AccessibleEntityRef ncenv.amap m ad modref submodref) ->",60],["let ad = envinner.eAccessRights",54],["let tyconSearch ad =",51],["|> CollectResults (fun (resInfo,typ) -> ResolveObjectConstructorPrim ncenv nenv.eDisplayEnv resInfo id.idRange ad typ)",47],["let ad = env.eAccessRights",590]],"useCount":8427},{"word":"add","context":[["// add let bindings for arguments to ensure that arguments will be evaluated",53],["let mhi = { mhi with mhiTycons = Zset.add entity mhi.mhiTycons }",34],["List.foldBack (Map.add id) matches results",34],["add pinfo",36],["#if EXTENDED_EXTENSION_MEMBERS // indicates if extension members can add additional constraints to type parameters",36],["// TODO: add raiser",52],["member x.AddTypes (providedTypeDefinitions) = add (providedTypeDefinitions, None)",58],["let add (providedTypeDefinitions:ProvidedTypeDefinition list, enclosingTypeNames: string list option) =",58],["#1 , add ,",72],["add \".\";",72]],"useCount":6048},{"word":"addr","context":[["let chunk sz next = ({addr=next; size=sz},next + sz)",37],["seek ctxt.is addr;",238],["let nameIdx = seekReadStringIdx ctxt &addr",187],["let flags = seekReadUInt16AsInt32Adv ctxt &addr",77],["let flags = seekReadInt32Adv ctxt &addr",66],["let nameIdx = seekReadStringIdx &addr",64],["let tidx = seekReadUntaggedIdx TableNames.TypeDef ctxt &addr",55],["let typeIdx = seekReadBlobIdx ctxt &addr",55],["let nochunk next = ({addr= 0x0;size= 0x0; } ,next)",37],["r> encode-64+                   \\ | Encode assigned addr              ( paddr plen R: size )",48]],"useCount":5181},{"word":"aenv","context":[["checkTypars m aenv implTypars sigTypars &&",28],["(if List.forall2 (checkField aenv)  implFields sigFields",28],["| TType_var tp1, _ when aenv.EquivTypars.ContainsKey tp1 ->",33],["tcrefAEquiv g aenv tc1 tc2 &&",38],["typesAEquivAux erasureFlag g aenv b1 b2",38],["let aenv = mrpi.ImplToSigMapping",38],["typeAEquivAux erasureFlag g aenv acty fcty",38],["let aenv = aenv.BindEquivTypars implTypars sigTypars",42],["let aenv = csenv.EquivEnv",70],["let aenv = aenv.BindEquivTypars implTypars sigTypars",42]],"useCount":2638},{"word":"after","context":[["// and the modifiations hang around even after the process has exited.",42],["ilg.Emit(OpCodes.Brfalse, after)",61],["let cfg = DependenciesFile.FromCode(after)",100],["let after = ilg.DefineLabel()",122],["//ONLY after a 401",54],["let after = \"\"\"source https://www.nuget.org/api/v2",40],["// polymorphic code, after inlining etc.",40],["ilg.MarkLabel(after)",61],["ilg.Emit(OpCodes.Bgt, after)",61],["ilg.MarkLabel after",61]],"useCount":3594},{"word":"all","context":[["/// Installs all dependencies.",89],["// You can specify all the values or you can default the Build and Revision Numbers",1037],["| Force -> \"Forces the download and reinstallation of all packages.\"",92],["// Find all the items with a non-empty key list. Bucket them together by",79],["// Find all the items with an empty key list and call 'tipf'",79],["/// Updates all dependencies.",72],["let all =",71],["//could theoretically go wrong, if all the values do happen to be zero.",57],["// of which there can be many. Simply turn them all into one big AND expression as that is the",46],["// Share intern'd strings across all lexing/parsing",57]],"useCount":11611},{"word":"also","context":[["/// The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts",34],["//    then it also asserts.  But these are edge cases that can be fixed later, e.g. in bug 4651.",40],["/// This also checks that there are some remaining results",44],["// case of generics all the generic type arguments are also recursively",38],["/// The current node is also considered in the comparison",36],["/// Like methodInfo.MakeGenericMethod, but will also work with unit-annotated types and provided types",33],["/// Like typ.MakeGenericType, but will also work with unit-annotated types",33],["// PassA: also processes their arg patterns - collecting type assertions",30],["// also want it for e.g. [|arr|].(0)",30],["/// and you can also specify the separator (use `\\t` for writing TSV files). When specifying",30]],"useCount":2401},{"word":"always","context":[["/// State variables always get zero-initialized",32],["// - targettype is not obj (assume this is always possible for ref types)",51],["// \"type x = | A\" can always be used instead.",40],["// There should be no bindings that have not been generalized since checking the vary last binding always",40],["// This ensures we always get the type instantiation right when doing this from",80],["/// generally always evolves towards being either rigid or solved.",34],["//   (its implementation of IsAssignableFrom raises NotSupportedException so it will be safer to always emit castclass)",51],["// This should be the only call to Thread.Start in this library. We must always install a trampoline.",34],["// argExprs should always include 'this'",35],["#nowarn \"67\" // this type test or downcast will always hold",59]],"useCount":2125},{"word":"amap","context":[["let amap = csenv.amap",116],["let amap = infoReader.amap",268],["|> List.filter (IsTyconUnseen ad g ncenv.amap m >> not)",120],["let amap = csenv.amap",116],["let amap = ncenv.amap",68],["let amap = tcImports.GetImportMap()",97],["ProvidedMeth(amap, meth, None, m)",68],["let amap = ncenv.amap",68],["| ProvidedMeth(amap,mi,_,m) ->",97],["let amap = infoReader.amap",268]],"useCount":16164},{"word":"an","context":[["// REVIEW: write into an accumuating buffer",78],["/// Represents an erased provided property.",75],["if prefixes.al <> Aligned then failwith \"an unaligned prefix is not allowed here\";",75],["// Find all the items with an empty key list and call 'tipf'",79],["/// <summary>Creates an instance of the attribute</summary>",427],["// associated with an assembly.",1072],["// General Information about an assembly is controlled through the following",1065],["// Version information for an assembly consists of the following four values:",1046],["0 // return an integer exit code",537],["/// with InvariantCulture settings. Otherwise the operation requires an appropriate",202]],"useCount":29109},{"word":"and","context":[["// You can specify all the values or you can default the Build and Revision Numbers",1037],["\\ * which accompanies this distribution, and is available at",436],["\\ * This program and the accompanying materials",436],["// This file is subject to the terms and conditions defined in",233],["and",1990],["(* Member of type 'CodeTypeConstructor' is not supported by the CodeDOM provider and was omitted *)",189],["/// [category:Grouping, windowing and chunking]",140],["and set v =",182],["and  set f =",132],["/// [category:Accessors and slicing]",130]],"useCount":71137},{"word":"any","context":[["// Emit the constructor (if any)",64],["/// <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>",44],["// Not, this does not have to be a SyncOp, it can be called from any thread",48],["req-any",59],["// XML doc text that we only compute once, if any. This must _not_ be forced until the ConstructorArguments",64],["/// Create a new provided field. It is not initially associated with any specific provided type definition.",66],["/// Create a new provided type. It is not initially associated with any specific provided type definition.",67],["/// semantics if any. It is not present if the type defines its own implementation",80],["// By using this source code in any fashion, you are agreeing to be bound",203],["// By using this source code in any fashion, you are agreeing to be bound",490]],"useCount":7653},{"word":"api","context":[["source \"http://www.nuget.org/api/v2\"",165],["remote: http://nuget.org/api/v2",132],["remote: https://www.nuget.org/api/v2",111],["source http://nuget.org/api/v2",107],["source http://www.nuget.org/api/v2",168],["source \"http://nuget.org/api/v2\"",134],["source https://www.nuget.org/api/v2",137],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://nuget.org/api/v2",139],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://www.nuget.org/api/v2",147],["remote: http://www.nuget.org/api/v2",152]],"useCount":2651},{"word":"are","context":[["// Allow 'fake' nested types that are actually real .NET types",67],["// These don't have to return fully accurate results - they are used",60],["| _ -> failwith (sprintf \"ApplyStaticArguments: static params for type %s are unexpected\" ty.FullName)",62],["// By using this source code in any fashion, you are agreeing to be bound",203],["// These are some constant expressions which can be accessed from context",85],["// Preconditions are checked by the member.",78],["/// <summary>Builds a new collection whose elements are the results of applying the given function",78],["// The contents of this file are made available under the terms of the",76],["/// are analyzed using reflection. The type is representationally equivalent to",76],["// By using this source code in any fashion, you are agreeing to be bound",490]],"useCount":17389},{"word":"arg","context":[["override this.MakeArrayType arg = ProvidedSymbolType(SymbolKind.Array arg, [this]) :> Type",73],["override this.MakeArrayType arg = ProvidedSymbolType(SymbolKind.Array arg, [this]) :> Type",73],["match arg with",313],["| SymbolKind.SDArray,[arg] -> arg.Name + \"[]\"",56],["let CustomAttributeNamedArgument(memb,arg:IProvidedCustomAttributeTypedArgument) =",60],["member x.TypedValue = arg }",61],["member x.ArgumentType = arg.ArgumentType",61],["match box arg with",69],["/// <param name=\"arg2\">The second arg.</param>",72],["/// <param name=\"arg1\">The first arg.</param>",72]],"useCount":8788},{"word":"arg1","context":[["| P.Lambda(arg, P.Application(P.Var f, P.Var arg1)) when v = f && arg = arg1 -> n",21],["let raiseExpr = mkCallRaise cenv.g m (tyOfExpr cenv.g expr) arg1",22],["/// <param name=\"arg1\">The first argument.</param>",36],["GenExpr cenv cgbuf eenv SPSuppress arg1 Continue;",65],["/// <param name=\"arg1\">The first arg.</param>",72],["| P.Lambda(arg, P.Application(P.Var f, P.Var arg1)) when v = f && arg = arg1 -> n",21],["let ty = tyOfExpr cenv.g arg1",22],["| TOp.ILAsm([ AI_ceq ],_),_,[arg1;arg2]  ->",22],["let eq = mkCallEqualsOperator cenv.g m ty arg1 arg2",22],["| TOp.ILAsm([ I_throw ],_),_,[arg1]  ->",22]],"useCount":2147},{"word":"args","context":[["let options =  checker.GetProjectOptionsFromCommandLineArgs (projFileName, args)",408],["match args with",970],["let main args =",352],["let args =",685],["let args = mkProjectCommandLineArgs (dllName, fileNames)",493],["args",324],["info.Arguments <- args) parameters.TimeOut",142],["match kind,args with",263],["for pe in args do",128],["\"args\", upcast []",99]],"useCount":26094},{"word":"argtys","context":[["(argtys |> IterateD (fun argty -> SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace argty g.int_ty)) ++ (fun () ->",28],["mkILMethSpecInTyRaw (enclTyp, cc, nm, argtys, retty, minst)",36],["let args',tpenv = TcExprs cenv env m tpenv flexes argtys args",62],["let argtys = NewInferenceTypes args",42],["let args',acc = TcPatterns warnOnUpper cenv env vFlags (tpenv,names,takenNames) argtys args",42],["let (MethodData(enclTyp, cc, nm, argtys, retty, minst)) = seekReadMethodDefAsMethodData ctxt idx",32],["argtys",33],["let flexes = argtys |> List.map (fun _ -> false)",42],["let flexes = argtys |> List.map (isTyparTy cenv.g >> not)",40],["argtysl |> List.mapi (fun i argtys ->",38]],"useCount":3289},{"word":"argument","context":[["///<param name=\"matrix\">Matrix argument</param>",56],["// Layout a named argument",60],["/// Sequence actions, discarding the value of the first argument.",51],["/// Sequence actions, discarding the value of the second argument.",51],["// static member and module value unit argument elimination",50],["/// Rescoping. The first argument tells the function how to reference the original scope from",85],["/// Represents an array or other symbolic type involving a provided type as the argument.",68],["#nowarn \"49\" // uppercase argument names",58],["// Layout an unnamed argument",60],["// Layout an optional argument",60]],"useCount":6713},{"word":"arguments","context":[["// add let bindings for arguments to ensure that arguments will be evaluated",53],["// being accessed we know the number of arguments the first class use of this",40],["/// types of optional arguments for function and member signatures.",40],["// Allow at most one constructor, and use its arguments as the fields of the type",64],["/// Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.",59],["// add let bindings for arguments to ensure that arguments will be evaluated",53],["// A single group of tupled arguments",51],["// no arguments are given or else based on the syntax of the arguments.",40],["// Handle optional arguments",40],["// no arguments are given or else based on the syntax of the arguments.",40]],"useCount":5269},{"word":"argv","context":[["let main argv =",1277],["argv i cells +  start  c cells  cmove",21],["argv i cells + @",21],["printfn \"%A\" argv",145],["let argv = System.Environment.GetCommandLineArgs()",54],["match argv with",27],["let parsedCommand = parse argv",26],[": eval-rest { env list -- argv argc }",25],["let cultureString = argv.[2] in",21],["| [] -> argv.[0]",21]],"useCount":2033},{"word":"arity","context":[["//     let f = (fun (x:int) (y:int) -> 1) // gets arity [1;1]",20],["/// The results of applying arity inference to PrelimValScheme2",20],["// Choose between the syntactic arity and the expression-inferred arity",20],["// fetch the arity",21],["// \"<type name>{`<arity>[<type>,+]}{<array rank>}{<scope>}\"  E.g.,",21],["// Check to see if there aren't enough arguments or if there is a tuple-arity mismatch",22],["// Index table by name and arity.",24],["// See what candidates we have based on name and arity",26],["let arity =",26],["| UnionCaseFullType (ty,arity) ->",40]],"useCount":2164},{"word":"arr","context":[["| arr ->",63],["let len = length arr",96],["emit ExpectedStackState.Value arr",112],["arr",255],["let arrn = length arr",48],["arr.Type.GetMethod(name)",61],["let arr =",50],["for i = 0 to arr.Length - 1 do",45],["let copyToArray s (arr: _[]) i =",37],["if arr.Length > 0 then",36]],"useCount":4644},{"word":"array","context":[["// integer array",514],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["let len = array.Length",372],["// empty array",496],["// null array",508],["// string array",549],["/// <param name=\"array\">The input array.</param>",657],["/// <param name=\"array\">The input array.</param>",657],["checkNonNull \"array\" array",1084],["checkNonNull \"array\" array",1084]],"useCount":14610},{"word":"as","context":[["let field = match field with :? ProvidedField as pf when fieldMap.ContainsKey pf -> fieldMap.[pf] :> FieldInfo | m -> m",80],["// Open up the compiler as an incremental service for parsing,",72],["| :? ProvidedTypeDefinition as t ->",80],["| :? AST as ast ->",72],["| :? PropertyInfo as p ->",96],["| :? System.Reflection.TargetInvocationException as e ->",99],["| :? System.Reflection.MethodInfo as minfo ->",69],["| :? MethodInfo as tagMeth ->",70],["| :? Type as ty ->",101],["// by using the '*' as shown below:",1021]],"useCount":27240},{"word":"assembly","context":[["// Version information for an assembly consists of the following four values:",1046],["[<assembly: AssemblyConfiguration(\"\")>]",1410],["[<assembly: AssemblyDescription(\"\")>]",1269],["[<assembly: ComVisible(false)>]",1179],["[<assembly: AssemblyCompany(\"\")>]",1152],["[<assembly: AssemblyCulture(\"\")>]",1149],["[<assembly: AssemblyVersion(\"1.0.0.0\")>]",1146],["// associated with an assembly.",1072],["// General Information about an assembly is controlled through the following",1065],["[<assembly: AssemblyTrademark(\"\")>]",1412]],"useCount":30419},{"word":"assert","context":[["assert(false)",54],["assert (gdtym <> null) // ?? will never happen - if method is not found - KeyNotFoundException will be raised",56],["(match xmlDocDelayed with None -> assert false; \"\" | Some f -> f())",63],["assert (t1 = t2)",52],["assert (dtym <> null)",59],["assert(t1 = t2)",50],["assert( depth 0 = )",46],["assert false",187],["override __.GetHashCode() = assert false; x.GetHashCode()",104],["assert ctorMap.ContainsKey pcinfo",64]],"useCount":3727},{"word":"associated","context":[["/// Create a new provided type. It is not initially associated with any specific provided type definition.",67],["// associated with an assembly.",1072],["/// Create a new provided field. It is not initially associated with any specific provided type definition.",66],["/// Create a new provided method. It is not initially associated with any specific provided type definition.",37],["/// Create a new provided constructor. It is not initially associated with any specific provided type definition.",37],["// this variable for the implicit class constructor. For static members, we assert the type variables associated",38],["/// and we have to check various conditions associated with that.",38],["/// or marked 'internal' or 'private' and we have to check various conditions associated with that.",38],["// baseValOpt is the 'base' variable associated with the inherited portion of a class",40],["/// Syntax trees and associated support functions.",54]],"useCount":3061},{"word":"async","context":[["|> async.Return",42],["/// <c>async { ... }</c> computation expression syntax.</remarks>",70],["let a = async {",67],["let rec loop() = async {",31],["| Some(r) -> async { return r }",26],["async { try",25],["let rec loop () = async {",82],["async{",83],["async {",5938],["async",24]],"useCount":7141},{"word":"at","context":[["﻿// Learn more about F# at http://fsharp.net",172],["// at the member signature. If so, we know the type of this member, and the full slotsig",40],["// Handle the case where this is a generic method instantiated at a type being compiled",51],["| _ -> failwith \"at most one implicit constructor allowed\"",59],["/// <param name=\"names\">The identifiers at the location where the information is being requested.</param>",59],["// Allow at most one constructor, and use its arguments as the fields of the type",64],["// distribution, and is available at the following URL:",76],["﻿// Learn more about F# at http://fsharp.org",78],["\\ * which accompanies this distribution, and is available at",436],["Email: jinl at microsoft dot com",273]],"useCount":7974},{"word":"attribs","context":[["entity_attribs=attribs",38],["let attribs =",74],["match TryFindFSharpAttribute tcGlobals (mkMscorlibAttrib tcGlobals attrib) attribs with",51],["SynSimplePat.Attrib(p2,attribs,m),",21],["nonNil attribs &&",28],["CustomAttrs= mkILCustomAttrs (GenAttrs cenv eenv attribs) }",32],["| SynPat.Attrib(p',attribs,m) ->",21],["let AttribsOfArgData (SynArgInfo(attribs,_,_)) = attribs",21],["None, attribs",32],["attribs",34]],"useCount":2669},{"word":"attribute","context":[["(fun _ -> None) // We do not respect this attribute for IL methods",54],["// COM, set the ComVisible attribute to true on that type.",997],["/// <summary>Creates an instance of the attribute</summary>",427],["// Run InferTyconKind to raise errors on inconsistent attribute sets",100],["// set of attributes. Change these attribute values to modify the information",1064],["// property of the custom attribute is foced.",64],["/// This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.",64],["// Check for the [<ProjectionParameter>] attribute on an argument position",36],["// Try to find an AssemblyVersion attribute",48],["/// Add a 'System.Obsolete' attribute to this provided field",56]],"useCount":5425},{"word":"attributes","context":[["attributes : int *",96],["// set of attributes. Change these attribute values to modify the information",1064],["attributes",111],["(attributes &&& ~~~TypeAttributes.VisibilityMask) ||| visibilityAttributes",68],["match attributes &&& TypeAttributes.VisibilityMask with",68],["// Adjust the attributes - we're codegen'ing this type as nested",64],["let attributes = adjustTypeAttributes ntd.Attributes true",64],["let adjustTypeAttributes attributes isNested =",64],["let attributes =",95],["// MUTABILITY: used when propagating signature attributes into the implementation.",93]],"useCount":6628},{"word":"attrs","context":[["let kind = InferTyconKind cenv.g (kind,attrs,slotsigs,fields,inSig,isConcrete,m)",72],["let attrs = GetCustomAttributesOfIlModule ilModule",40],["tycon.Data.entity_attribs <- attrs",36],["let attrs = checkedAttrs",42],["match attrs with",48],["attrs",50],["match TryFindFSharpAttribute g nm attrs with",51],["let attrs =",54],["let hasMeasureAttr = HasFSharpAttribute cenv.g cenv.g.attrib_MeasureAttribute attrs",72],["List.iter walkAttribute attrs",88]],"useCount":3996},{"word":"available","context":[["s\" No data available\"  exception constant exp-no-data            ( -- n = No data available exception number )",44],["\\ * which accompanies this distribution, and is available at",436],["// The contents of this file are made available under the terms of the",76],["// distribution, and is available at the following URL:",76],["s\" No data available\"  exception constant exp-no-data            ( -- n = No data available exception number )",44],["// Because there is only one accessible method info available based on the name of the item",40],["// Initially, assume the equality relation is available for all structural type definitions",40],["/// Tycons available by unqualified, demangled names (i.e. (List,1) --> TyconRef)",34],["// fold the available extension members into the overload resolution",32],["// 64 bit flag is not available <= Win2k",30]],"useCount":2488},{"word":"axis","context":[["/// <param name=\"TitleAlignment\">The alignment of the title for the axis</param>",56],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753],["/// <param name=\"ArrowStyle\">The arrow style for the axis</param>",56],["/// <param name=\"YTitle\">The title of the Y-axis.</param>",753],["/// <param name=\"TitleColor\">The color of the title of the axis</param>",56],["/// <param name=\"Title\">The title of the axis</param>",56],["/// <param name=\"Tooltip\">The tooltip to use for the axis</param>",56],["/// <param name=\"TitleFontSize\">The font size for the title of the axis</param>",56],["/// <param name=\"MajorTickMark\">The major tick marks to use for the axis</param>",56],["/// <param name=\"LabelStyle\">The label style for the axis</param>",56]],"useCount":2478},{"word":"b","context":[["let y = getMatrixFromMatlab(app, \"b\")",168],["b",151],["let valueKeyMap = Map.ofSeq [(2,\"b\"); (3,\"c\"); (4,\"d\"); (5,\"e\")]",133],["let a = p1 st in let b = p2 st in let c = p3 st in let d = p4 st in",104],["let b =",102],["match b with",565],["b = fract(b);",101],["b = fract(b);",101],["if (b > 1.0) {",101],["let b = mkFreeV bb in",100]],"useCount":24791},{"word":"b0","context":[["let b0 = b0 &&& 0x3Fuy",44],["let b0,sigptr = sigptr_get_byte bytes sigptr",138],["let b0 = b0 &&& 0x3Fuy",44],["elif b0 <= 0xBFuy then",44],["let b0 = b0 &&& 0x7Fuy",44],["int64 b0 ||| (int64 b1 <<< 8) ||| (int64 b2 <<< 16) ||| (int64 b3 <<< 24) |||",45],["let b0 = head t01",64],["let b0 = head r0",64],["let b0,sigptr = sigptrGetByte bytes sigptr",110],["let b0 = b0 &&& 0x7Fuy",44]],"useCount":2946},{"word":"b1","context":[["let b1 = head t11",64],["(* let v = if c then b1 else b2 in bexpr => if c then let v = b1 in bexpr else let v = b2 in bexpr *)",59],["(* let v = if c then b1 else b2 in bexpr => if c then let v = b1 in bexpr else let v = b2 in bexpr *)",59],["let b1,sigptr = sigptrGetByte bytes sigptr",66],["let b1,sigptr = sigptr_get_byte bytes sigptr",115],["Quotations.Expr.IfThenElse(c, inlineByref v b1 bexpr, inlineByref v b2 bexpr)",50],["| Quotations.Patterns.IfThenElse(c,b1,b2) ->",50],["int64 b0 ||| (int64 b1 <<< 8) ||| (int64 b2 <<< 16) ||| (int64 b3 <<< 24) |||",45],["///       let b1 = ILBasicBlock(\"B1\", [| I_ldarg(1); I_br(\"B2\") |])",42],["///    (fun b1 b2 -> E (b1 :> A) (b2 :> A))",38]],"useCount":2608},{"word":"b2","context":[["///    (fun b1 b2 -> E (b1 :> A) (b2 :> A))",38],["///    (fun b1 b2 -> E (b1 :> A) (b2 :> A))",38],["int64 b0 ||| (int64 b1 <<< 8) ||| (int64 b2 <<< 16) ||| (int64 b3 <<< 24) |||",45],["| Quotations.Patterns.IfThenElse(c,b1,b2) ->",50],["Quotations.Expr.IfThenElse(c, inlineByref v b1 bexpr, inlineByref v b2 bexpr)",50],["let b2 n =  ((n >>> 16) &&& 0xFF)",50],["(* let v = if c then b1 else b2 in bexpr => if c then let v = b1 in bexpr else let v = b2 in bexpr *)",59],["(* let v = if c then b1 else b2 in bexpr => if c then let v = b1 in bexpr else let v = b2 in bexpr *)",59],["let b2,sigptr = sigptr_get_byte bytes sigptr",69],["let b2 = head t21",96]],"useCount":1961},{"word":"base","context":[["fsharpVsLanguageService = base.VsLanguageService,",58],["// phase 1b - emit base types",59],["r> base !",82],["base !",77],["base.IsAssignableFrom(otherTy)",54],["| _ -> base.IsAssignableFrom(otherTy)",55],["projectFactory = base.ProjectFactory,",56],["BaseLight base;",57],["| Some _ -> failwith (sprintf \"ProvidedConstructor: base call already given for '%s'\" (nameText()))",58],["serviceProvider = base.ServiceProvider,",66]],"useCount":3116},{"word":"based","context":[["// no arguments are given or else based on the syntax of the arguments.",40],["// optimized mutation-based implementation. This code is only valid in fslib, where mutation of private",114],["/// Used to hide/filter members from super classes based on signature",72],["// Because there is only one accessible method info available based on the name of the item",40],["/// File system query based on TcConfig settings",38],["// use different sources based on Declared flag",32],["/// Returns a data frame whose rows are indexed based on the specified column of the original",32],["// often statically optimized or devirtualized based on the statically known type.",36],["// table indexes are 1-based, document array indexes are 0-based",30],["// The default location of FSharp.Core.dll and fsc.exe based on the version of fsc.exe that is running",31]],"useCount":2058},{"word":"bb","context":[["EmitType cenv env bb typ",30],["emitBytesViaBuffer (fun bb ->",45],["let b = mkFreeV bb in",100],["let bb = (\"b\", Type_sort) in",40],["| ILBasicBlock bb ->",33],["let bb = (\"b\", Term_sort) in",32],["bb.EmitZ32 i",30],["let instrs = bb.Instructions",25],["emitTypeInfoAsTypeDefOrRefEncoded cenv bb (tspec.Scope,tspec.Enclosing,tspec.Name)",23],["not (aa |> List.forall(fun a -> bb |> List.exists (fun b -> canAccessCompPathFrom a b)))",19]],"useCount":1925},{"word":"be","context":[["// These are some constant expressions which can be accessed from context",85],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["// By using this source code in any fashion, you are agreeing to be bound",490],["///  - `series` - The input series to be aggregated.",86],["/// Close All Active Connection, to be called when the program gets shutdown.",103],["|> should be True",133],["true |> should be False",136],["// By using this source code in any fashion, you are agreeing to be bound",203],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// Event handler defined on server-side, lambda must be a call to a static member.",278]],"useCount":22477},{"word":"because","context":[["// This breaks certain invariants that hold elsewhere, because they dereference to point to",38],["///     an approximate intellisense resolution is inaccurate because a range of text has changed. This",30],["// because it is the MethodBuilder and that does not support Invoke.",32],["// Doing both a store and load keeps FxCop happier because it thinks the field is useful",32],["// A full type signature is required on this method because it is used at more specific types within its own scope",32],["// Eliminate subsumption coercions for functions. This must be done post-typechecking because we need",34],["/// Note that because of signatures, there are situations where in a single compilation the \"same\"",34],["/// or comes from another F# assembly then it does not (because the documentation will get read from",34],["// because the base type is CsvRow<RowType>, so we have to erase recursively to CsvRow<TupleType>",38],["// This helps avoid issues with mutable state which arise because unit tests can run in any order.",40]],"useCount":2759},{"word":"been","context":[["// this is because non-identity columns will have been set",30],["/// - A private key blob which has been encrypted and contains information to initialize RSA",42],["#nowarn \"52\" // The value has been copied to ensure the original is not mutated by this operation",41],["// There should be no bindings that have not been generalized since checking the vary last binding always",40],["// to the NUnit console/log so we'll know this function has been executed.",40],["CommonTasks.``ensure columns have been loaded`` (this :> ISqlProvider) con entities",34],["/// from running the function. It is null if the thunk has been evaluated successfully.",27],["/// Evict object that hasn't been visited within the specified seconds",25],["[<System.Obsolete(\"This type has been renamed to 'FSharpDeclarationListInfo'\")>]",24],["// This code has been modified and is appropriate for use in conjunction with the F# 3.0, F# 3.1, and F# 3.1.1 releases",23]],"useCount":2479},{"word":"before","context":[["ilg.MarkLabel before",122],["testEvent tagger.TagsChanged \"Timed out before tags changed\" timeout",30],["testEvent classifier.ClassificationChanged \"Timed out before classification changed\" timeout <| fun _ ->",31],["// Reverse the list of mapped values before returning it.",34],["// Reset mutable state for this module and those proceeding it before running each unit test.",40],["let before = \"\"\"source https://www.nuget.org/api/v2",42],["let before = GC.GetTotalMemory true",48],["ilg.Emit(OpCodes.Br, before)",122],["let before = ilg.DefineLabel()",122],["testEventTrigger tagger.TagsChanged \"Timed out before tags changed\" timeout",183]],"useCount":2275},{"word":"begin","context":[["else begin",48],["then begin",44],["begin ?dup while",38],["begin match head.n with",35],["begin match m with",34],["begin match t.n with",31],["begin match Util.smap_try_find env.cache tkey.hash with",30],["((wordL \"module\" ^^ nmL ^^ wordL \"=\" ^^ wordL \"begin\") @@-- basic) @@ wordL \"end\"",28],["begin-dispatch",26],["begin",1713]],"useCount":3137},{"word":"being","context":[["/// <param name=\"lineText\">The text of the line where the information is being requested.</param>",59],["/// <param name=\"names\">The identifiers at the location where the information is being requested.</param>",59],["/// <param name=\"line\">The line number where the information is being requested.</param>",59],["/// It is not clear it is a primary logical classification that should be being used in the",51],["// Handle the case where this is a generic method instantiated at a type being compiled",51],["// being accessed we know the number of arguments the first class use of this",40],["// being used in a first-class way, i.e.",40],["// being used with",40],["/// Holds the data indicating how this assembly/module is referenced from the code being compiled.",39],["/// generally always evolves towards being either rigid or solved.",34]],"useCount":2369},{"word":"below","context":[["// by using the '*' as shown below:",1021],["// Call the helper below to do the real checking",20],["// Ignore these and rely on the logic below to emit an error for each unresolved reference.",20],["// Additional fsi options are list below.",21],["// overall range. If the let binding is given the flag below then it is asserting that",21],["// keys can be compared using the functions below depending on the",22],["// to \"Use an environment lookup as the last resort\" below",24],["by using the '*' as shown below:",25],["// The assert below is almost ok, but it fires in two cases:",40],["// below is of the second form. However, to extract relevant information",20]],"useCount":1983},{"word":"bind","context":[["match ConvLetBind cenv env bind with",44],["let bind',tmenvinner = copyAndRemapAndBindBinding g compgen tmenv bind",38],["| Expr.Let (bind,body,m,_) ->",39],["let nm = bind.Var.DisplayName",40],["| TMDefLet(bind,m)  ->",40],["| TDBind (bind,rest) ->",48],["bind",48],["| TDBind(bind,rest) ->",50],["match bind with",56],["let v = bind.Var",137]],"useCount":6070},{"word":"binding","context":[["binding = None",169],["/// <param name=\"bindingFlags\">Optional binding flags.</param>",102],["match box tcr.binding with",80],["| Redirects -> \"Creates binding redirects for the NuGet packages.\"",69],["binding = None;",63],["// nice: don't introduce awful temporary for r.h.s. in the 99% case where we know what we're binding it to",60],["failwith (sprintf \"Unexpected byref binding: %A = %A\" v vexpr)",58],["// the binding must have leaves that are themselves variables (due to the limited support for byrefs in expressions)",54],["/// Applies the given function to each binding in the map.",52],["| CreateNewBindingFiles -> \"Creates binding redirect files if needed.\"",48]],"useCount":4789},{"word":"bindings","context":[["// The state of the left-to-right iteration through the bindings",38],["// --- Extract bindings for implicit constructors",36],["// --- Extract method bindings from let-bindings",36],["/// Folds over the bindings in the map.",40],["// There should be no bindings that have not been generalized since checking the vary last binding always",40],["List.tryPick walkBinding bindings",44],["// add let bindings for arguments to ensure that arguments will be evaluated",53],["/// Returns a new map made from the given bindings.",72],["// --- Extract field bindings from let-bindings",36],["// Skip over 'let' and 'do' bindings",36]],"useCount":4291},{"word":"binds","context":[["let z = valBindsF false z binds",34],["let vs = valsOfBinds binds",31],["| Expr.LetRec (binds,e,m,_) ->",66],["| TMDefRec(tycons,binds,mbinds,_) ->",54],["let binds =",50],["| TMDefRec(tycons,binds,mbinds,m) ->",44],["binds",41],["| IncrClassBindingGroup(binds,isStatic,_) ->",40],["| Expr.LetRec (binds,body,_,_) ->",38],["match (List.map (BindingNormalization.NormalizeBinding ValOrMemberBinding cenv env) binds) with",36]],"useCount":4335},{"word":"blob","context":[["if Utils.IsNull blob.Object then",32],["/// Get a blob of data indicating how this type is nested in other namespaces, modules or types.",34],["/// Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.",34],["blob.Stream.Seek( int64 pos, SeekOrigin.Begin ) |> ignore",28],["/// Indicates the \"tycon blob\" is actually a module",37],["/// - A private key blob which has been encrypted and contains information to initialize RSA",42],["/// Get a blob of data indicating how this type is nested inside other namespaces, modules and types.",63],["blobList.Add( blob )",68],["match blob.TypeOf with",132],["let blob = x.Blobs.[blobi]",149]],"useCount":1859},{"word":"block","context":[["/// A target of a decision tree. Can be thought of as a little function, though is compiled as a local block.",20],["// pos    - current pos in line = rightmost position of last line of block.",23],["// offset - width of last line of block",23],["// NOTE: offset <= pos -- depending on tabbing of last block",23],["// Now return the new block, the remaining blocks and the new set",30],["// We only count one argument block for these.",36],["match block with",63],["// In Visual Studio, when sending a block of text, it  prefixes  with '# <line> \"filename\"\\n'",21],["/// If the action is to block, it will return handle, false, so that the thread will wait on the handles.",21],["block-size * to part-offset",20]],"useCount":1832},{"word":"body","context":[["body",71],["emit ExpectedStackState.Empty body",112],["body enum.Current)))",63],["let body =",197],["</body>",192],["<body>",185],["match body with",178],["// for(loopVar = first..last) body",61],["let tps,vsl,body,returnTy = stripTopLambda (expr,vspec.Type)",60],["let fixedBody = f fallback body",60]],"useCount":10411},{"word":"bool","context":[["assert_equal typeof<bool> (snd result)",220],["Unlisted : bool",67],["bool *",79],["// (unit -> bool) * M<'T> -> M<'T>",80],["IsSpecialName: bool;",85],["IsSpecialName: bool;",95],["member IsUnresolved : bool",66],["| Bool of bool",114],["member AddObsoleteAttribute : message: string * ?isError: bool -> unit",190],["abstract addEventListener: ``type``: string * listener: EventListenerOrEventListenerObject * ?useCapture: bool -> unit",208]],"useCount":22919},{"word":"box","context":[["match box item with",104],["match box tcr.binding with",80],["box",104],["box <| NameValueLookup.ofList [",78],["match box arg with",69],["XDocument(declaration, box root)",64],["sb.Append(\"(\").Append(box(x.Item1).ToString()).Append(\",\")",63],["member x.IsLinked = match box x.Data with null -> false | _ -> true",60],["Microsoft.FSharp.Core.Operators.box",3597],["box x === other ||",108]],"useCount":9361},{"word":"buf","context":[["let buf = System.Text.StringBuilder 100",45],["buf.Build()",44],["buf.ToString()",47],["<@ fun (range:_1D) (buf:array<int>) ->",51],["let n = stream.Read(buf, 0, int rem)",59],["fun (range:_1D) (buf:array<int>) ->",216],["buf",154],["buf.Close()",112],["List.fold visitNode buf nodeList",73],["let buf = Array.zeroCreate<byte> (int len)",70]],"useCount":4550},{"word":"buffer","context":[["let tagger = helper.GetTagger(buffer, view)",194],["let! bytes = httpResponseStream.AsyncRead(buffer, 0, bufferSize)",57],["do! fileStream.AsyncWrite(buffer, 0, !bytesRead)",57],["helper.SetUpProjectAndCurrentDocument(createVirtualProject(buffer, fileName), fileName, content)",59],["buffer",65],["let! point = buffer.GetSnapshotPoint view.Caret.Position",71],["// REVIEW: write into an accumuating buffer",78],["helper.TagsOf(buffer, tagger)",159],["let view = helper.GetView(buffer)",194],["let buffer = createMockTextBuffer content fileName",265]],"useCount":5636},{"word":"build","context":[["gitSource.Command |> shouldEqual (Some \"build.cmd NuGet\")",36],["///  - `setParams` - Function used to override the default build parameters",35],["[<assembly: AssemblyDescriptionAttribute(\"Project has no summmary; update build.fsx\")>]",31],["// SEQUENCE POINTS: need to build a let here consuming spBind",40],["{ build = fun s ->",56],["let build cfg dir = attempt {",58],["do! build cfg dir",58],["| Or(preds,rest) -> build \"OR\" preds rest",46],["let build op preds (rest:Condition list option) =",46],["| And(preds,rest) ->  build \"AND\" preds rest",46]],"useCount":3114},{"word":"but","context":[["// The assert below is almost ok, but it fires in two cases:",40],["// method produced something, but we don't need it",64],["failwith (sprintf \"ProvidedTypeDefinition: static parameters supplied but not expected for %s\" (fullName.Force()))",60],["obox0  Same but indent continuation lines to the same column as the",54],["| _ -> Assert.Fail(\"Expectt overflow exception but not.\")",52],["Assert.Fail(\"Expectt overflow exception but not.\")",52],["// In principle the JIT should be able to do good liveness analysis to clean things up, but the",48],["// It is declared once on the 'inheritedTys clause, but a fresh binding is made for",40],["// Error recovery - return some rubbish expression, but replace/annotate",38],["// this is not correct JoinRelation but it is still binary operation",36]],"useCount":3867},{"word":"by","context":[["// by using the '*' as shown below:",1021],["// Find all the items with a non-empty key list. Bucket them together by",79],["///  - `targets` - A string with the target names which should be run by MSBuild.",78],["// Preconditions are checked by the member.",78],["/// FSharp.Data addition: this method is used by Debug.fs",73],["select * from Employee order by EmployeeId",120],["// This file was autogenerated by running the script in this directory",170],["(* Member of type 'CodeTypeConstructor' is not supported by the CodeDOM provider and was omitted *)",189],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234],["/// Called by the evaluation session to ask the host for parameters to format text for output",110]],"useCount":16536},{"word":"byte","context":[["let buf = Array.zeroCreate<byte> (int len)",70],["x.AvailThis.AvailVector.[blobi] <- byte BlobStatus.AllAvailable",141],["if subL <= dif && (((%% genComparator pat):array<byte> -> int -> bool) s i)",60],["let theTable = Dictionary<Assembly, Lazy<byte[]>>()",58],["let buffer : byte [] = Array.zeroCreate bufferSize",57],["/// - 16 byte GUID",42],["x.AvailThis.AvailVector.[blobi] <- byte BlobStatus.NotAvailable",49],["#bits/byte cell *",50],["elif t1 = typeof<byte> then",50],["#bits/byte 1 chars *",54]],"useCount":5586},{"word":"bytes","context":[["let b0,sigptr = sigptr_get_byte bytes sigptr",138],["bytes",121],["let bytes = readBlobHeap ctxt blobIdx",108],["let ccByte,sigptr = sigptrGetByte bytes sigptr",120],["let n, sigptr = sigptrGetZInt32 bytes sigptr",88],["let tdorIdx, sigptr = sigptrGetTypeDefOrRefOrSpecIdx bytes sigptr",88],["let typ, sigptr = sigptrGetTy ctxt numtypars bytes sigptr",108],["let b0,sigptr = sigptrGetByte bytes sigptr",110],["let bytes =",112],["let b1,sigptr = sigptr_get_byte bytes sigptr",115]],"useCount":7665},{"word":"c","context":[["if c <> 0 then c else",662],["if c <> 0 then c else",662],["c",299],["let c = comparer.Compare(k,k2)",295],["let c =",190],["match c with",1044],["// (c) Microsoft Corporation 2005-2009.",167],["let valueKeyMap = Map.ofSeq [(2,\"b\"); (3,\"c\"); (4,\"d\"); (5,\"e\")]",133],["let refMap = Map.ofSeq [for c in [\".\"; \"..\"; \"...\"; \"....\"] do yield (c, c.Length) ]",126],["| Some c ->",129]],"useCount":32829},{"word":"cache","context":[["match !cache with",76],["let cache =",56],["|> Seq.cache",118],["/// Get the cache of the compiled ILTypeRef representation of this module or type.",34],["/// as a cache for this sig-string computation.",34],["cache.Clear()",41],["let cache = ref null",45],["!cache",46],["checkNonNull \"cache\" cache",54],["checkNonNull \"cache\" cache",54]],"useCount":2060},{"word":"call","context":[["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["// Ensure the deref_nlpath call in UpdateAccModuleOrNamespaceType succeeds",36],["// The entire data segment is filtered out, don't generate a call in this case.",39],["(* The printing functions call these utility functions to insert grouping",54],["| Some _ -> failwith (sprintf \"ProvidedConstructor: base call already given for '%s'\" (nameText()))",58],["// convert NewTuple to the call to the constructor of the Tuple type (only for generated types)",60],["// call function",84],["// Find all the items with an empty key list and call 'tipf'",79],["// the first key. For each bucket, call 'nodef' on that head key and the bucket.",79],["// Otherwise, assume this is a generative assembly and just emit a call to the constructor or method",63]],"useCount":3939},{"word":"called","context":[["/// Close All Active Connection, to be called when the program gets shutdown.",103],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// which in F# is called a 'unknown representation' type).",34],["let called = ref false",35],["// Emit a message to the NUnit console/log to record when this function is called.",40],["// Not, this does not have to be a SyncOp, it can be called from any thread",48],["| _ -> failwith (sprintf \"There is more than one nested type called '%s' in type '%s'\" name this.FullName)",60],["| None -> failwith \"ProvidedTypeDefinition: DefineStaticParameters was not called\"",79],["/// Lazy logging adapter. It won't be initialized until logging function will be called.",30]],"useCount":2512},{"word":"calls","context":[["// Eliminate F# property gets to method calls",64],["// Eliminate F# function applications to FSharpFunc<_,_>.Invoke calls",64],["// Eliminate F# property sets to method calls",64],["// convert TupleGet to the chain of PropertyGet calls (only for generated types)",61],["// Note: static calls never mutate a struct object argument",40],["// See bug 6254: Mono has a bug in reflection-emit dynamic calls to the \"Get\", \"Address\" or \"Set\" methods on arrays",32],["// Detect 'typedefof<ty>' calls",30],["// Detect 'typeof<ty>' calls",30],["// Optimize/analyze calls to LanguagePrimitives.HashCompare.GenericComparisonWithComparerIntrinsic for tuple types",24],["// Optimize/analyze calls to LanguagePrimitives.HashCompare.GenericHashWithComparerIntrinsic for tuple types",24]],"useCount":2386},{"word":"can","context":[["#nowarn \"51\" // address-of operator can occur in the code",58],["// therefore, we can perform inlining to translate this to a form that can be compiled",59],["/// The actor can only be used locally.",59],["// therefore, we can perform inlining to translate this to a form that can be compiled",59],["/// can be created using methods on the System.Array type.</summary>",64],["/// not in the subset that can be converted to a LINQ expression tree",71],["// This is a value we can access from the outside to definitely force initialziation of the module",85],["// These are some constant expressions which can be accessed from context",85],["// You can specify all the values or you can default the Build and Revision Numbers",1037],["// You can specify all the values or you can default the Build and Revision Numbers",1037]],"useCount":11197},{"word":"case","context":[["/// optimized case: Core implementation of structural equality on arrays.",45],["// Try again, just case we can restart",42],["| None -> typ  // avoid reallocation in the common case",44],["case",173],["// Test case for an empty array.",47],["// Handle the case where this is a generic method instantiated at a type being compiled",51],["// single case",51],["// nice: don't introduce awful temporary for r.h.s. in the 99% case where we know what we're binding it to",60],["let elems = interfaceImplsDelayed |> Seq.toArray // take a copy in case more elements get added",60],["let elems = membersQueue |> Seq.toArray // take a copy in case more elements get added",63]],"useCount":5985},{"word":"cases","context":[["/// a true body. These cases are often causes of bugs in the compiler.",60],["cases",41],["| TDSwitch (e,cases,dflt,m) ->",41],["match cases with",45],["let cases = Reflection.FSharpType.GetUnionCases(ty)",59],["let a = cases.[0]",59],["// Sample usage test cases.",170],["// Handle the generic cases",64],["let cases =",63],["let b = cases.[1]",59]],"useCount":2862},{"word":"category","context":[["/// [category:Accessing series data and lookup]",112],["/// [category:Accessing frame data and lookup]",88],["/// [category:Operators]",379],["//[category: Creating generators from generators]",279],["/// [category:Grouping, windowing and chunking]",140],["/// [category:Accessors and slicing]",130],["/// [category:Sorting and index manipulation]",108],["/// [category:Missing values]",93],["/// [category:Series operations]",92],["/// [category:Frame transformations]",88]],"useCount":2835},{"word":"ccu","context":[["| ResolvedCcu ccu -> Some ccu",38],["let (NonLocalEntityRef(ccu,_)) = nleref",20],["let ccu =",96],["{ FSharpViewOfMetadata=ccu",42],["/// A handle to the full specification of the contents of the module contained in this ccu",39],["| _ -> errorR(Failure(\"internal error: the ccu thunk for assembly \"+x.AssemblyName+\" not delayed!\"))",38],["match ccu with",28],["let newEntity = Construct.NewProvidedTycon(resolutionEnvironment, st, ccu.ImportProvidedType, false, m)",34],["| Some ccu ->",34],["| ResolvedCcu ccu -> Some ccu",38]],"useCount":3863},{"word":"cell","context":[["cell+ ;",50],["list MalList/start @ cell+ { arg0 }",80],[": r'@              ( R: x1 x2 -- x1 x2; -- x1 = Fetch the second cell on the return stack )",34],["env arg0 cell+ @ TCO-eval",36],["cell 4 = [IF]",37],["#bits/byte cell *",50],["cell +loop",50],["let cell = ref 0",72],["cell+",57],["cell",52]],"useCount":2049},{"word":"cenv","context":[["let tyargsR = ConvTypes cenv env m tyargs",112],["UnifyTypes cenv env m genTy (mkSeqTy cenv.g genResultTy)",108],["type cenv =",119],["UnifyTypes cenv env mStmt overallTy cenv.g.unit_ty",126],["UnifyTypes cenv env mStmt overallTy cenv.g.unit_ty",126],["GenUnitThenSequel cenv eenv m eenv.cloc cgbuf sequel",126],["use _holder = TemporarilySuspendReportingTypecheckResultsToSink cenv.tcSink",126],["if cenv.reportErrors then",235],["GenExpr cenv cgbuf eenv SPSuppress e Continue;",286],["GenSequel cenv eenv.cloc cgbuf sequel",594]],"useCount":79490},{"word":"cfg","context":[["cfg.ToString()",258],["let cfg = DependenciesFile.FromCode(config)",200],["let { Directory = dir; Config = cfg } = testContext ()",165],["cfg.Groups.[Constants.MainDependencyGroup].Options.Strict |> shouldEqual false",121],["let exec p = Command.exec dir cfg.EnvironmentVariables { Output = Inherit; Input = None; } p >> checkResult",118],["|> LockFileSerializer.serializePackages cfg.Groups.[Constants.MainDependencyGroup].Options",115],["let cfg = DependenciesFile.FromCode(after)",100],["let cfg = DependenciesFile.FromCode(config1)",98],["do! SingleTestBuild.singleTestBuild cfg dir p",71],["let fsc = Printf.ksprintf (Commands.fsc exec cfg.FSC)",73]],"useCount":3550},{"word":"cgbuf","context":[["GenSequelEndScopes cgbuf sequel",67],["GenExpr cenv cgbuf eenv SPSuppress arg1 Continue;",65],["GenExpr cenv cgbuf eenv SPSuppress e Continue",85],["GenExprs cenv cgbuf eenv args;",91],["GenUnitThenSequel cenv eenv m eenv.cloc cgbuf sequel",126],["GenExpr cenv cgbuf eenv SPSuppress e Continue;",286],["CommitGetStorageSequel cenv cgbuf eenv m typ None storeSequel",64],["let endOfHandler = CG.GenerateMark cgbuf \"endOfHandler\"",57],["let startOfHandler = CG.GenerateMark cgbuf \"startOfHandler\"",57],["GenSequel cenv eenv.cloc cgbuf sequel",594]],"useCount":11595},{"word":"char","context":[["r@ tis-next-char",54],["when 'T : char    = (# \"ceq\" x y : bool #)",33],["// char type",36],["// char",41],["r@ tis-fetch-char IF",42],["| :? char as x -> ilg.Emit(OpCodes.Ldc_I4, int32 x)",64],["char+",60],["[char] \" parse",44],["let! _ = char '\"'",44],["| Char of char",53]],"useCount":2504},{"word":"chart","context":[["chart",71],["/// <param name=\"data\">The data for the chart.</param>",403],["/// <param name=\"data\">The data for the chart. Each observation adds a data element to the chart.</param>",49],["/// <param name=\"data\">The data for the chart. Each observation adds a data element to the chart.</param>",49],["/// chart.",32],["/// <param name=\"Options\">The chart's options.</param>",159],["/// <param name=\"data\">The chart's data.</param>",159],["/// <param name=\"data\">The data for the chart. Each observation replaces the entire data on the chart.</param>",224],["/// <param name=\"data\">The data for the chart. Each observation replaces the entire data on the chart.</param>",224],["/// <param name=\"Title\">The title of the chart.</param>",753]],"useCount":2561},{"word":"check","context":[["check",927],["member this.DeclaringTypeImpl with set x = declaringType <- x // check: not set twice",214],["let run,check = checkResult command",176],["member __.DeclaringTypeImpl with set x = declaringType <- x // check: not set twice",90],["check()",80],["check 0",72],["// check lengths",72],["/// <remarks>A cancellation check is performed when the computation is executed.",49],["// NICE: it would be better to do this check in the type checker",57],["// check contents",54]],"useCount":7447},{"word":"checkNonNull","context":[["checkNonNull \"array2\" array2",139],["checkNonNull \"source2\" source2",102],["checkNonNull \"resizeArray\" resizeArray",136],["checkNonNull \"array1\" array1",139],["checkNonNull \"bimap\" bimap",244],["checkNonNull \"list\" list",265],["checkNonNull \"map\" map",328],["checkNonNull \"set\" set",458],["checkNonNull \"source\" source",741],["checkNonNull \"array\" array",1084]],"useCount":5053},{"word":"checker","context":[["let wholeProjectResults = checker.ParseAndCheckProject(Project1.options) |> Async.RunSynchronously",127],["checker = None",181],["let options =  checker.GetProjectOptionsFromCommandLineArgs (projFileName, args)",408],["let options = checker.GetProjectOptionsFromCommandLineArgs (projFileName, args)",45],["let wholeProjectResults = checker.ParseAndCheckProject(Project31.options) |> Async.RunSynchronously",50],["let wholeProjectResults = checker.ParseAndCheckProject(Project4.options) |> Async.RunSynchronously",55],["let wholeProjectResults = checker.ParseAndCheckProject(Project2.options) |> Async.RunSynchronously",55],["// NICE: it would be better to do this check in the type checker",57],["Check.QuickThrowOnFail(checker, maxRuns = __.FsCheckMaxTests)",60],["let checker = FSharpChecker.Create()",69]],"useCount":2766},{"word":"checking","context":[["//     ctor = 1 indicates actually type checking the body expression",20],["let checking = false",24],["// Try to use the exact results of name resolution during type checking to generate the results",26],["// type checking and intellisense-like environment-reporting.",74],["// type checking and intellisense-like environment-reporting.",46],["// There should be no bindings that have not been generalized since checking the vary last binding always",40],["// 'delayed' is about to be dropped on the floor, first do rudimentary checking to get name resolutions in its body",36],["/// If true, indicates all type checking and code generation is in the context of fsi.exe",30],["//      source code in the editor. Type checking is abandoned when this returns 'true'.",30],["/// Indicates if the type inference variable was generated after an error when type checking expressions or patterns",34]],"useCount":2384},{"word":"choose","context":[["|> Seq.choose (function :? ProvidedConstructor as pcinfo when not pcinfo.IsTypeInitializer -> Some pcinfo | _ -> None)",51],["for evt in ptd.GetEvents(ALL) |> Seq.choose (function :? ProvidedEvent as pe -> Some pe | _ -> None) do",51],["for pinfo in ptd.GetProperties(ALL) |> Seq.choose (function :? ProvidedProperty as pe -> Some pe | _ -> None) do",51],["choose [",98],["|> List.choose id",158],["|> Seq.choose id",159],["choose",48],["|> Array.choose id",41],["|> List.choose (function",36],["// choose only fields",34]],"useCount":2895},{"word":"class","context":[["class end",95],["(\"C\", \"M.C\", \"file1\", ((9, 15), (9, 16)), [\"class\"]);",72],["type Class() = class end",71],["[\"class\"; \"provided\"; \"erased\"]);",55],["// per spec, extension members in F1 keywords are qualified with definition class",51],["type DateTime() = class end",48],["class;",360],["class",171],["/// static fields, 'val' declarations and hidden fields from the compilation of implicit class constructions.",102],["class",563]],"useCount":7280},{"word":"cloc","context":[["GenUnitThenSequel cenv eenv.cloc cgbuf sequel",18],["GenSequel cenv eenv.cloc cgbuf sequel",594],["GenUnitThenSequel cenv eenv m eenv.cloc cgbuf sequel",126],["GenSequel cenv eenvouter.cloc cgbuf sequel",48],["mkILTyRef(cloc.clocScope,tyname)",32],["CommitCallSequel cenv eenv m eenv.cloc cgbuf mustGenerateUnitAfterCall sequel",28],["allocVal cloc bind.Var eenv",19],["AddBindingsForModuleDef allocVal cloc eenv mdef",16],["GenSequel cenv eenv.cloc cgbuf sequelAfterJoin",19],["match cloc.clocEncl with",32]],"useCount":2605},{"word":"cmd","context":[["cmd",168],["match cmd with",135],["use reader = cmd.ExecuteReader()",83],["printfn \"cmd=\\\"%s\\\"\" cmd",95],["printfn \"cmd=\\\"%s\\\"\" cmd",95],["Common.QueryEvents.PublishSqlQuery cmd.CommandText",168],["x.ParseSendBackAtDaemonAndDispose( queuePeer, cmd, msReply )",80],["let cmd = tool.InternalGenerateCommandLineCommands()",119],["cmd.CommandText <- sb.ToString()",102],["cmd.ExecuteNonQuery() |> ignore",102]],"useCount":3078},{"word":"code","context":[["0 // return an integer exit code",537],["// By using this source code in any fashion, you are agreeing to be bound",490],["end-code",339],["let code =",150],["///<code lang=\"F#\">",220],["///</code>",220],["// By using this source code in any fashion, you are agreeing to be bound",203],["///<code lang=\"F#\">",156],["///</code>",156],["match code with",142]],"useCount":12176},{"word":"codebuf","context":[["emitVolatility codebuf vol",80],["emitAfterTailcall codebuf tl",52],["emitVolatility codebuf vol;",70],["let handlerStart = codebuf.code.Position",52],["let handlerFinish = codebuf.code.Position",52],["emitInstrCode codebuf i",48],["commitSuspNoDest codebuf susp;",42],["emitAlignment codebuf al;",56],["emitInstrCode codebuf",60],["emitAlignment codebuf al",64]],"useCount":2791},{"word":"collect","context":[["|> List.collect(fun g -> g |> getDescendants \"ProjectTypeGuids\")",23],["|> collect",109],["|> Seq.collect id",82],["let collect name =",40],["// So collect up free vars in all constraints first, then bind all variables",38],["|> List.collect (fun tycon ->",32],["|> List.collect (fun meth ->",28],["|> List.collect getKeyValueList",28],["|> Array.collect search",27],["infoReader.GetEntireTypeHierachy(AllowMultiIntfInstantiations.Yes,m,typ) |> List.collect (fun typ ->",24]],"useCount":2742},{"word":"color","context":[["/// <param name=\"TitleColor\">The color of the title of the axis</param>",56],["let color =",43],["member __.color",43],["gl_FragColor = vec4(color, 1.0);",48],["/// <param name=\"Color\">The color for the data.</param>",753],["out vec4 color;",236],["vec3 color;",92],["gl_FragColor = color;",90],["return color;",63],["vec4 color;",58]],"useCount":2184},{"word":"com","context":[["<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",113],["(* http://github.com/domasin/HolZeroFs                                        *)",68],["<Choose xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",146],["Email: jinl at microsoft dot com",273],["**  https://github.com/fscheck/FsCheck                              **",55],["// For the further information contact <mailto:david.sorokin@gmail.com>.",57],["#if CROSS_PLATFORM_COMPILER // see https://bugzilla.xamarin.com/show_bug.cgi?id=22591",62],["// For the further information contact <mailto:david.sorokin@gmail.com>.",62],["use reader = com.ExecuteReader()",68],["<ItemGroup xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",70]],"useCount":2495},{"word":"command","context":[["command",56],["let command =",435],["use reader = command.ExecuteReader()",62],["match (command.Verb, command.Noun ) with",73],["match (command.Verb, command.Noun ) with",73],["match command with",139],["let commandResult = handler.Handle(command)",44],["command {",37],[".AppendLine(command.Name)",36],["let run,check = checkResult command",176]],"useCount":2804},{"word":"compare","context":[["| _ -> invalidArg \"that\" \"cannot compare value of different types\"",54],["compare nm1 nm2 }",38],["/// Note: this is true for the overrides generated by hash/compare augmentations",32],["/// <summary>Uses a sequence of columns to compare values across categories.</summary>",28],["/// Elements are compared using Operators.compare.</summary>",25],["// read and compare the stream name byte by byte",22],["if idx1 < idx2 then -1 elif idx1 > idx2 then 1 else compare t1.Tag t2.Tag",140],["match compare ai bi with",104],["// Note: Relies on 'compare' respecting true > false",84],["| _ -> invalidArg \"yobj\" \"cannot compare values of different types\"",71]],"useCount":1852},{"word":"comparer","context":[["let acc = partitionAux comparer f r acc",37],["override t.CompareTo (other:obj,comparer:System.Collections.IComparer) =",72],["let c = comparer.Compare(k,k2)",295],["let  n = GenericComparisonWithComparerFast comparer x1 y1",36],["partitionAux comparer f l acc",37],["let c = comparer.Compare(n1k,n2k)",72],["override t.GetHashCode(comparer:System.Collections.IEqualityComparer) =",72],["override t.Equals (other:obj,comparer:System.Collections.IEqualityComparer) =",63],["/// Elements within each partition/bin are sorted using the 'comparer'.",48],["let rec mkFromEnumerator comparer acc (e : IEnumerator<_>) =",37]],"useCount":3126},{"word":"compgen","context":[["|> List.filter (fun (_,compgen,_) -> not compgen)",33],["let e1' = remapExpr g compgen tmenv e1",38],["let iimpls = iimpls |> List.filter (fun (_,compgen,_) -> not compgen)",33],["match compgen with",74],["let args' = remapExprs g compgen tmenv args",38],["let _,_,tmenvinner = copyAndRemapAndBindTyconsAndVals g compgen tmenv tycons vs",38],["let bind',tmenvinner = copyAndRemapAndBindBinding g compgen tmenv bind",38],["let mdef = copyAndRemapModDef g compgen tmenv mdef",38],["let iimpls = iimpls |> List.filter (fun (_,compgen,_) -> not compgen)",33],["|> List.filter (fun (_,compgen,_) -> not compgen)",33]],"useCount":2441},{"word":"compiled","context":[["/// of measure is erased in compiled code and when values of this type",76],["// therefore, we can perform inlining to translate this to a form that can be compiled",59],["// Handle the case where this is a generic method instantiated at a type being compiled",51],["/// Gets the data indicating the compiled representation of a type or module in terms of Abstract IL data structures.",34],["/// <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>",49],["[<CompilerMessage(\"This value is for use by compiled F# code and should not be used directly\", 1204, IsHidden=true)>]",45],["/// Holds the data indicating how this assembly/module is referenced from the code being compiled.",39],["/// Indicates that this DLL was compiled using the F# compiler and has F# metadata",38],["// expect no warning, and attribute to be in compiled code",36],["// Code for potential future design change to allow functions-compiled-as-members in structs",36]],"useCount":2055},{"word":"compiler","context":[["CompilerComponent.create <| fun (|Split|) compiler returnStrategy ->",38],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234],["// Open up the compiler as an incremental service for parsing,",72],["/// a true body. These cases are often causes of bugs in the compiler.",60],["* FSharp.Quotations.Compiler - a compiler for F# expression tree",56],["/// <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>",49],["let compiler, a, b, c, size, wrapper = GetData()",46],["let compiler = new Compiler()",42],["// implementation details used by other code in the compiler",40],["/// Indicates that this DLL was compiled using the F# compiler and has F# metadata",38]],"useCount":3677},{"word":"computation","context":[["/// Applies a function to each element of the collection, threading an accumulator argument through the computation.",36],["/// If <c>cancelAction</c> is not specified, then cancellation causes the computation",35],["/// as a cache for this sig-string computation.",34],["/// Lifts a computation.",42],["/// Converts the computation to a result property.",44],["/// <remarks>A cancellation check is performed when the computation is executed.",49],["/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>",57],["/// This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.",64],["/// Converts the computation to a result source.",72],["/// <c>async { ... }</c> computation expression syntax.</remarks>",70]],"useCount":2387},{"word":"concat","context":[["|> String.concat \",\"",108],["// let typenames = String.concat \",\" (types |> Array.map (fun t -> t.Name))",41],["if sco = \"\" then basic else String.concat \", \" [basic;sco]",44],["|> String.concat \", \"",80],["|> String.concat \" \"",102],["|> String.concat \"\\n\"",102],["|> String.concat \"\"",130],["|> Array.concat",157],["|> List.concat",509],["|> Seq.concat",755]],"useCount":4696},{"word":"config","context":[["let dependencies = DependenciesFile.FromCode(config)",181],["config",107],["Guard.argNotNull (config, \"config\")",120],["Guard.argNotNull (config, \"config\")",120],["/// <param name=\"config\">The database configuration.</param>",133],["let db = LocalDbImpl(config, connection)",141],["let config = \"\"\"",177],["let cfg = DependenciesFile.FromCode(config)",200],["let config =",203],["include ffl/config.fs",239]],"useCount":5243},{"word":"constant","context":[["constant bigendian?   ( -- flag = Check for bigendian hardware )",51],["s\" Invalid data\"       exception constant exp-invalid-data       ( -- n = Invalid data exception number )",47],["// These are some constant expressions which can be accessed from context",85],["s\" Wrong file type\"    exception constant exp-wrong-file-type    ( -- n = Wrong file type )",47],["| _ -> failwithf \"unknown constant '%A' in generated method\" v",64],["float constant;",57],["s\" Wrong file version\" exception constant exp-wrong-file-version ( -- n = Wrong file version )",47],["s\" Wrong length\"       exception constant exp-wrong-length       ( -- n = Wrong length )",47],["s\" Wrong file data\"    exception constant exp-wrong-file-data    ( -- n = Wrong file data )",47],["s\" Wrong checksum\"     exception constant exp-wrong-checksum     ( -- n = Wrong checksum )",47]],"useCount":1843},{"word":"constraint","context":[["// is known to satisfy the default constructor constraint even before any of its members have been established.",20],["// Checks if a field type supports the 'comparison' constraint based on the assumptions about the type constructors",20],["/// Indicates a constraint that a type has a parameterless constructor",21],["/// Indicates a constraint that a type is a subtype of the given type",21],["/// Indicates a constraint that a type is a non-Nullable value type",21],["/// Indicates a constraint that a type is a reference type",21],["/// Indicates a constraint that a type is an enum with the given underlying",21],["/// Indicates a constraint that a type is a delegate from the given tuple of args to the given return type",21],["/// Indicates a constraint that a type has a 'null' value",21],["| _ -> invalidOp \"incorrect constraint kind\"",35]],"useCount":2177},{"word":"constraints","context":[["| Expr.StaticOptimization (constraints,e2,e3,m) ->",57],["let constraints',tpenv = List.mapFold (TcStaticOptimizationConstraint cenv env) tpenv constraints",20],["// Adhoc constraints on use of .NET methods",20],["constraints |> List.iter (function",23],["/// Indicates if the type variable can be sovled or given new constraints. The status of a type variable",24],["/// Indicates if the type variable can be solved or given new constraints. The status of a type variable",27],["#if EXTENDED_EXTENSION_MEMBERS // indicates if extension members can add additional constraints to type parameters",36],["// So collect up free vars in all constraints first, then bind all variables",38],["// Canonicalize constraints prior to generalization",62],["// Bound type vars form a recursively-referential set due to constraints, e.g.  A : I<B>, B : I<A>",38]],"useCount":2548},{"word":"constructor","context":[["/// Set the quotation used to compute the implementation of invocations of this constructor.",40],["/// This is used to typecheck legitimate 'non-main body of object constructor' expressions",40],["/// <param name=\"expr\">The name of the parameter, expressed as quotation of DU constructor.</param>",59],["| _ -> failwith \"at most one implicit constructor allowed\"",59],["// convert NewTuple to the call to the constructor of the Tuple type (only for generated types)",60],["// Otherwise, assume this is a generative assembly and just emit a call to the constructor or method",63],["// Allow at most one constructor, and use its arguments as the fields of the type",64],["// Emit the constructor (if any)",64],["/// Represents the type constructor in a provided symbol type.",68],["/// Add XML documentation information to this provided constructor",217]],"useCount":4196},{"word":"cont","context":[["match cont with",86],["fun state cont ->",48],["fun (exec, cont) ->",32],["fun ctx cont ->",34],["processWhiteAndComment str offset delay cont )",34],["if ctx.IsCancellationRequested then cont.Cancel ctx else",38],["if ctx.IsCancellationRequested then cont.Cancel ctx",40],["cont.Exception ctx (ExceptionDispatchInfo.Capture se)",44],["cont res",31],["return cont",45]],"useCount":1946},{"word":"contains","context":[["if Zset.contains typar env.singletons then",33],["//             failwith (sprintf \"Unknown type '%s' in namespace '%s' (contains %s)\" typeName namespaceName typenames)",41],["// This file contains a set of helper types and methods for providing types in an implementation",34],["if List.contains ilShortAssemName externalSigAndOptData then",36],["if Zset.contains qualNameOfFile rootImpls then",40],["/// - A private key blob which has been encrypted and contains information to initialize RSA",42],["/// Returns a data frame that contains the same data as the input,",45],["if ListSet.contains g.valRefEq v rvs then",48],["( The config module contains the extension and missing words for a forth system.)",54],["// This file contains a set of helper types and methods for providing types in an implementation",61]],"useCount":2971},{"word":"content","context":[["let content = \"\"\"",336],["let doc = Literate.ParseMarkdownString(content, formatAgent=getFormatAgent())",37],["match entry |> getNode \"content\" |> optGetAttribute \"type\",",28],["entry |> getNode \"content\" |> optGetAttribute \"src\"  with",28],["let buffer = createMockTextBuffer content fileName",265],["helper.SetUpProjectAndCurrentDocument(createVirtualProject(buffer, fileName), fileName, content)",59],["content",56],["let content =",53],["match content with",41],["let content = File.ReadAllText fileName",49]],"useCount":1937},{"word":"contents","context":[["Microsoft.FSharp.Core.FSharpRef`1[T]: T contents",28],["// check contents",54],["obox   Open a \"box\" whose contents will be indented by two spaces if",54],["let contents =",41],["/// A handle to the full specification of the contents of the module contained in this ccu",39],["{ templateFile with Contents = contents }",35],["// The contents of this file are made available under the terms of the",76],["// each filter is effectively the entire contents of each where clause in the linq query,",34],["/// The logical contents of the entity when it is a type definition.",34],["/// The logical contents of the entity when it is a module or namespace fragment.",34]],"useCount":2148},{"word":"context","context":[["member __.ActorSelection(path : ActorPath) = context.ActorSelection(path)",40],["// These are some constant expressions which can be accessed from context",85],["context",42],["let context =",40],["match context with",41],["member __.ActorSelection(path : string) = context.ActorSelection(path)",40],["member __.ActorOf(props, name) = context.ActorOf(props, name)",40],["member __.Log = lazy (Akka.Event.Logging.GetLogger(context))",39],["member __.Context = context",38],["if context <> DirectArg && cenv.reportErrors then",34]],"useCount":2694},{"word":"convType","context":[["let ety = convType (ty.GetElementType())",59],["static member convType (parameters: Type list) (ty:Type) =",59],["let args = Array.map (ProvidedSymbolType.convType parameters) (ty.GetGenericArguments())",59],["let rec convType (ty:Type) =",58],["if ty.IsGenericType then ty.GetGenericTypeDefinition().MakeGenericType (Array.map convType (ty.GetGenericArguments()))",58],["let targetTy = convType ty",56],["ilg.Emit(OpCodes.Ldelema, convType ty)",54],["let args = meth.GetGenericArguments() |> Array.map convType",54],["let ety = ProvidedSymbolType.convType parameters (ty.GetElementType())",60],["let aty = convType cenv emEnv  (ILType.Array(shape,typ))",64]],"useCount":2434},{"word":"core","context":[["| CompleteInfo(core, optional) ->",33],["#version 330 core",300],["| CompleteTemplate(core, opt) ->",61],["#version 150 core",50],["#version 430 core",93],["#version 420 core",35],["#version 410 core",33],["#version 400 core",33],["| ProjectInfo(core, optional) ->",33],["match core.Version with",37]],"useCount":2024},{"word":"count","context":[["/// <param name=\"limit\">The max row count. Negative value means infinite.</param>",87],["if count < 0 then",75],["let count = ref 0",280],["let mutable count = 0",216],["count <- count + 1",180],["count <- count + 1",180],["count",132],["for i = 0 to count - 1 do",92],["match count with",89],["if count < 0 then invalidArg \"count\" (SR.GetString(SR.inputMustBeNonNegative))",69]],"useCount":6025},{"word":"cr","context":[[".\" }\" cr",40],["\\ 2 c, 13 c, 10 c,   \\ dos:  cr lf",27],["match rescopeILTypeSpecQuick scoref cr with",34],["cr cr",35],["cr cr",35],["\\ .\" Type: \" dup mal-type @ type-name safe-type cr",26],[".\" }\" cr ;",48],[".\" {\" cr",48],["cr ;",63],["cr",513]],"useCount":1889},{"word":"create","context":[["let create() =",34],["/// Helps create erased provided unit-of-measure annotations.",33],["let fileguard = (Commands.getfullpath dir) >> FileGuard.create",33],["// PassA: create member prelimRecValues for \"recursive\" items, i.e. ctor val and member vals",30],["CompilerComponent.create <| fun (|Split|) compiler returnStrategy ->",38],["let eptArr = Array2D.create 0 0 1",40],["create ,",50],["// initially supporting update/create/delete of single entities, no hierarchies yet",56],["// Only create a new tree when the subtree is actually modified.",64],["create",91]],"useCount":2419},{"word":"cref","context":[["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["/// <exception cref=\"System.ArgumentException\">Thrown when the input array is empty.</exception>",50],["/// <exception cref=\"System.ArgumentException\">Thrown when the input type is not a record type.</exception>",52],["/// <exception cref=\"System.ArgumentException\">Thrown when the list is empty.</exception>",60],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",66],["/// <exception cref=\"System.ArgumentException\">Thrown when the input arrays differ in length.</exception>",71],["/// <exception cref=\"Soma.Core.NoAffectedRowException\">Thrown when there is no affected row.</exception>",48],["/// <exception cref=\"System.ArgumentNullException\">Thrown when either of the input sequences is null.</exception>",46],["/// <exception cref=\"System.ArgumentException\">Thrown when the input sequence is empty.</exception>",73],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518]],"useCount":2741},{"word":"csenv","context":[["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty1 ++ (fun () ->",98],["let g = csenv.g",286],["(csenv:ConstraintSolverEnv)",56],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty ++ (fun () ->",70],["csenv",70],["let aenv = csenv.EquivEnv",70],["let denv = csenv.DisplayEnv",260],["let m = csenv.m",238],["let amap = csenv.amap",116],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace argty2 argty1 ++ (fun () ->",78]],"useCount":4736},{"word":"ctor","context":[["| Quotations.Patterns.NewObject (ctor,args) ->",55],["let ctor, restTyOpt = Reflection.FSharpValue.PreComputeTupleConstructorInfo ty",60],["(\"member .ctor\",",69],["let ctor =",74],["override this.Name = if this.IsStatic then \".cctor\" else \".ctor\"",45],["let ctor = lambda.DefineDefaultConstructor(MethodAttributes.Public)",51],["[\"member\"; \"ctor\"]);",165],["callSiteIlg.Emit(OpCodes.Newobj, ctor)",51],["Quotations.Expr.NewObject(ctor, curr @ [mkCtor rest restTy])",52],["| None -> Quotations.Expr.NewObject(ctor, List.map trans args)",53]],"useCount":6319},{"word":"ctx","context":[["let cultureStr = ctx.CultureStr",51],["let rec pickfreshname ctx x =",50],["match ctx with",132],["Printf.sprintf \"Variable lookup failure: offset: %d, ctx size: %d\"",96],["ctx)",94],["ctx",76],["let (t1', store') = eval1 ctx store t1",58],["writer.Indent ctx.Indentation",56],["writer.Unindent ctx.Indentation",55],["let ctx = Db.getContext()",51]],"useCount":8507},{"word":"ctxt","context":[["let nm = readStringHeap ctxt nameIdx",144],["let flags = seekReadUInt16AsInt32Adv ctxt &addr",77],["match ctxt with",82],["let nm = readBlobHeapAsTypeName ctxt (nameIdx,namespaceIdx)",90],["let bytes = readBlobHeap ctxt blobIdx",108],["let typ, sigptr = sigptrGetTy ctxt numtypars bytes sigptr",108],["let nameIdx = readStringIdx ctxt",119],["let nameIdx = seekReadStringIdx ctxt &addr",187],["seek ctxt.is addr;",238],["let ctxt = getHole ctxtH",486]],"useCount":16363},{"word":"curr","context":[["curr := !curr + 1;",60],["curr := !curr + 1;",60],["let curr = [for a in Seq.take 7 args -> trans a]",55],["if curr > acc then",55],["if curr < acc then",53],["let dest = !curr + offsDest",72],["let (tab,idx) = seekReadUncodedToken ctxt.is (start + (!curr))",72],["acc <- curr",108],["curr := !curr + 4;",195],["curr := !curr + 4;",195]],"useCount":2555},{"word":"current","context":[["//    printfn \"function result: %A %A\" current rest",51],["// Apply the mapping to the current element and state value.",48],["// Apply the folder to the current element and state values.",48],["// Note this modifies the real honest-to-goodness settings for the current shell.",42],["Assert.AreEqual(current, currentResult)",40],["// the type of the current expression with a type variable that indicates an error",38],["cbox   Close the current box",54],["the whole box cannot fit on the current line",54],["set-current",69],["match current with",47]],"useCount":3751},{"word":"customAttributesImpl","context":[["member __.AddXmlDocDelayed xmlDocFunction             = customAttributesImpl.AddXmlDocDelayed xmlDocFunction",126],["member __.AddXmlDocComputed xmlDocFunction            = customAttributesImpl.AddXmlDocComputed xmlDocFunction",126],["override __.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",129],["member this.AddXmlDocDelayed xmlDoc                     = customAttributesImpl.AddXmlDocDelayed xmlDoc",304],["member __.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",126],["override this.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",311],["member this.AddXmlDocComputed xmlDoc                    = customAttributesImpl.AddXmlDocComputed xmlDoc",304],["member this.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",304],["let customAttributesImpl = CustomAttributesImpl()",562],["member __.GetCustomAttributesDataImpl() = customAttributesImpl.GetCustomAttributesData()",476]],"useCount":3249},{"word":"d","context":[["let a = p1 st in let b = p2 st in let c = p3 st in let d = p4 st in",104],["match d.TryRecdField with",98],["Printf.sprintf \"Variable lookup failure: offset: %d, ctx size: %d\"",96],["Printf.sprintf \"Variable lookup failure: offset: %d, ctx size: %d\"",96],["[| (5, 'a'); (3, 'b'); (11, 'f'); (2, 'd'); (17, 'a'); (4, 'g'); (12, 'b'); (14, 'c'); (11, 'F'); (4, 'G'); |]",84],["let valueKeyMap = Map.ofSeq [(2,\"b\"); (3,\"c\"); (4,\"d\"); (5,\"e\")]",133],["d",159],["let d = timer.Elapsed",173],["reportDeprecatedOption d",266],["match d with",1248]],"useCount":19168},{"word":"data","context":[["data",404],["/// <param name=\"Color\">The color for the data.</param>",753],["match data with",249],["/// <param name=\"data\">The data for the chart. Each observation replaces the entire data on the chart.</param>",224],["/// <param name=\"data\">The data for the chart.</param>",403],["/// <param name=\"data\">The data for the chart.</param>",403],["/// <param name=\"Labels\">The labels that match the data.</param>",392],["/// <param name=\"Name\">The name of the data set.</param>",753],["// /// <param name=\"Labels\">The labels that match the data.</param>",301],["let data =",297]],"useCount":23040},{"word":"debug","context":[["debug-disk-label? IF",55],["if debug env Options.Low",32],["if debug env <| Options.Other \"Rel\"",55],["debug-client-interface? IF",71],["fdt-debug IF",40],["if Flags.debug then",48],["vscsi-debug IF",54],["let debug = false",55],["if Env.debug env Options.High",36],["scsi-disk-debug? IF",35]],"useCount":2912},{"word":"declaration","context":[["/// Get the type parameters for an entity that is a type declaration, otherwise return the empty list.",68],["// Process a class declaration or F# type declaration",34],["let declaration = XDeclaration(\"1.0\", \"UTF-8\", \"yes\")",64],["/// Note: result is a indexed table, and for each name the results are in reverse declaration order",37],["/// The host F# compiler does this when processing a generative type declaration for the type.",34],["/// The identifier at the point of declaration of the type definition.",34],["XDocument(declaration, box root)",64],["/// Specifies that the given method body implements the given method declaration.",37],["/// Note: result is alphabetically sorted, then for each name the results are in declaration order",37],["/// Indicates if the entity represents an F# exception declaration.",34]],"useCount":1959},{"word":"declared","context":[["/// Indicates if this value was a member declared 'override' or an implementation of an interface slot",29],["// It is declared once on the 'inheritedTys clause, but a fresh binding is made for",40],["/// Analyze three cases for attributes declared on methods: IL-declared attributes, F#-declared attributes and",32],["/// Analyze three cases for attributes declared on methods: IL-declared attributes, F#-declared attributes and",32],["/// Analyze three cases for attributes declared on methods: IL-declared attributes, F#-declared attributes and",32],["///  Indicates the declared visibility of the field, not taking signatures into account",32],["/// Get the declared documentation for the value",32],["/// is declared.",32],["//  Indicates if this value was declared to be a type function, e.g. \"let f<'a> = typeof<'a>\"",29],["/// Get the declared attributes for the value",32]],"useCount":1939},{"word":"default","context":[["// You can specify all the values or you can default the Build and Revision Numbers",1037],["///  - `setParams` - Function used to manipulate the WiX default parameters.",113],["///  - `setParams` - Function used to manipulate the default parameters.",36],["/// Set the attributes on the provided type. This fully replaces the default TypeAttributes.",37],["/// Set the method attributes of the method. By default these are simple 'MethodAttributes.Public'",37],["// to their default values (for optionals) and be part of the return tuple (for out args).",40],["default this.ResolveAssembly(args) =",41],["///  - `setParams` - Function used to manipulate the default NuGet parameters.",55],["///  - `configProcessStartInfoF` - A function which overwrites the default ProcessStartInfo.",82],["default y",113]],"useCount":4650},{"word":"defaultArg","context":[["let maxResults = defaultArg maxResults 1000",77],["let options = defaultArg Options <| Configuration.Options()",119],["let bindingFlags = defaultArg bindingFlags BindingFlags.Public",115],["let beginX = defaultArg minX 0L",60],["let parameters = defaultArg parameters []",68],["let isOut = defaultArg isOut false",65],["|> fun x -> defaultArg x []",65],["let beginX = defaultArg minX 0 |> int64",60],["override __.RawDefaultValue = defaultArg parameterDefaultValue null",64],["let maxX = defaultArg maxX (info.SX - 1L)",60]],"useCount":3354},{"word":"defaultof","context":[["let f1hole = ref (Unchecked.defaultof<_>)",63],["Unchecked.defaultof<_>",123],["let f2hole = ref (Unchecked.defaultof<_>)",63],["let mutable res = Unchecked.defaultof<'res>",62],["let tuple = ref Unchecked.defaultof<_>",56],["let f3hole = ref (Unchecked.defaultof<_>)",54],["let f4hole = ref (Unchecked.defaultof<_>)",45],["let mutable res = Unchecked.defaultof<'Value>",45],["let mutable res = Unchecked.defaultof<_>",250],["let refValue = ref Unchecked.defaultof<_>",126]],"useCount":2948},{"word":"defined","context":[["/// Get a table of types defined within this module, namespace or type. The",34],["[defined] x11 [IF]",41],["/// Indicates if this is an F#-defined delegate type definition",34],["/// Get a list of all fields for F#-defined record, struct and class fields in this type definition,",34],["/// The code location where the module, namespace or type is defined.",34],["/// Get an array of fields for all the F#-defined record, struct and class fields in this type definition, including",34],["// There is an internal version of typeof defined in prim-types.fs that needs to be detected",57],["// OK, the implied nested type is not defined, define it now",59],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["// This file is subject to the terms and conditions defined in",233]],"useCount":2728},{"word":"definition","context":[["/// Create a new provided type definition, to be located as a nested type in some type definition.",37],["/// Add definition location information to the provided type definition.",146],["/// Add definition location information to the provided type definition.",146],["/// Create a new provided method. It is not initially associated with any specific provided type definition.",37],["/// Add definition location information to the provided constructor.",37],["/// Indicates if this entity is an F# type abbreviation definition",46],["// per spec, extension members in F1 keywords are qualified with definition class",51],["/// Create a new provided field. It is not initially associated with any specific provided type definition.",66],["/// Create a new provided type. It is not initially associated with any specific provided type definition.",67],["/// A flag read eagerly from the provided type and used to compute basic properties of the type definition.",85]],"useCount":5763},{"word":"definitions","context":[["// phase 2 - emit member definitions",64],["/// and adjust the 'Assembly' property of all provided type definitions to return that",44],["previous definitions",48],["// Return the set of structural type definitions which support the relation",40],["// Initially, assume the equality relation is available for all structural type definitions",40],["// Compute the top-rooted type definitions",40],["// Repeatedly eliminate structural type definitions whose structural component types no longer support",40],["forth definitions",34],["Forth definitions",36],["// phase 1 - set assembly fields and emit type definitions",64]],"useCount":2460},{"word":"defn","context":[["(\"Impl\", \"Impl\", \"file1\", ((2, 7), (2, 11)), [\"defn\"], [\"module\"])|]",44],["[(\"file1\", ((38, 20), (38, 34)), [\"defn\"], [\"member\"; \"overridemem\"; \"intfmem\"])]);",30],["// Propagate defn location information from implementation to signature .",30],["(\"val x1\", \"x1\", \"file1\", ((4, 4), (4, 6)), [\"defn\"], [\"val\"]);",22],["(\"val x2\", \"x2\", \"file1\", ((5, 4), (5, 6)), [\"defn\"], [\"val\"]);",22],["let (TyconBindingDefn(containerInfo,newslotsOK,declKind,classMemberDef,m)) = defn",18],["defn  |> List.choose (fun mem ->",20],["// a) For interfaces, only if it is in the original defn.",20],["/// implicit ctor args as a defn line, 'as' specification",21],["| Some(defn) -> [ (ity',defn,m) ]",18]],"useCount":2117},{"word":"delayed","context":[["override x.ErrorCount = delayed |> Seq.filter snd |> Seq.length",35],["TcIndexerThen cenv env overallTy mWholeExpr mDot tpenv synExpr e1 e2 delayed",36],["// 'delayed' is about to be dropped on the floor, first do rudimentary checking to get name resolutions in its body",36],["RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects_Delayed cenv env tpenv delayed",36],["| _ -> errorR(Failure(\"internal error: the ccu thunk for assembly \"+x.AssemblyName+\" not delayed!\"))",38],["let errors = delayed |> Seq.toList",40],["then GetMemberApplicationArgs delayed cenv env tpenv",40],["/// Reading is delayed, since it does an import on the underlying type",34],["let delayed = new ResizeArray<_>()",57],["match delayed with",338]],"useCount":1969},{"word":"denv","context":[["(NicePrint.stringOfQualifiedValOrMember denv v)",72],["Some(items, denv, m)",70],["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv t1 t2",54],["let t1,t2,tpcs = NicePrint.minimalStringsOfTwoTypes denv t1 t2",54],["if denv.shortConstraints then",132],["let denv = env.DisplayEnv",158],["(fun res -> ErrorD (ErrorFromAddingConstraint(denv,res,m)))",174],["let denv = csenv.DisplayEnv",260],["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",72],["let _, ty, _cxs = PrettyTypes.PrettifyTypes1 denv.g ty",72]],"useCount":14139},{"word":"dependencies","context":[["Dependencies = dependencies",51],["let dependencies = DependenciesFile.FromCode(config)",181],["dependencies.Groups.[Constants.MainDependencyGroup].RemoteFiles",152],["dependencies",141],["let dependencies =",98],["/// Adds the given package with the given version to the dependencies file.",84],["/// Updates all dependencies.",72],["/// Removes the given package from dependencies file.",48],["| No_Install -> \"Skips paket install --hard process afterward generation of dependencies / references files.\"",42],["/// Installs all dependencies.",89]],"useCount":2772},{"word":"dir","context":[["let build cfg dir = attempt {",58],["let exec p = Command.exec dir cfg.EnvironmentVariables { Output = Inherit; Input = None; } p >> checkResult",118],["let { Directory = dir; Config = cfg } = testContext ()",165],["do! run cfg dir",53],["do! build cfg dir",58],["dir",61],["let dir =",62],["do! SingleTestRun.singleTestRun cfg dir p",65],["match dir with",71],["do! SingleTestBuild.singleTestBuild cfg dir p",71]],"useCount":3087},{"word":"dll","context":[["[<DllImport(\"kernel32.dll\")>]",84],["#r \"../../packages/NUnit/lib/nunit.framework.dll\"",184],["let dllName = Path.ChangeExtension(base2, \".dll\")",436],["[<DllImport(\"nvcuda.dll\")>]",130],["[<DllImport(@\"SDL2.dll\", CallingConvention = CallingConvention.Cdecl)>]",738],["#r \"../../bin/FSharp.Compiler.Service.dll\"",71],["#r \"../../packages/NUnit.2.6.3/lib/nunit.framework.dll\"",71],["[ @\"..\\Fantomas\\lib\\FantomasLib.dll\"",68],["@\"..\\Fantomas\\lib\\FSharp.Core.dll\"",68],["[<DllImport(dll, CallingConvention=calling, ExactSpelling=exact, SetLastError=last)>]",73]],"useCount":8882},{"word":"do","context":[["do()",572],["while true do",493],["for i = 0 to len - 1 do",403],["for cust in dc.Main.Customers do",217],["while e.MoveNext() do",257],["do ()",1969],["static do Android.Runtime.ResourceIdManager.UpdateIdValues()",189],["for i = 0 to len1 - 1 do",182],["for i = 0 to n - 1 do",156],["do",3569]],"useCount":40062},{"word":"doc","context":[["doc",229],["doc.Blocks",170],["let doc = XmlDocument()",120],["let doc =",113],["Markdown.TransformHtml doc",93],["let doc = new XmlDocument()",74],["doc.LoadXml raw",71],["// XML doc text that we only compute once, if any. This must _not_ be forced until the ConstructorArguments",64],["/// This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.",64],["/// This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.",64]],"useCount":3625},{"word":"does","context":[["// NOTE: ;; does not terminate a 'namespace' body.",42],["/// or comes from another F# assembly then it does not (because the documentation will get read from",34],["/// then this does not include any attributes from those sources.",34],["// This does not need to be run on the background thread",34],["/// Reading is delayed, since it does an import on the underlying type",34],["// Generic type names are (name ^ \"`\" ^ digits) where name does not contain \"`\".",38],["/// Note that the type provider specification does not require us to implement pointer-equality for provided types.",68],["// Not, this does not have to be a SyncOp, it can be called from any thread",48],["does>",50],["/// The host F# compiler does this when processing a generative type declaration for the type.",34]],"useCount":2425},{"word":"don","context":[["// In this case, we don't want any of the fallback logic, rather, we want to produce zero results.",24],["/// The size after which we don't inline",24],["let loadedTimeStamp = defaultArg loadedTimeStamp DateTime.MaxValue // Not 'now', we don't want to force reloading",31],["// Provider-generated assemblies don't necessarily have an on-disk representation we can load.",36],["// The entire data segment is filtered out, don't generate a call in this case.",39],["// Initially, don't assume that the equality relation is dependent on any type varaibles",40],["// These don't have to return fully accurate results - they are used",60],["// nice: don't introduce awful temporary for r.h.s. in the 99% case where we know what we're binding it to",60],["// method produced something, but we don't need it",64],["2drop                           \\ | don't do anything",88]],"useCount":3034},{"word":"done","context":[["done;",500],["printfn \"done\"",24],["done",187],["printfn \"done.\"",48],["// OK, we're done, Record the results for the type variable which provide the support",40],["// Eliminate subsumption coercions for functions. This must be done post-typechecking because we need",34],["// Write FieldRVA table - fixups into data section done later",30],["//                       done",28],["// This is pretty fragile, e.g. the script lookup is done via a regular expression.",24],["/// the reader and the LexBuffer. The caller should dispose the first two when done.",23]],"useCount":1880},{"word":"drop","context":[["THEN drop",41],["drop",2137],["drop ;",182],["r> drop",144],["drop 0",117],["// just drop rhs on the floor",72],["drop()",63],["drop false",59],["drop 2drop",42],["2drop drop",40]],"useCount":4840},{"word":"dup","context":[["dup IF                                  \\ IF Size > 0",48],["?dup 0= IF",55],["?dup if",61],["?dup IF",68],["dup >r",68],["dup 0= if",74],["dup nil<> IF",89],["?dup",92],["dup IF",133],["dup",490]],"useCount":3958},{"word":"e","context":[["use e = source.GetEnumerator()",308],["| Some e ->",361],["if e.MoveNext() then",180],["| e ->",1044],["match e with",2467],["with e ->",2621],["e",307],["GenExpr cenv cgbuf eenv SPSuppress e Continue;",286],["while e.MoveNext() do",257],["with e->",210]],"useCount":55087},{"word":"e1","context":[["/// <param name=\"e1\">The first value.</param>",165],["| Quotations.Patterns.Sequential(e1, e2) ->",56],["if e1 === e then",58],["e1",60],["let e1',e1info = OptimizeExpr cenv env e1",60],["let e1',e1info = OptimizeExpr cenv env e1",60],["yield! walkExpr false e1",137],["let e1R = ConvExpr cenv env e1",96],["walkExpr e1 || walkExpr e2",95],["let mExprAndDotLookup = unionRanges e1.Range (rangeOfLid longId)",72]],"useCount":8128},{"word":"e2","context":[["/// <param name=\"e2\">The second value.</param>",165],["| Expr.StaticOptimization (constraints,e2,e3,m) ->",57],["emit expectedState e2",56],["yield! walkExpr true e2",79],["yield! walkExpr false e2",60],["| Quotations.Patterns.Sequential(e1, e2) ->",56],["let expr = mbuilder.Close(dtree,m,tyOfExpr g e2)",56],["GenExpr cenv cgbuf eenv SPSuppress e2 Continue;",52],["| DelayedSet(e2,mStmt) :: otherDelayed ->",90],["walkExpr e1 || walkExpr e2",95]],"useCount":7499},{"word":"each","context":[["Make sure each method works on:",111],["/// Performs setup for each unit test.",40],["/// Executed once prior to running each unit test in this fixture.",40],["/// Returns a supervisor strategy appliable to each supervised actor when any of them had faulted during execution.",41],["/// Creates a new dataset whose elements are the results of applying the given function to each of the elements",44],["/// Elements within each partition/bin are sorted using the 'comparer'.",48],["// Apply the mapping function to each array element.",48],["/// Applies the given function to each binding in the map.",52],["/// <param name=\"predicate\">A function to test each source element for a condition.</param>",70],["// the first key. For each bucket, call 'nodef' on that head key and the bucket.",79]],"useCount":4308},{"word":"eenv","context":[["GenExpr cenv cgbuf eenv SPSuppress e Continue;",286],["GenSequel cenv eenv.cloc cgbuf sequel",594],["eenv",128],["GenUnitThenSequel cenv eenv m eenv.cloc cgbuf sequel",126],["GenUnitThenSequel cenv eenv m eenv.cloc cgbuf sequel",126],["GenExprs cenv cgbuf eenv args;",91],["GenExpr cenv cgbuf eenv SPSuppress e Continue",85],["GenExpr cenv cgbuf eenv SPSuppress arg1 Continue;",65],["CommitGetStorageSequel cenv cgbuf eenv m typ None storeSequel",64],["GenExpr cenv cgbuf eenv SPSuppress e2 Continue;",52]],"useCount":10586},{"word":"element","context":[["/// <param name=\"predicate\">A function to test each source element for a condition.</param>",70],["/// function indicates the index of element.</summary>",49],["/// <param name=\"data\">The data for the chart. Each observation adds a data element to the chart.</param>",49],["// One-element Map",154],["// Apply the mapping to the current element and state value.",48],["// Apply the folder to the current element and state values.",48],["// Apply the mapping function to each array element.",48],["// Add the mapped element to the mapped set and continue iterating.",48],["/// Return the index of the first element in the array",48],["element",53]],"useCount":4053},{"word":"elements","context":[["let elements = ResizeArray ()",131],["elements",182],["/// <param name=\"predicate\">The function to test the input elements.</param>",207],["ilg.Emit(OpCodes.Ldc_I4, List.length elements)",61],["/// <param name=\"folder\">The function to update the state given the input elements.</param>",90],["let elements =",78],["/// <summary>Builds a new collection whose elements are the results of applying the given function",78],["let elems = membersQueue |> Seq.toArray // take a copy in case more elements get added",63],["/// * recurseOnMatch - If a match is found continues down the tree matching child elements",60],["let elems = interfaceImplsDelayed |> Seq.toArray // take a copy in case more elements get added",60]],"useCount":5270},{"word":"elif","context":[["elif ty.IsPointer then ProvidedSymbolType(Pointer,[ety]) :> Type",56],["elif ty.IsPointer then ety.MakePointerType()",72],["elif ty.IsGenericParameter then",63],["elif ty.IsGenericType && ty.GetGenericTypeDefinition() = typedefof<_ list> then",60],["elif meth.DeclaringType.IsGenericType then",59],["if idx1 < idx2 then -1 elif idx1 > idx2 then 1 else compare t1.Tag t2.Tag",140],["elif not argTy.IsValueType && targetTy.IsValueType then",57],["elif ty.IsByRef then ProvidedSymbolType(ByRef,[ety]) :> Type",56],["elif ty.HasElementType then",129],["elif ty.IsByRef then ety.MakeByRefType()",72]],"useCount":9006},{"word":"else","context":[["if c <> 0 then c else",662],["if isUnresolved() then false else",324],["#else",587],["else []",535],["else",64144],["else false",511],["else None",2235],["#else",9593],["else None)",489],["let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"",343]],"useCount":116825},{"word":"emEnv","context":[["emEnv",126],["let emEnv = envPopTyvars emEnv",64],["let typB  = envGetTypB emEnv tref",32],["let emEnv = envPushTyvars emEnv tyargTs",32],["queryableTypeGetMethodBySearch cenv emEnv parentT mref",32],["let fieldB = envGetFieldB emEnv fref",32],["let emEnv = envPushTyvars emEnv tyargTs",32],["let methB = envGetMethB emEnv mref",32],["let emEnv = envPopTyvars emEnv",64],["let aty = convType cenv emEnv  (ILType.Array(shape,typ))",64]],"useCount":6146},{"word":"emit","context":[["emit ExpectedStackState.Value index",112],["emit ExpectedStackState.Value pe",112],["emit ExpectedStackState.Value e",112],["emit ExpectedStackState.Value cond",112],["emit ExpectedStackState.Empty body",112],["emit ExpectedStackState.Value arr",112],["emit ExpectedStackState.Value v",100],["emit ExpectedStackState.Value a2",92],["emit ExpectedStackState.Value a1",92],["emit s e",164]],"useCount":3202},{"word":"empty","context":[["Seq.empty",367],["let emptySeq = Seq.empty",95],["let eptMap = Map.empty",112],["// empty Map",133],["Dependencies = Set.empty",145],["Array.empty",149],["Map.empty",247],["// empty Seq",330],["// empty List",359],["// empty array",496]],"useCount":11541},{"word":"end","context":[["end",5357],["end;",484],["end",383],["end-code",339],["end-structure",238],["class end",95],["interface end",102],["end |||",120],["device-end",134],["end in",171]],"useCount":11106},{"word":"endif","context":[["endif",956],["#endif",20711],["#endif",1776],["endif ;",439],["endif ;;",125],["//#endif",83],["#endif // SILVERLIGHT",49],["[endif]",45],["#endif // NO_COMPILER_BACKEND",32],["\\c #endif",34]],"useCount":24525},{"word":"entity","context":[["/// Get the type parameters for an entity that is a type declaration, otherwise return the empty list.",68],["Guard.argNotNull (entity, \"entity\")",82],["Guard.argNotNull (entity, \"entity\")",82],["match entity.TypeReprInfo with",59],["/// Indicates if the entity is a provided namespace fragment",51],["let pk = pkLookup.[entity.Table.FullName]",57],["entity",82],["match entity with",93],["/// <param name=\"entity\">The entity.</param>",114],["/// <param name=\"entity\">The entity.</param>",114]],"useCount":5426},{"word":"entry","context":[["match (entry |> getNode \"properties\" |> optGetNode \"Id\") ++ (entry |> getNode \"title\") with",42],["/// <param name=\"key\">Key to entry.</param>",43],["/// <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>",44],["match (entry |> getNode \"properties\" |> optGetNode \"Id\") ++ (entry |> getNode \"title\") with",42],["// The type constructor is in the signature. Hence record the repackage entry",38],["//      1 entry for EOF",32],["// clause blocks. Only the entry to the clause is kept visible.",30],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234],["let entry =",70],["tracefn \"Removing 'Import' entry from %s for project %s\"",29]],"useCount":2345},{"word":"enum","context":[["Assert.AreEqual(enum.MoveNext(), false)",68],["enum (int32 TypeProviderTypeAttributes.IsErased)",66],["&&& ~~~(enum (int32 TypeProviderTypeAttributes.IsErased))",65],["enum.MoveNext,",82],["let enum = ie.GetEnumerator()",88],["Assert.AreEqual(enum.MoveNext(), true)",102],["CheckThrowsInvalidOperationExn(fun () -> enum.Current |> ignore)",128],["if v then attributes <- attributes ||| enum (int32 TypeProviderTypeAttributes.IsErased)",63],["if v then attributes <- attributes ||| enum (int32 TypeProviderTypeAttributes.SuppressRelocate)",63],["else attributes <- attributes &&& ~~~(enum (int32 TypeProviderTypeAttributes.IsErased))",63]],"useCount":3165},{"word":"env","context":[["let denv = env.DisplayEnv",158],["let env = env()",115],["env",663],["let ad = env.eAccessRights",590],["let env =",220],["return env",181],["CallEnvSink tcSink (scopem,env.NameEnv,env.eAccessRights)",162],["CallEnvSink tcSink (scopem,env.NameEnv,env.eAccessRights)",162],["UnifyTypes cenv env mStmt overallTy cenv.g.unit_ty",126],["let env = env()",115]],"useCount":49534},{"word":"envinner","context":[["let envinner = MakeInnerEnvForTyconRef cenv envinner tcref isExtrinsic",40],["vspecs, envinner)",90],["let envinner = AddDeclaredTypars CheckForDuplicateTypars (tycon.Typars(m)) envinner",76],["let envinner = AddDeclaredTypars CheckForDuplicateTypars (tycon.Typars(m)) envinner",76],["let envinner = AddDeclaredTypars CheckForDuplicateTypars declaredTypars env",56],["let envinner = MakeInnerEnvForTyconRef cenv envinner thisTyconRef false",56],["let envinner = MakeInnerEnvForTyconRef cenv envinner thisTyconRef false",56],["let ad = envinner.eAccessRights",54],["let innerExpr,tpenv = tcSequenceExprBody envinner genOuterTy tpenv innerComp",54],["let _,_,vspecs,envinner,_ = TcMatchPattern cenv (NewInferenceType()) env tpenv (pat,None)",54]],"useCount":2894},{"word":"environment","context":[["// These come through as an empty plid and residue \"\". Otherwise we try an environment lookup",24],["/// Binds the given processing ROP function to current environment and executes it.",24],["// type checking and intellisense-like environment-reporting.",74],["s\" ADDRESS-UNIT-BITS\" environment? 0= [IF] 8 [THEN]",54],["// type checking and intellisense-like environment-reporting.",46],["// Add active pattern result names to the environment",40],["errorR(Error((193,\"Inline IL not valid in a hosted environment\"),m))",38],["/// Add a set of union cases to the corresponding sub-table of the environment",30],["// If we have nonempty items from environment that were resolved from a type, then use them...",26],["// Use an environment lookup as the last resort",26]],"useCount":2748},{"word":"equal","context":[["|> equal true",118],["true |> should equal true",60],["query.SelectColumns |> should equal gameTypePropertySet",66],["|> should equal true",407],["actual |> should equal expected",387],["|> should equal false",121],["|> should equal Invalid",138],["|> should equal Valid",142],["|> should equal expected",311],["|> should equal \"\"\"",205]],"useCount":4861},{"word":"err","context":[["match err with",58],["| Choice2Of2 err ->",94],["error <- Some err",86],["match err.Exception with",59],["with err ->",54],["let n = GetErrorNumber err",40],["OutputPhasedError os err flattenErrors",38],["match GetRangeOfError err with",36],["override x.WarnSinkImpl(err) =",35],["| Parser.Error (num, tok, err) -> printErr (num, tok, err)",34]],"useCount":4379},{"word":"error","context":[["| _ -> error fi \"arrow type expected\")",60],["if nonNil otherDelayed then error(Error(FSComp.SR.tcInvalidAssignment(),mStmt))",64],["error (Error(FSComp.SR.nrGlobalUsedOnlyAsFirstName(), id.idRange))",68],["error <- Some err",86],["// This type is used to give symbolic names to token indexes, useful for error messages",88],["| Some error ->",91],["Choice2Of2 error",175],["match error with",135],["| Choice2Of2 error ->",111],["let mutable error = None",93]],"useCount":15536},{"word":"errorLogger","context":[["AbortOnError(errorLogger, tcConfig, exiter)",59],["AbortOnError(errorLogger,tcConfig,exiter)",57],["errorLogger.AbortOnError();",159],["let errorLogger =",110],["errorLogger.SetError()",42],["errorLogger.AbortOnError(fsiConsoleOutput);",47],["SetThreadErrorLoggerNoUnwind(errorLogger)",47],["use unwindEL = PushErrorLoggerPhaseUntilUnwind (fun _ -> errorLogger)",56],["SqmLoggerWithConfig tcConfig errorLogger.ErrorNumbers errorLogger.WarningNumbers",83],["SqmLoggerWithConfig tcConfig errorLogger.ErrorNumbers errorLogger.WarningNumbers",83]],"useCount":2290},{"word":"errorR","context":[["errorR(Error(FSComp.SR.tcInvalidRelationInJoin(nm.idText),relExpr.Range))",72],["errorR(Error(FSComp.SR.tcCannotInheritFromErasedType(),m))",54],["errorR(Error(FSComp.SR.tcOperatorIncorrectSyntax(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",54],["errorR(Error(FSComp.SR.parsInvalidLiteralInType(), m))",54],["with e -> (* errorR(Failure(\"parse failed\")); *) errorRecovery e rangeStartup; None",40],["errorR(Error(FSComp.SR.buildMultipleToplevelModules(),rangeOfLid lid))",40],["errorR(Error(FSComp.SR.tcBinaryOperatorRequiresBody(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",36],["errorR(Error((193,\"Inline IL not valid in a hosted environment\"),m))",38],["errorR(HashDirectiveNotAllowedInNonScript(m))",36],["| _ -> errorR(Failure(\"internal error: the ccu thunk for assembly \"+x.AssemblyName+\" not delayed!\"))",38]],"useCount":7228},{"word":"errors","context":[["let errors =",110],["// Eagerly grab all the errors and warnings from the mutable collection",40],["// Run InferTyconKind to raise errors on inconsistent attribute sets",100],["let mutable errors = 0",46],["for e in errors do",44],["errors <- errors + 1",43],["errors <- errors + 1",43],["// Reporting - warnings, errors",40],["let errors = delayed |> Seq.toList",40],["match errors with",40]],"useCount":4061},{"word":"es","context":[["match es with",89],["trans (Quotations.Expr.NewObject(Reflection.FSharpValue.PreComputeRecordConstructorInfo ci, es) )",55],["| TDSuccess (es,n) ->",60],["| Quotations.Patterns.NewUnionCase(ci, es) ->",56],["| Quotations.Patterns.NewRecord(ci, es) ->",56],["trans (Quotations.Expr.Call(Reflection.FSharpValue.PreComputeUnionConstructorInfo ci, es) )",55],["| SynExpr.DotIndexedGet (e1,es,_,_) ->",36],["| SynExpr.ArrayOrList (_,es,_)",36],["| SynExpr.DotIndexedSet (e1,es,e2,_,_,_) ->",34],["yield! walkExprs [ for e in es do yield! e.Exprs ]",30]],"useCount":2366},{"word":"etc","context":[["// Attributes, etc..",64],["// This check is required because constructors etc. are externally visible",28],["// (such as type declarations, nested modules etc.)",30],["/// of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other",30],["/// Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.",34],["/// Indicates the type prefers the \"tycon<a,b>\" syntax for display etc.",38],["// polymorphic code, after inlining etc. *",40],["// polymorphic code, after inlining etc.",40],["line, reading files, building and connecting lexers and parsers, etc.",47],["// etc.",56]],"useCount":2412},{"word":"event","context":[["// Instance IL event (fake up event-as-value)",60],["// Instance IL event (fake up event-as-value)",60],["/// <param name=\"sourceEvent\">The input event.</param>",56],["event",50],["if (Utils.IsNotNull event) then",34],["// Check if we're compiling the property as a .NET event",32],["(success, event)",31],["ptr display /* Display the event was read from */",31],["/// If so, caller can wait on event prior to calling again.",30],["match event with",71]],"useCount":2682},{"word":"ex","context":[["printfn \"%A\" ex",65],["member this.OnError( ex ) =",68],["| ex ->",684],["with ex ->",301],["fail ex",192],["| _ as ex ->",68],["| ex -> fail ex",89],["| ex -> ()",123],["printfn \"%s\" ex.Message",116],["| ex -> fail ex",89]],"useCount":3687},{"word":"example","context":[["/// The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.",34],["// For example",48],["Origin = ModuleResolver.SingleSourceFileOrigin.HttpLink \"http://example\"",50],["{ Owner = \"example\"",64],["///<example>Code example:",156],["///</example>",156],["///<example>Code example:",156],["///</example>",220],["///<example>Code example:",220],["///<example>Code example:",220]],"useCount":2523},{"word":"exception","context":[["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",66],["/// <exception cref=\"System.ArgumentException\">Thrown when the input arrays differ in length.</exception>",71],["/// <exception cref=\"System.ArgumentException\">Thrown when the input arrays differ in length.</exception>",71],["/// <exception cref=\"System.ArgumentException\">Thrown when the input sequence is empty.</exception>",73],["/// <exception cref=\"System.ArgumentException\">Thrown when the input sequence is empty.</exception>",73],["/// <param name=\"decider\">Used to determine a actor behavior response depending on exception occurred.</param>",82],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518]],"useCount":10645},{"word":"exe","context":[["{ ToolPath = (findToolFolderInSubPath \"paket.exe\" (currentDirectory @@ \".paket\")) @@ \"paket.exe\"",29],["//  - fsi.exe sometimes passes \"stdin\" as a dummy filename",40],["// The default location of FSharp.Core.dll and fsc.exe based on the version of fsc.exe that is running",31],["// The default location of FSharp.Core.dll and fsc.exe based on the version of fsc.exe that is running",31],["/// If true, indicates all type checking and code generation is in the context of fsi.exe",30],["do! exec (\".\"/\"test.exe\") \"\"",30],["/// Run the given buildscript with fsi.exe",30],["{ ToolPath = (findToolFolderInSubPath \"paket.exe\" (currentDirectory @@ \".paket\")) @@ \"paket.exe\"",29],["// Open the prefixPath for fsi.exe",27],["@\"..\\Fantomas\\lib\\Fantomas.exe\" ],",62]],"useCount":2208},{"word":"exists","context":[["exists",49],["|> Seq.filter (fun kv -> normalizedDependencies |> Seq.exists ((=) kv.Key))",72],["|> Seq.exists (fun r2 ->",67],["/// <param name=\"overwrite\">Enables overwriting of target file if it exists. Defaults to false.</param>",64],["|> List.exists (fun restriction ->",54],["/// Return <c>None</c> if no such element exists.</summary>",47],["if candidates |> List.exists (CalledMethHasSingleArgumentGroupOfThisLength argTys.Length) then",40],["// Only apply this rule if a candidate method exists with this number of arguments",40],["List.exists isInt32OrObjectIndexer (minfo :: others)) ->",40],["members |> List.exists (function",120]],"useCount":5074},{"word":"exit","context":[["exit 0",176],["0 // return an integer exit code",537],["exit 1",177],["exit",138],["matched exit",54],["/// Runs the given process and returns the exit code.",46],["tracefn \" - Please enter search text (:q for exit):\"",26],["exit 0)",23],["exit 0;",22],["/// This ErrorLogger reports all warnings, but raises StopProcessing on first error or early exit",21]],"useCount":1929},{"word":"exn","context":[["| exn ->",411],["else exn.Message)",35],["with exn -> failwithf \"Start of process %s failed. %s\" proc.StartInfo.FileName exn.Message",42],["with exn -> failwithf \"Start of process %s failed. %s\" proc.StartInfo.FileName exn.Message",42],["// M<'T> * (exn -> M<'T>) -> M<'T>",47],["| Error of exn",50],["raise exn",66],["match this :> exn with",75],["match exn with",144],["with exn ->",383]],"useCount":5111},{"word":"expected","context":[["let expected =",1155],["|> shouldEqual expected",478],["actual |> should equal expected",387],["|> shouldEqual (normalizeLineEndings expected)",317],["|> should equal expected",311],["actual |> shouldEqual expected",283],["let expected = \"\"\"",139],["|> shouldEqual (normalizeXml expected)",130],["Assert.AreEqual(expected, actual)",129],["|> assertEqual expected",102]],"useCount":7854},{"word":"expr","context":[["| None -> expr",130],["let rec loop expr = traverse loopCore expr",84],["let rec loop expr = traverse loopCore expr",84],["match expr with",2167],["let expr =",574],["expr",560],["let m = expr.Range",265],["|> pick expr",180],["expr,tpenv",178],["] |> pick expr",93]],"useCount":20108},{"word":"expression","context":[["// of which there can be many. Simply turn them all into one big AND expression as that is the",46],["match expression with",56],["* FSharp.Quotations.Compiler - a compiler for F# expression tree",56],["failwith (sprintf \"unknown expression '%A' in generated method\" n)",64],["/// emits given expression to corresponding IL",64],["/// Exceptions: InvalidArgumentException will be raised if the input expression is",67],["/// <param name=\"input\">The input expression to match against.</param>",315],["/// <returns>The resulting expression.</returns>",261],["/// not in the subset that can be converted to a LINQ expression tree",71],["/// <c>async { ... }</c> computation expression syntax.</remarks>",70]],"useCount":7093},{"word":"expressions","context":[["/// <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>",49],["// These occur in the F# quotation form of F# sequence expressions",24],["/// size after which we start enforcing splitting sub-expressions to new methods, to avoid hitting .NET IL limitations",24],["// it appears we're getting some typings recorded for non-atomic expressions like \"f x\"",26],["/// Computation expressions only",85],["// These are some constant expressions which can be accessed from context",85],["// the binding must have leaves that are themselves variables (due to the limited support for byrefs in expressions)",54],["// next up is the filter expressions",41],["/// Indicates if the type inference variable was generated after an error when type checking expressions or patterns",34],["/// This is used to typecheck legitimate 'non-main body of object constructor' expressions",40]],"useCount":2413},{"word":"extension","context":[["/// For an extension method this includes all type parameters, even if it is extending a generic type.",34],["#if EXTENDED_EXTENSION_MEMBERS // indicates if extension members can add additional constraints to type parameters",36],["( The config module contains the extension and missing words for a forth system.)",54],["/// value will appear in compiled code. For extension members this is the module where the extension member",32],["/// value will appear in compiled code. For extension members this is the module where the extension member",32],["/// value is associated. For extension members this is the nominal type the member extends.",32],["#extension GL_ARB_texture_rectangle : enable",36],["// This extension member adds to the FuncConvert type and is the last resort member in the method overloading rules.",38],["( Float extension words )",46],["// per spec, extension members in F1 keywords are qualified with definition class",51]],"useCount":2836},{"word":"f","context":[["let f = OptimizedClosures.FSharpFunc<_,_,_>.Adapt(f)",305],["f()",333],["match f with",311],["| [<AltCommandLine(\"-f\")>] Force",141],["f",143],["let f(xs : int[]) =",146],["let f =",156],["let f x =",183],["| Some f ->",193],["let f = OptimizedClosures.FSharpFunc<_,_,_>.Adapt(f)",305]],"useCount":40228},{"word":"fail","context":[["| ex -> fail ex",89],["fail()",64],["DownloadError url |> fail",48],["| _ -> fail ()",45],["fail",28],["fail ex",192],["| x -> fail x",192],["fail ()",339],["| _ -> fail()",421],["|> Either.fail",118]],"useCount":2663},{"word":"failwith","context":[["| _ -> failwith \"impossible\" in",131],["failwith \"unreachble\"",80],["failwith \"Not implemented yet\"",89],["| _          -> failwith \"unreachable\"",100],["| _ -> failwith \"\"",119],["| _ -> failwith \"impossible\"",140],["| _ -> failwith \"rebalance\"",162],["| _ -> failwith \"Impossible\"",164],["failwith msg",461],["| _ -> failwith \"unreachable\"",481]],"useCount":13836},{"word":"failwithf","context":[["| _ -> failwithf \"unknown constant '%A' in generated method\" v",64],["with exn -> failwithf \"%s - in %s\" exn.Message referencesFile.FileName)",32],["failwithf \"Could not retrieve data from %s%s Message: %s%s\" url Environment.NewLine exn.Message (innerText exn)",32],["| x -> failwithf \"Unknown .NET moniker %O\" x",34],["with exn -> failwithf \"Start of process %s failed. %s\" proc.StartInfo.FileName exn.Message",42],["if i >= len then failwithf \"%s\" <| FSComp.SR.forBadPrecision();",42],["if i >= len then failwithf \"%s\" <| FSComp.SR.forBadPrecision()",42],["| _ -> failwithf \"invalid %s specification:%s     %s\" originTxt Environment.NewLine trimmed",42],["| _ -> failwithf \"could not parse version range \\\"%s\\\"\" text",43],["| None -> failwithf \"unable to parse %s\" node.Name",47]],"useCount":2579},{"word":"false","context":[["| _ -> false)",909],["| _ -> false",6597],["false",4104],["| None -> false",1531],["[<assembly: ComVisible(false)>]",1179],["// Setting ComVisible to false makes the types in this assembly not visible",997],["| false, _ ->",553],["[<AutoSerializable(false)>]",394],["else false",511],["| false ->",400]],"useCount":67080},{"word":"fi","context":[["| TmApp (fi, _, _) -> fi",50],["| TmApp (fi, _, _) -> fi",50],["| TmVar (fi, x, n) ->",52],["error fi",56],["| _ -> error fi \"arrow type expected\")",60],["| TmIf (fi, t1, t2, t3) ->",62],["| TmRecord (fi, fields) ->",77],["| TmApp (fi, t1, t2) ->",81],["| TmAbs (fi, x, tyT1, t2) ->",82],["let fi = FileInfo(fileName)",100]],"useCount":8302},{"word":"field","context":[["ilg.Emit(OpCodes.Ldsfld, field)",58],["if field.IsStatic then",116],["match field with",95],["let field = match field with :? ProvidedField as pf when fieldMap.ContainsKey pf -> fieldMap.[pf] :> FieldInfo | m -> m",80],["/// Represents an erased provided field.",66],["/// Create a new provided field. It is not initially associated with any specific provided type definition.",66],["/// Add XML documentation information to this provided field",66],["failwith \"unknown parameter/field\"",63],["// Add an I_nop if this is an initonly field to make sure we never recognize it as an lvalue. See mkExprAddrOfExpr.",60],["let field = match field with :? ProvidedField as pf when fieldMap.ContainsKey pf -> fieldMap.[pf] :> FieldInfo | m -> m",80]],"useCount":7352},{"word":"fields","context":[["fields",149],["let fields =",109],["/// static fields, 'val' declarations and hidden fields from the compilation of implicit class constructions.",102],["/// static fields, 'val' declarations and hidden fields from the compilation of implicit class constructions.",102],["// Allow at most one constructor, and use its arguments as the fields of the type",64],["for (v, f) in fields do",102],["// Always allow subsumption on assignment to fields",100],["| TmRecord (fi, fields) ->",77],["let kind = InferTyconKind cenv.g (kind,attrs,slotsigs,fields,inSig,isConcrete,m)",72],["// phase 1 - set assembly fields and emit type definitions",64]],"useCount":6299},{"word":"file","context":[["This file is part of OpenSpades.",87],["// This file is part of WebSharper",342],["// This file is subject to the terms and conditions defined in",233],["// This file was autogenerated by running the script in this directory",170],["let file = \"/home/user/Test.fsx\"",153],["/*  This file is part of Visualization Library                                        */",98],["file",96],["\\ See the file \"COPYING\" for further information about",89],["/// <param name=\"path\">Path to input file.</param>",85],["\\ This file is part of Gforth.",664]],"useCount":19209},{"word":"file1","context":[["///     [\"file1.fs\"; \"file2.fs\"]",30],["(\"C\", \"M.C\", \"file1\", ((9, 15), (9, 16)), [\"class\"]);",72],["let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"",343],["(\"Impl\", \"Impl\", \"file1\", ((2, 7), (2, 11)), [\"defn\"], [\"module\"])|]",44],["(\"C\", \"file1\", ((9, 15), (9, 16)), [\"class\"]);",44],["|> Array.map (fun (a,b) -> (if a = Project4.fileName1 then \"file1\" else \"??\"), b)",33],["(\"FSharp.Data.XmlProvider\", \"file1\", ((4, 15), (4, 26)),",33],["(\"int\", \"int\", \"file1\", ((5, 9), (5, 12)), [\"type\"]);",33],["TemplateFile.Parse(\"file1.template\", None, strToStream text)",31],["TemplateFile.Parse(\"file1.template\", LockFile.Parse(\"\",[||]), None, Map.empty, strToStream text)",30]],"useCount":9270},{"word":"file2","context":[["(\"( + )\", \"Microsoft.FSharp.Core.Operators.( + )\", \"file2\",",77],["\"file2\", ((18, 6), (18, 18)), [\"class\"]);",44],["///     [\"file1.fs\"; \"file2.fs\"]",30],["(\"DefaultValueAttribute\", \"Microsoft.FSharp.Core.DefaultValueAttribute\",\"file2\", ((18, 6), (18, 18)), [\"class\"]);",28],["(\"val mmmm2\", \"file2\", (40, 4), (40, 9), [\"val\"]);",22],["(\"field value__\", \"file2\", (28, 2), (29, 25), [\"field\"; \"compgen\"]);",22],["(\"val c1\", \"file2\", (35, 4), (35, 6), [\"val\"]);",22],["(\"val c2\", \"file2\", (37, 4), (37, 6), [\"val\"]);",22],["(\"member get_SomeProperty\", \"file2\", (22, 13), (22, 25),",22],["(\"D2\", \"file2\", (9, 5), (9, 7), [\"class\"]);",22]],"useCount":2441},{"word":"fileName","context":[["let fileName =",112],["let buffer = createMockTextBuffer content fileName",265],["helper.SetUpProjectAndCurrentDocument(createVirtualProject(buffer, fileName), fileName, content)",59],["let fi = FileInfo(fileName)",100],["if File.Exists fileName then",99],["| Some fileName ->",69],["let assemblyBytes = System.IO.File.ReadAllBytes fileName",61],["static member RegisterGenerated (fileName:string) =",61],["helper.SetUpProjectAndCurrentDocument(createVirtualProject(buffer, fileName), fileName, content)",59],["//printfn \"registered assembly in '%s'\" fileName",59]],"useCount":5503},{"word":"fileName1","context":[["checker.GetBackgroundCheckResultsForFileInProject(Project25.fileName1, Project25.options)",33],["let fileNames = [fileName1]",456],["File.WriteAllText(fileName1, fileSource1)",495],["let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"",343],["(fileName1 = fileName2)",65],["|> Array.map (fun (a,b) -> (if a = Project4.fileName1 then \"file1\" else \"??\"), b)",33],["let fileNames = [fileName1; fileName2]",24],["checker.CheckFileInProject(parseResults1, Project1.fileName1, 0, Project1.fileSource1, Project1.options)",22],["checker.GetBackgroundCheckResultsForFileInProject(Project5.fileName1, Project5.options)",22],["let fileName1 = Path.ChangeExtension(Path.GetTempFileName(), \".fs\")",503]],"useCount":2210},{"word":"filename","context":[["filename",39],["let lower = String.lowercase filename",88],["let slotOfFile = ib.GetSlotOfFileName filename",48],["let filename =",44],["/// <param name=\"filename\">The filename for the file.</param>",40],["//  - fsi.exe sometimes passes \"stdin\" as a dummy filename",40],["| _ -> QualFileNameOfFilename (rangeN filename 1) filename",40],["| _ -> QualFileNameOfFilename (rangeN filename 1) filename",40],["/// <param name=\"filename\">The filename for the file.</param>",40],["tcConfig.CheckFSharpBinary(filename,dllinfo.ILAssemblyRefs,m)",40]],"useCount":5000},{"word":"files","context":[["| No_Install -> \"Skips paket install --hard process afterward generation of dependencies / references files.\"",42],["files",254],["let files =",136],["///  - `projects` - A list of project or solution files.",72],["/// Restores the given paket.references files.",54],["for file in files do",49],["| CreateNewBindingFiles -> \"Creates binding redirect files if needed.\"",48],["line, reading files, building and connecting lexers and parsers, etc.",47],["let files = files |> Array.map (fun fi -> fi.FullName)",45],["let files = files |> Array.map (fun fi -> fi.FullName)",45]],"useCount":4744},{"word":"filter","context":[["|> Array.filter(fun m ->",63],["getMembers() |> Array.filter(fun m->0<>(int(m.MemberType &&& mt)) && m.Name = name)",63],["|> Array.filter (fun m -> m.MemberType.HasFlag(MemberTypes.Method))",64],["|> List.filter (EntityRefContainsSomethingAccessible ncenv m ad)",64],["|> Seq.filter (fun kv -> normalizedDependencies |> Seq.exists ((=) kv.Key))",72],["/// Used to hide/filter members from super classes based on signature",72],["|> List.filter (fun x ->",73],["|> List.filter (fun node ->",116],["|> List.filter (IsTyconUnseen ad g ncenv.amap m >> not)",120],["|> Array.filter(fun m -> m.MemberType.HasFlag(MemberTypes.Event) && (name = null || m.Name = name))",63]],"useCount":8302},{"word":"finally","context":[["// Build iteration as a while loop with a try/finally disposal",20],["/// F# syntax: try expr finally expr",20],["/// An operation representing a lambda-encoded try/finally",20],["finally gc.Free()",20],["/// Match a try-finally expression",19],["wordL \"try\" ^^ exprL x1 ^^ wordL \"finally\" ^^ exprL x2 ^^ rightL \"}\"",19],["// set the PC past the try/finally before trying to run it, to make sure we only run it once",18],["finally",1949],["finally compensation()",40],["finally tcConfigB.implicitIncludeDir <- old",21]],"useCount":2400},{"word":"find","context":[["let gdtym = gdty.GetMethods() |> Seq.find (fun x -> x.Name = meth.Name)",58],["let p = cfg.Groups.[Constants.MainDependencyGroup].Packages |> List.find (fun x-> x.Name = PackageName \"Foobar\")",52],["// Try to find an AssemblyVersion attribute",48],["let zippedNuspec = zip.Entries |> Seq.find (fun f -> f.FullName.EndsWith \".nuspec\")",42],["\" /\" find-device",40],["\" /chosen\" find-device",33],["/// Try to find an attribute that takes a string argument",31],["|> Option.toChoiceWithError \"find\"",30],["let kvp = HashMap.find key cache",28],["// v, dereferencing it to find the corresponding signature Val, and adding an entry for the signature val.",28]],"useCount":3229},{"word":"first","context":[["source \"http://www.nuget.org/api/v2\" // first source",97],["/// <param name=\"x\">The first parameter.</param>",150],["/// <param name=\"start1\">The start index of the first dimension.</param>",68],["/// <param name=\"arg1\">The first arg.</param>",72],["/// <param name=\"list1\">The first input list.</param>",77],["/// <param name=\"source1\">The first input sequence.</param>",78],["// the first key. For each bucket, call 'nodef' on that head key and the bucket.",79],["/// Rescoping. The first argument tells the function how to reference the original scope from",85],["/// <param name=\"array1\">The first input array.</param>",87],["/// <param name=\"e1\">The first value.</param>",165]],"useCount":7206},{"word":"flags","context":[["(flags,nameIdx,typIdx)",44],["let flags =",247],["// Filter out the additional TypeProviderTypeAttributes flags",123],["/// <param name=\"bindingFlags\">Optional binding flags.</param>",102],["let flags = seekReadUInt16AsInt32Adv ctxt &addr",77],["let flags = seekReadInt32Adv ctxt &addr",66],["ValFlags(flags)",60],["flags(i+1)",56],["let flags = readUInt16AsInt32 ctxt.is",49],["[| UShort (uint16 flags)",48]],"useCount":5797},{"word":"float","context":[["float linear;",57],["precision mediump float;",383],["precision highp float;",231],["uniform float time;",141],["abstract length: float with get, set",111],["type MyRecord = {Field1: int; Field2: float}",66],["abstract y: float with get, set",62],["abstract x: float with get, set",62],["| :? float as x -> ilg.Emit(OpCodes.Ldc_R8, x)",61],["float constant;",57]],"useCount":6826},{"word":"fold","context":[["List.fold (fun s d ->",40],["((List.fold (fun s (x, _) -> s + (\" \" + x)) \"\"",40],["// REVIEW: fold this into ILMethodDef",47],["|> List.fold",49],["|> Seq.fold handleElement data",50],["(\"\",ns) ||> List.fold (fun fullName n ->",58],["let fold () : unit =",58],["((None,\"\"),ns) ||> List.fold (fun (otb:TypeBuilder option,fullName) n ->",58],["List.fold visitNode buf nodeList",73],["List.fold",111]],"useCount":4376},{"word":"foldBack","context":[["List.foldBack",229],["let expr = Array.foldBack (fun (arg, var) e -> Quotations.Expr.Let(var, arg, e)) pairs expr",51],["let foldBack () : unit =",37],["let mkIteratedFunTy dl r = List.foldBack (-->) dl r",34],["List.foldBack cons s (returnM [])",34],["List.foldBack (Map.add id) matches results",34],["let env = Option.foldBack (BindInternalValToUnknown cenv) baseValOpt env",24],["Map.foldBack",22],["let expr = List.foldBack (fun spats e -> SynExpr.Lambda (isMember,true,spats, e,wholem)) t rhs",22],["(csl,acc) ||> List.foldBack (fun (TCase(discrim,dtree)) acc ->",22]],"useCount":3242},{"word":"folder","context":[["/// Extracts the given package to the ./packages folder",57],["ignore(IO.Path.GetFullPath folder)",60],["// use GetFullPath to ensure that folder is valid",60],["probingFolders.Add folder",60],["/// <param name=\"folder\">The function to update the state given the input elements.</param>",90],["/// <param name=\"folder\"></param>",91],["let folder = FSharpFunc<_,_,_>.Adapt folder",100],["let folder = FSharpFunc<_,_,_>.Adapt folder",100],["let folder = FSharpFunc<_,_,_,_>.Adapt folder",148],["let folder = FSharpFunc<_,_,_,_>.Adapt folder",148]],"useCount":2560},{"word":"following","context":[["// Version information for an assembly consists of the following four values:",1046],["// Split the following line:",34],["// furnished to do so, subject to the following conditions:",39],["// the packaging of this file.  Please review the following information to",57],["// The following arise during reprocessing of the inserted tokens when we hit a DONE",57],["// the packaging of this file.  Please review the following information to",62],["// distribution, and is available at the following URL:",76],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["// General Information about an assembly is controlled through the following",1065],["// The following attributes are used to specify the signing key for the assembly,",26]],"useCount":4344},{"word":"for","context":[["// Version information for an assembly consists of the following four values:",1046],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["/// <param name=\"Color\">The color for the data.</param>",753],["for i = 0 to len - 1 do",403],["/// <param name=\"data\">The data for the chart.</param>",403],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234],["/// <param name=\"data\">The data for the chart. Each observation replaces the entire data on the chart.</param>",224],["for cust in dc.Main.Customers do",217],["// See the 'F# Tutorial' project for more help.",208],["for i = 0 to len1 - 1 do",182]],"useCount":74807},{"word":"forall","context":[["if modrefs.Length > 0 && modrefs |> List.forall (fun modref -> modref.IsNamespace) then",40],["when (namedCurriedCallerArgs |> List.forall isNil &&",36],["if String.forall (fun c -> System.Char.IsDigit c || c = '-')  s",28],["List.forall",28],["let definiteNamespace = modrefs |> List.forall (fun modref -> modref.IsNamespace)",28],["| _ when List.forall isInternalCompPath p  -> Internal",27],["if lengths |> Array.forall (fun dimLen -> dimLen > 0) then",24],["let forall () : unit =",22],["|> Seq.forall (fun l -> l.Count <= value.Count)",22],["if String.forall (fun c -> System.Char.IsDigit(c) || c = '-')  s",69]],"useCount":2399},{"word":"force","context":[["// This is a value we can access from the outside to definitely force initialziation of the module",85],["let force = results.Contains <@ RemoveArgs.Force @>",26],["let force = results.Contains <@ ConvertFromNugetArgs.Force @>",26],["let force = results.Contains <@ AddArgs.Force @>",27],["let loadedTimeStamp = defaultArg loadedTimeStamp DateTime.MaxValue // Not 'now', we don't want to force reloading",31],["let! result = NuGetV3.GetPackageDetails force nugetSource packageName version",32],["|> Lazy.force",44],["if not force && targetFile.Exists && targetFile.Length > 0L then",57],["if not force && targetFile.Exists then",66],["force",81]],"useCount":2125},{"word":"form","context":[["// construct arising out the compilation of pattern matching. We decode these back to the form",44],["// Bound type vars form a recursively-referential set due to constraints, e.g.  A : I<B>, B : I<A>",38],["// as a type constructor, or if the form type A = A is used.",40],["/// A utility function to convert function values from tupled to curried form",38],["//    printfn \"external form: %A\" externalForm",53],["//    printfn \"internal form: %A\" internalForm",53],["//    printfn \"converted form: %A\" convertedForm",54],["// Verify function input form and human form match.",55],["// Verify function input form and human form match.",55],["// therefore, we can perform inlining to translate this to a form that can be compiled",59]],"useCount":2312},{"word":"format","context":[["/// Called by the evaluation session to ask the host for parameters to format text for output",60],["// The assembly version has the format {Major}.{Minor}.{Build}.{Revision}",300],["static member format =",124],["/// Called by the evaluation session to ask the host for parameters to format text for output",110],["/// <param name=\"format\">The input formatter.</param>",65],["[<Obsolete (\"Use format instead.\")>]",62],["/// <param name=\"format\">The formatter.</param>",48],["(* Convert the linear code format to the nested code format *)",36],["(* Convert the linear code format to the nested code format *)",36],["///    information about the schema format.",30]],"useCount":1934},{"word":"found","context":[["match found with",111],["let mutable found = false",92],["found <- true",60],["/// * recurseOnMatch - If a match is found continues down the tree matching child elements",60],["assert (gdtym <> null) // ?? will never happen - if method is not found - KeyNotFoundException will be raised",56],["found",55],["if found then",49],["/// <returns>The found entity.</returns>",36],["// not found",34],["let message = \"No matching member could be found.\"",32]],"useCount":3056},{"word":"framework","context":[["\"/Library/Frameworks/Mono.framework/Versions/Current\"",24],["#r \"../../packages/NUnit/lib/nunit.framework.dll\"",184],["#r \"../../packages/NUnit.2.6.3/lib/nunit.framework.dll\"",71],["let framework =",40],["#r \"../../packages/NUnit/lib/net45/nunit.framework.dll\"",30],["nuget \"Rx-Main\" \"~> 2.0\" framework: >= net40 \"\"\"",24],["Rx-Main (2.0) - framework: >= net40",24],["// framework to .NET 4.0 or .NET 4.5.",24],["/// Returns all libraries for the given package and framework.",24],["match framework with",24]],"useCount":1828},{"word":"free","context":[["let free = Zset.diff freeInDeclaringType.FreeTypars  freeInArgsAndRetType.FreeTypars",30],["free throw",153],["// In other words, the free type variables get divided into two sets",32],["//    {LAM <tyfunc-typars>. expr }[free-typars] : overall-type[contract-typars]",32],["//    internal-typars = free-typars - contract-typars",32],["free.IsEmpty)",34],["free",36],["// non-local values do not contain free variables",38],["// So collect up free vars in all constraints first, then bind all variables",38],["// promote free vars to fields",51]],"useCount":1939},{"word":"from","context":[["/// static fields, 'val' declarations and hidden fields from the compilation of implicit class constructions.",102],["// This is a value we will access from the outside.",85],["/// A flag read eagerly from the provided type and used to compute basic properties of the type definition.",85],["// This is a value we can access from the outside to definitely force initialziation of the module",85],["// These are some constant expressions which can be accessed from context",85],["/// Rescoping. The first argument tells the function how to reference the original scope from",85],["select * from Employee order by EmployeeId",120],["[<CompilerMessage(\"This method is not intended for use from F#.\", 10001, IsHidden=true, IsError=false)>]",132],["//[category: Creating generators from generators]",279],["// to COM components.  If you need to access a type in this assembly from",997]],"useCount":16683},{"word":"fs","context":[["let fileName1 = Path.ChangeExtension(Path.GetTempFileName(), \".fs\")",503],["include ffl/stc.fs",106],["// FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs",105],["#load \"../Common/FsUnit.fs\"",103],["#load \"FsUnit.fs\"",89],["#load \"Common.fs\"",81],["Name = \"src/app/FAKE/Cli.fs\"",77],["/// FSharp.Data addition: this method is used by Debug.fs",73],["include ffl/tst.fs",71],["include ffl/config.fs",239]],"useCount":7541},{"word":"fsi","context":[["let fsi = FsiSession.Value",138],["let fsi = Printf.ksprintf (Commands.fsi exec cfg.FSI)",28],["let fsi = Printf.ksprintf (Commands.fsi exec cfg.FSI)",28],["/// Run the given buildscript with fsi.exe",30],["/// If true, indicates all type checking and code generation is in the context of fsi.exe",30],["match (if exists \"fsc\" && exists \"fsi\" then tryFsharpiScript (file \"fsi\") else None) with",34],["match (if exists \"fsc\" && exists \"fsi\" then tryFsharpiScript (file \"fsi\") else None) with",34],["//  - fsi.exe sometimes passes \"stdin\" as a dummy filename",40],["fsi.EvalInteraction \"\"\"",42],["// Open the prefixPath for fsi.exe",27]],"useCount":2053},{"word":"fspec","context":[["let mkTest (fspec:RecdField) =",32],["let fspec = mkILFieldSpec(fref,mkILNamedTy valu fref.EnclosingTypeRef [])",80],["| StaticField (fspec, _, hasLiteralAttr, ilContainerTy, _, _, ilGetterMethRef, _, _) ->",48],["goutput_fspec env os fspec",42],["// The empty instantiation on the AbstractIL fspec is OK, since we make the correct fspec in IlxGen.GenAsm",42],["// The empty instantiation on the AbstractIL fspec is OK, since we make the correct fspec in IlxGen.GenAsm",42],["let ilPropName = fspec.Name",42],["let fty = fspec.FormalType",40],["let fspec =",38],["let typR = ConvILTypeRefApp cenv m fspec.EnclosingTypeRef enclTypeArgs",32]],"useCount":3660},{"word":"fst","context":[["assert_equal false (fst result)",110],["|> Seq.groupBy fst",113],["|> List.sortBy fst",101],["assert_equal true (fst result)",113],["|> Seq.map fst",117],["|> List.map fst",163],["|> fst",174],["|> Seq.sortBy fst",500],["|> List.groupBy fst",52],["|> Option.map fst",72]],"useCount":4536},{"word":"fullName","context":[["let fullName =",96],["let priorType = if typeMapExtra.ContainsKey(fullName) then Some typeMapExtra.[fullName]  else None",58],["f typeMapExtra.[fullName] None",59],["typeMapExtra.[fullName] <- tb",59],["(Some tb, fullName))",59],["failwith (sprintf \"ProvidedTypeDefinition: static parameters supplied but not expected for %s\" (fullName.Force()))",60],["fullName)",65],["let fullName = if fullName = \"\" then n else fullName + \".\" + n",116],["let fullName = if fullName = \"\" then n else fullName + \".\" + n",116],["let fullName = if fullName = \"\" then n else fullName + \".\" + n",116]],"useCount":2128},{"word":"fun","context":[["(fun res -> ErrorD (ErrorFromAddingConstraint(denv,res,m)))",174],["(fun (parseState : Internal.Utilities.Text.Parsing.IParseState) ->",1046],["(fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->",2648],["fun () ->",331],["fun state ->",239],["fun (range:_1D) (buf:array<int>) ->",216],["repeat(fun () ->",197],["|> Seq.map (fun kv ->",196],["Eventive (fun p ->",183],["(fun () ->",785]],"useCount":79063},{"word":"func","context":[["/// <param name=\"func\">The function.</param>",54],["let res = func stream substr",42],["func",203],["internal_err func",116],["/// <param name=\"func\">The input function.</param>",90],["if Utils.IsNull func then",60],["if not (Utils.IsNull func ) then",60],["x.ExportInternal( name, func, true )",60],["let func _ = ()",54],["/// <param name=\"func\">The input tupled function.</param>",36]],"useCount":2221},{"word":"function","context":[["/// <param name=\"folder\">The function to update the state given the input elements.</param>",90],["|> List.map (function",119],["members |> List.exists (function",120],["/// <returns>The function result.</returns>",126],["/// <param name=\"predicate\">The function to test the input elements.</param>",207],["(function",256],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["|> function",792],["function",1560]],"useCount":22514},{"word":"functions","context":[["/// this allows the use of mapping functions requiring a (possibly mutable) state variable.",40],["(* The printing functions call these utility functions to insert grouping",54],["// Helper functions",31],["//     bake our own function base contracts for local type functions",32],["// Eliminate subsumption coercions for functions. This must be done post-typechecking because we need",34],["// Code for potential future design change to allow functions-compiled-as-members in structs",36],["(* the xmlDocSigOf* functions encode type into string to be used in \"id\" *)",38],["(* The printing functions call these utility functions to insert grouping",54],["/// Syntax trees and associated support functions.",54],["/// Core typechecking and evaluation functions.",54]],"useCount":2162},{"word":"fvs","context":[["if isEmptyFreeTyvars fvs then eUngeneralizableItems",40],["else fvs",57],["if not opts.includeLocals then fvs else",38],["| _ -> fvs",38],["let fvs = accFreevarsInVal opts v fvs",38],["let fvs = accFreevarsInVal opts v fvs",38],["if fvs.FreeTypars.IsEmpty then",20],["fvs",47],["uvs=mk_uvs(); fvs=mk_fvs();",97],["let fvs = freeInType CollectAllNoCaching typ",20]],"useCount":2745},{"word":"g","context":[["let g = csenv.g",286],["let g = infoReader.g",389],["let g = infoReader.g",389],["\\g @see anscore",355],["let g = csenv.g",286],["let g = ncenv.g",200],["| FSMeth(g,typ,vref,_) ->",152],["let tcref,tinst = destAppTy g ty",171],["if isTyparTy g ty then",192],["let g = ncenv.g",200]],"useCount":102396},{"word":"generate","context":[["let generate =",39],["// The entire data segment is filtered out, don't generate a call in this case.",39],["// to C<_> occurs then generate C<?ty> for a fresh type inference variable ?ty.",40],["/// <param name=\"chooser\">The function to generate options from the elements.</param>",39],["/// including static fields, but excluding compiler-generate fields.",34],["/// excluding compiler-generate fields.",34],["// generate proper increasing sequence",27],["// Try to use the type of the expression on the left to help generate a completion list",26],["let ``should generate Xml for System.Net.Http 2.2.8``() =",43],["generate,dispose,checkDispose);",56]],"useCount":2957},{"word":"generated","context":[["// convert TupleGet to the chain of PropertyGet calls (only for generated types)",61],["/// any type relocations or static linking for generated types.",38],["failwith (sprintf \"unknown expression '%A' in generated method\" n)",64],["/// This is the value implementing the auto-generated comparison",40],["// Implementation file for parser generated by fsyacc",41],["//     This code was generated by a tool.",41],["/// <return> generated dataset </return>",44],["// Signature file for parser generated by fsyacc",53],["// convert NewTuple to the call to the constructor of the Tuple type (only for generated types)",60],["| _ -> failwithf \"unknown constant '%A' in generated method\" v",64]],"useCount":4122},{"word":"generic","context":[["/// The type of the field, w.r.t. the generic parameters of the enclosing type constructor",32],["// Handle the generic cases",64],["// Handle the case where this is a generic method instantiated at a type being compiled",51],["let generic,cc = byteAsCallConv ccByte",44],["// case of generics all the generic type arguments are also recursively",38],["// For non-generic type providers there is no difference",34],["/// For an extension method this includes all type parameters, even if it is extending a generic type.",34],["(\"generic parameter T\",",33],["my-space pci-device-generic-setup",33],["/// Get the type of the value including any generic type parameters",32]],"useCount":3510},{"word":"get","context":[["with get () = Option.get _type",70],["member Item1 : 'T1 with get",72],["abstract name: string with get, set",76],["abstract ``type``: string with get, set",78],["// This ensures we always get the type instantiation right when doing this from",80],["abstract length: float with get, set",111],["with get()  = isStatic",123],["|> Option.get",129],["with get() =",3875],["with get () =",253]],"useCount":21054},{"word":"getErrorString","context":[["| Parser.TOKEN_INFIX_COMPARE_OP -> getErrorString(\"Parser.TOKEN.INFIX.COMPARE.OP\")",20],["| Parser.TOKEN_BEGIN  -> getErrorString(\"Parser.TOKEN.BEGIN\")",20],["| Parser.TOKEN_EQUALS -> getErrorString(\"Parser.TOKEN.EQUALS\")",20],["| Parser.TOKEN_DO -> getErrorString(\"Parser.TOKEN.DO\")",20],["| Parser.TOKEN_WHILE   -> getErrorString(\"Parser.TOKEN.WHILE\")",20],["| Parser.TOKEN_STRUCT  -> getErrorString(\"Parser.TOKEN.STRUCT\")",20],["| Parser.TOKEN_STRING -> getErrorString(\"Parser.TOKEN.STRING\")",20],["| Parser.TOKEN_MINUS -> getErrorString(\"Parser.TOKEN.MINUS\")",20],["| Parser.TOKEN_SIG -> getErrorString(\"Parser.TOKEN.SIG\")",20],["| Parser.TOKEN_INHERIT -> getErrorString(\"Parser.TOKEN.INHERIT\")",20]],"useCount":3056},{"word":"given","context":[["/// Adds the given package with the given version to the dependencies file.",84],["/// Restores the given paket.references files.",54],["/// Extracts the given package to the ./packages folder",57],["| Some _ -> failwith (sprintf \"ProvidedConstructor: base call already given for '%s'\" (nameText()))",58],["| Some _ -> failwith (sprintf \"ProvidedConstructor: code already given for '%s'\" (nameText()))",60],["/// emits given expression to corresponding IL",64],["/// Returns a new map made from the given bindings.",72],["/// <summary>Builds a new collection whose elements are the results of applying the given function",78],["/// Adds the given package with the given version to the dependencies file.",84],["/// <param name=\"folder\">The function to update the state given the input elements.</param>",90]],"useCount":9730},{"word":"group","context":[["group.Packages",74],["let group =",46],["// A single group of tupled arguments",51],["| [<CustomCommandLine(\"group\")>] Group of string",55],["group.Resolution",58],["group Group",68],["match group with",91],["group Test",127],["group Build",230],["| Some group ->",309]],"useCount":3617},{"word":"groupName","context":[["match dependenciesFile.Groups |> Map.tryFind groupName with",67],["match groups |> Map.tryFind groupName with",132],["let groupName =",107],["match groupName with",105],["match lockFile.Groups |> Map.tryFind groupName with",99],["| Some groupName ->",76],["match referencesFile.Groups |> Map.tryFind groupName with",40],["let groupName,packageName = kv.Key",36],["let group = groups.[groupName]",34],["match this.Groups |> Map.tryFind groupName with",32]],"useCount":2844},{"word":"h","context":[["h",53],["// nice: don't introduce awful temporary for r.h.s. in the 99% case where we know what we're binding it to",60],["compactify (Some (h::prev::moreprev)) t",70],["///     let h = Library.hello 1",75],["///     printfn \"%d\" h",80],["| [h] -> h",81],["| [h] -> h",81],["match h with",100],["| h :: t ->",107],["| h::t ->",378]],"useCount":7259},{"word":"handler","context":[["AppDomain.CurrentDomain.remove_AssemblyResolve handler",32],["// Initialize the error handler",40],["handler ()",44],["let commandResult = handler.Handle(command)",44],["let handler =",54],["let handler = ResolveEventHandler(fun _ args -> this.ResolveAssembly(args))",59],["do AppDomain.CurrentDomain.add_AssemblyResolve handler",61],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",284]],"useCount":2546},{"word":"has","context":[["// This sets a value in another module to indicate that initialization has happened",85],["// to the NUnit console/log so we'll know this function has been executed.",40],["[ has? os [IF] ]",38],["has? file [IF]",40],["#nowarn \"52\" // The value has been copied to ensure the original is not mutated by this operation",41],["// and the modifiations hang around even after the process has exited.",42],["[ has? file [IF] ]",42],["/// - A private key blob which has been encrypted and contains information to initialize RSA",42],["/// Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control",84],["// The assembly version has the format {Major}.{Minor}.{Build}.{Revision}",300]],"useCount":6013},{"word":"hash","context":[["| SymbolKind.Generic gty,_ -> 9797 + hash gty + List.sumBy hash args",51],["hash",60],["| SymbolKind.ByRef,[arg] -> 43904 + hash arg",51],["| SymbolKind.Generic gty,_ -> 9797 + hash gty + List.sumBy hash args",51],["| SymbolKind.Pointer,[arg] -> 283 + hash arg",51],["| SymbolKind.Array _,[arg] -> 163 + hash arg",51],["override this.MetadataToken = hash declaringType + hash this.Name",41],["if i > defaultHashNodes then i <- defaultHashNodes // limit the hash",36],["| SymbolKind.SDArray,[arg] -> 10 + hash arg",51],["override this.MetadataToken = hash declaringType + hash this.Name",41]],"useCount":3557},{"word":"have","context":[["// Check if we have a codepage from the console",40],["/// Post-filter items to make sure they have precisely the right name",44],["// \"single named item\" rule. This is where we have a single accessible method",80],["if len1 <> length arr2 then invalidArg \"arr2\" \"the arrays have different lengths\"",84],["// Not, this does not have to be a SyncOp, it can be called from any thread",48],["/// headers that have to be handled specially - such as Accept, Content-Type & Referer)",48],["if (cinfo.GetParameters()).Length <> 0 then failwith \"Type initializer should not have parameters\"",51],["// the binding must have leaves that are themselves variables (due to the limited support for byrefs in expressions)",54],["/// arrays must have the same lengths, otherwise an <c>ArgumentException</c> is",57],["// These don't have to return fully accurate results - they are used",60]],"useCount":7446},{"word":"head","context":[["let a1 = head r1",128],["|> List.head",89],["let pinfo = List.head pinfos",91],["let c2 = head t22",96],["let h3 = head t3",96],["let b2 = head t21",96],["let a2 = head r2",112],["let h2 = head t2",114],["let h1 = head r1",114],["|> Seq.head",352]],"useCount":6841},{"word":"here","context":[["if prefixes.vol <> Nonvolatile then failwith \"a volatile prefix is not allowed here\";",60],["here",146],["if prefixes.tl <> Normalcall then failwith \"a tailcall prefix is not allowed here\";",60],["// data structures involved here are so large we can't take the risk.",48],["// TEMP : Until any \"real\" code is added here (if ever), just emit a message",40],["// SEQUENCE POINTS: need to build a let here consuming spBind",40],["if prefixes.ro <> NormalAddress then failwith \"a readonly prefix is not allowed here\";",75],["if prefixes.constrained <> None then failwith \"a constrained prefix is not allowed here\";",75],["// and unit type inference. Normalize them here",38],["if prefixes.al <> Aligned then failwith \"an unaligned prefix is not allowed here\";",75]],"useCount":4788},{"word":"http","context":[["source http://www.nuget.org/api/v2",168],["﻿// Learn more about F# at http://fsharp.net",172],["source \"http://www.nuget.org/api/v2\"",165],["remote: http://www.nuget.org/api/v2",152],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://www.nuget.org/api/v2",147],["<Choose xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",146],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://nuget.org/api/v2",139],["source \"http://nuget.org/api/v2\"",134],["remote: http://nuget.org/api/v2",132],["<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">",113]],"useCount":4795},{"word":"i","context":[["i <- i + 1",691],["for i = 0 to len1 - 1 do",182],["let i = ref 0",182],["let rec loop i =",192],["i",204],["for i = 0 to len - 1 do",403],["match i with",452],["let mutable i = 0",677],["i <- i + 1",691],["match fmt.[i] with",168]],"useCount":44990},{"word":"id","context":[["| Some id ->",99],["| id :: rest ->",119],["let m = unionRanges m id.idRange",135],["id My.Thing",146],["|> List.choose id",158],["|> Seq.choose id",159],["let id = Guid.NewGuid()",229],["match id with",84],["| id::rest ->",85],["id",601]],"useCount":20005},{"word":"idRange","context":[["let m = unionRanges m id.idRange",135],["let m = id.idRange",77],["let resInfo = resInfo.AddEntity(id.idRange,submodref)",68],["error (Error(FSComp.SR.nrGlobalUsedOnlyAsFirstName(), id.idRange))",68],["| SynExpr.Ident id -> id.idRange",65],["errorR(Error(FSComp.SR.tcOperatorIncorrectSyntax(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",54],["|> CollectResults (fun (resInfo,typ) -> ResolveObjectConstructorPrim ncenv nenv.eDisplayEnv resInfo id.idRange ad typ)",47],["let logicalMethId = ident (ComputeLogicalName memberId memberFlags,memberId.idRange)",40],["errorR(Error(FSComp.SR.tcBinaryOperatorRequiresVariable(nm.idText, Option.get (customOpUsageText nm)), nm.idRange))",36],["errorR(Error(FSComp.SR.tcBinaryOperatorRequiresBody(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",36]],"useCount":3585},{"word":"idText","context":[["let tcrefs = LookupTypeNameInEnvNoArity fullyQualified id.idText nenv",34],["errorR(Error(FSComp.SR.tcBinaryOperatorRequiresVariable(nm.idText, Option.get (customOpUsageText nm)), nm.idRange))",36],["if isNullableOp opId.idText then",36],["errorR(Error(FSComp.SR.cannotResolveNullableOperators(DecompileOpName opId.idText),relExpr.Range))",36],["errorR(Error(FSComp.SR.tcBinaryOperatorRequiresBody(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",36],["errorR(Error(FSComp.SR.tcOperatorIncorrectSyntax(nm.idText, Option.get (customOpUsageText nm)),nm.idRange))",54],["| id :: lid when id.idText = MangledGlobalName ->",68],["| [id] when id.idText = MangledGlobalName ->",68],["errorR(Error(FSComp.SR.tcInvalidRelationInJoin(nm.idText),relExpr.Range))",72],["| id :: rest when id.idText = MangledGlobalName -> rest",80]],"useCount":4672},{"word":"idx","context":[["let (tab,idx) = seekReadUncodedToken ctxt.is (start + (!curr))",72],["// idx 4",72],["// idx 3",74],["let s1,s2 = splitNameAt nm idx",76],["// idx 2",76],["idx <- idx + 1",77],["// idx 0",78],["| Some idx ->",100],["// idx 1",78],["idx <- idx + 1",77]],"useCount":10226},{"word":"if","context":[["if",876],["#if EXTENSIONTYPING",4122],["if bExist then",463],["#if FX_NO_LOCAL_FILESYSTEM",530],["#if ONE",570],["if c <> 0 then c else",662],["#if SILVERLIGHT",709],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["#if DEBUG",2517],["#if FX_NO_CUSTOMATTRIBUTEDATA",1144]],"useCount":149852},{"word":"ignore","context":[[") |> ignore",233],["|> ignore",1907],["1 |> ignore",798],["|> ignore)",111],["let (~~) (t:string) = sb.Append t |> ignore",119],["node.ParentNode.RemoveChild node |> ignore",127],["CheckThrowsInvalidOperationExn(fun () -> enum.Current |> ignore)",128],["Console.ReadLine() |> ignore",162],["] |> ignore",542],["sb.Clear() |> ignore",214]],"useCount":18268},{"word":"ilG","context":[["| DT_U2  -> ilG.EmitAndLog(OpCodes.Stind_I2)   // NOTE: is it ok?",16],["| DT_U1  -> ilG.EmitAndLog(OpCodes.Ldelem_U1)",16],["ilG.MarkSequencePoint(symDoc, l1, c1, l2, c2)",16],["emitInstrVolatile ilG vol;",64],["ilG.EmitAndLog(OpCodes.Call,meth)",48],["ilG",32],["ilG.EmitCalli(OpCodes.Calli,",32],["emitInstrCall cenv emEnv ilG OpCodes.Callvirt tail mspec varargs",31],["ilG.EndExceptionBlock()",16],["if logRefEmitCalls then printfn \"ilg%d.BeginExceptionBlock()\" (abs <| hash ilG)",16]],"useCount":4264},{"word":"ilg","context":[["ilg.Emit(OpCodes.Readonly)",121],["let after = ilg.DefineLabel()",122],["ilg.Emit(OpCodes.Stloc, lb)",122],["ilg.Emit(OpCodes.Br, before)",122],["let before = ilg.DefineLabel()",122],["ilg.Emit(OpCodes.Ldarg_0)",251],["ilg.Emit(OpCodes.Ret)",139],["ilg.MarkLabel before",122],["let ilg = cb.GetILGenerator()",116],["ilg.Emit(OpCodes.Ldloc, lb)",122]],"useCount":11808},{"word":"implementation","context":[["/// Set the quotation used to compute the implementation of gets of this property.",68],["// The dynamic implementation",63],["/// semantics if any. It is not present if the type defines its own implementation",80],["/// Set the function used to compute the implementation of sets of this property.",68],["\\ *     IBM Corporation - initial implementation",436],["// Call the recursive implementation.",216],["// optimized mutation-based implementation. This code is only valid in fslib, where mutation of private",114],["/// Reference implementation:",110],["// MUTABILITY: used when propagating signature attributes into the implementation.",93],["// Call the recursive implementation function.",72]],"useCount":3841},{"word":"implicit","context":[["/// Gets any implicit CompareTo methods added to an F# record, union or struct type definition.",34],["/// Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable",34],["/// including hidden fields from the compilation of implicit class constructions.",34],["/// Gets any implicit hash/equals methods added to an F# record, union or struct type definition.",34],["/// An intermediate definition that represent the point in an implicit class definition where",36],["// --- Extract bindings for implicit constructors",36],["// for the class to be identical to those used for the implicit class constructor and the static class constructor.",38],["// this variable for the implicit class constructor. For static members, we assert the type variables associated",38],["| _ -> failwith \"at most one implicit constructor allowed\"",59],["/// static fields, 'val' declarations and hidden fields from the compilation of implicit class constructions.",102]],"useCount":2298},{"word":"in","context":[["end in",171],["for cust in dc.Main.Customers do",217],["// to COM components.  If you need to access a type in this assembly from",997],["// Setting ComVisible to false makes the types in this assembly not visible",997],["in",2024],["// By using this source code in any fashion, you are agreeing to be bound",490],["// This file is subject to the terms and conditions defined in",233],["// By using this source code in any fashion, you are agreeing to be bound",203],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",195],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",195]],"useCount":85787},{"word":"include","context":[["include ffl/tos.fs",28],["include ffl/enm.fs",28],["#include peel_fs",29],["/// then this does not include any attributes from those sources.",34],["/// then this _does_ include this documentation. If the entity is backed by Abstract IL metadata",34],["include ffl/config.fs",239],["include ffl/stc.fs",106],["include ffl/tst.fs",71],["// argExprs should always include 'this'",35],["include ffl/str.fs",38]],"useCount":2114},{"word":"index","context":[["let c = input.[index]",75],["index <- index + 1",200],["index <- index + 1",200],["let mutable index = 0",167],["match index with",116],["emit ExpectedStackState.Value index",112],["/// [category:Sorting and index manipulation]",108],["if input.Length <= index",95],["/// <param name=\"start1\">The start index of the first dimension.</param>",68],["index",84]],"useCount":6638},{"word":"inference","context":[["/// a fresh set of inference type variables for the type parameters of the union type.",30],["/// Set the properties of recursive values that are only fully known after inference is complete",20],["/// Optimized unification routine that avoids creating new inference",62],["/// at the member signature prior to type inference. This is used to pre-assign type information if it does",28],["/// Indicates if the type inference variable was generated after an error when type checking expressions or patterns",34],["/// systematically with lower-case type inference variables such as <c>'a</c>.",42],["// to C<_> occurs then generate C<?ty> for a fresh type inference variable ?ty.",40],["// and unit type inference. Normalize them here",38],["// complete inference types.",34],["/// Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable",34]],"useCount":2181},{"word":"info","context":[["info.Arguments <- args) parameters.TimeOut",142],["if 0 <> ExecProcess (fun info ->",120],["match info with",128],["let st = info.ProvidedType",131],["| TProvidedTypeExtensionPoint info ->",140],["| ProvidedTypeMetadata info ->",140],["let info =",140],["| Some info ->",318],["info.FileName <- parameters.ToolPath",169],["ExecProcess (fun info ->",166]],"useCount":11734},{"word":"infoReader","context":[["infoReader.GetILFieldInfosOfType (None,ad,m,ty)",24],["DataTipElement(os.ToString(), GetXmlComment (XmlDoc [||]) infoReader m d)",22],["infoReader.GetEntireTypeHierachy(AllowMultiIntfInstantiations.Yes,m,typ) |> List.collect (fun typ ->",24],["match metaInfoOfEntityRef infoReader m tcref  with",30],["let xml = GetXmlComment (XmlDoc [||]) infoReader m d",30],["let xml = GetXmlComment (if minfo.HasDirectXmlComment then minfo.XmlDoc else XmlDoc [||]) infoReader m d",30],["let infoReader = new InfoReader(g,amap)",40],["let amap = infoReader.amap",268],["let g = infoReader.g",389],["match TryDestStandardDelegateTyp infoReader m ad dty with",36]],"useCount":2947},{"word":"information","context":[["// the packaging of this file.  Please review the following information to",62],["// set of attributes. Change these attribute values to modify the information",1064],["// Version information for an assembly consists of the following four values:",1046],["/// Add XML documentation information to this provided constructor",217],["/// Add definition location information to the provided type definition.",146],["\\ See the file \"COPYING\" for further information about",89],["/// Add XML documentation information to this provided field",66],["// For the further information contact <mailto:david.sorokin@gmail.com>.",62],["/// <param name=\"line\">The line number where the information is being requested.</param>",59],["/// <param name=\"names\">The identifiers at the location where the information is being requested.</param>",59]],"useCount":7586},{"word":"inherit","context":[["inherit System.Attribute",417],["inherit System.Attribute()",541],["inherit Type()",141],["/// <inherit />",323],["inherit Attribute()",234],["inherit PSCmdlet()",148],["inherit HTMLElement",141],["inherit TypeProviderForNamespaces()",133],["inherit IDisposable",132],["inherit System.Reflection.ParameterInfo()",131]],"useCount":8669},{"word":"init","context":[["let init =",35],["let args = ILList.init shape.Rank (fun _ -> cenv.ilg.typ_int32)",36],["let mutable init = false",85],["let t1_1 = init t1",64],["let init () =",60],["let t1_2 = init t1_1",56],["let t1_3 = init t1_2",48],["let intArr = Array2D.init 2 3 (fun i j -> i*100 + j)",44],["let t1_4 = init t1_3",40],["List.init numClauses (fun i ->",36]],"useCount":2226},{"word":"inline","context":[["let inline sequence s =",32],["inline",32],["/// Helper for parsing the inline IL fragments.",42],["let inline checkNonNull argName arg =",39],["let inline (>=>) f g = fun x -> f x >>= g",38],["let inline (<=<) x = flip (>=>) x",38],["let inline (===) a b = LanguagePrimitives.PhysicalEquality a b",37],["let inline test col =",35],["let inline mapM f x = sequence (List.map f x)",34],["let inline cons a b = lift2 List.cons a b",33]],"useCount":4836},{"word":"input","context":[["let input =",331],["/// <param name=\"list\">The input list.</param>",358],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["/// <param name=\"input\">The input expression to match against.</param>",315],["/// <param name=\"input\">The input expression to match against.</param>",315],["match input with",440],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518],["/// <param name=\"source\">The input sequence.</param>",562],["/// <param name=\"value\">The input value.</param>",584],["/// <param name=\"array\">The input array.</param>",657]],"useCount":15981},{"word":"instance","context":[["/// <summary>Creates an instance of the attribute</summary>",427],["match instance with",55],["/// Initializes a new instance.",33],["/// Get a list of all instance fields for F#-defined record, struct and class fields in this type definition,",34],["/// Renders a textual representation of the instance that is suitable for diagnostic purposes",34],["/// Get a list of all instance fields for F#-defined record, struct and class fields in this type definition.",34],["// instance member unit argument elimination",38],["// Get or set instance IL field",40],["// Structs with no instance fields get size 1, pack 0",32],["static member Instance = instance",45]],"useCount":3045},{"word":"instantiation","context":[["// Create a formal instantiation if needed",36],["// If we have got an explicit instantiation then use that",38],["// The empty instantiation on the AbstractIL fspec is OK, since we make the correct fspec in IlxGen.GenAsm",42],["// This ensures we always get the type instantiation right when doing this from",80],["/// Fixup the type instantiation at recursive references. Used after the bindings have been",20],["// Work out if an explicit instantiation has been given. If so then the explicit type",20],["/// if it is an instantiation of a generic type.",22],["/// <param name=\"actorFactory\">Object responsible for actor instantiation.</param>",24],["// NOTE: This doesn't take instantiation into account",24],["/// Abstract a type to a parametric-type. Requires \"formal parameters\" and \"instantiation function\".",83]],"useCount":1936},{"word":"int","context":[["member AddDefinitionLocation : line:int * column:int * filePath:string -> unit",249],["member AddDefinitionLocation : line:int * column:int * filePath:string -> unit",249],["fun (range:_1D) (buf:array<int>) ->",216],["VersionNo : int }",187],["let f(xs : int[]) =",146],["addr1 : int *",96],["let emptyArr:int list = [ ]",114],["Spec.ForAny<int[]>(fun xs ->",116],["// int",130],["let emptyArr:int[] = [| |]",129]],"useCount":29744},{"word":"int32","context":[["enum (int32 TypeProviderTypeAttributes.IsErased)",66],["&&& ~~~(enum (int32 TypeProviderTypeAttributes.IsErased))",65],["| Int32 of int32",73],["| :? int16 as x -> ilg.Emit(OpCodes.Ldc_I4, int32 x)",64],["| :? uint32 as x -> ilg.Emit(OpCodes.Ldc_I4, int32 x)",64],["| :? uint16 as x -> ilg.Emit(OpCodes.Ldc_I4, int32 (int16 x))",64],["| :? int8 as x -> ilg.Emit(OpCodes.Ldc_I4, int32 x)",64],["| :? uint8 as x -> ilg.Emit(OpCodes.Ldc_I4, int32 (int8 x))",64],["| :? int32 as x -> ilg.Emit(OpCodes.Ldc_I4, x)",64],["| :? char as x -> ilg.Emit(OpCodes.Ldc_I4, int32 x)",64]],"useCount":6498},{"word":"int64","context":[["let i : int64 = -1L",56],["let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64",48],["let beginY = defaultArg minY 0 |> int64",56],["let maxY = defaultArg maxY (int info.SY - 1) |> int64",56],["let maxX = defaultArg maxX (int info.SX - 1) |> int64",60],["let beginX = defaultArg minX 0 |> int64",60],["| :? uint64 as x -> ilg.Emit(OpCodes.Ldc_I8, int64 x)",64],["| :? int64 as x -> ilg.Emit(OpCodes.Ldc_I8, x)",64],["| Int64 of int64",75],["let beginZ = defaultArg minZ 0 |> int64",48]],"useCount":3794},{"word":"integer","context":[["// Logical shift right treating int32 as unsigned integer.",22],["// Code that uses this should probably be adjusted to use unsigned integer types.",22],["// integer vector",24],["/// <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all",25],["/// indicates the partition, and the second integer passed to the function index (from 0) element within the partition.",30],["/// <remarks>Any integer from 0 to 100.</remarks>",32],["// integer Seq",353],["// integer List",387],["// integer array",514],["0 // return an integer exit code",537]],"useCount":2768},{"word":"interface","context":[["interface System.Collections.IEnumerable with",286],["interface IArgParserTemplate with",641],["interface System.IDisposable with",578],["interface System.IComparable with",407],["interface",291],["interface IDisposable with",1224],["interface IEnumerable<'T> with",195],["interface System.IComparable",202],["interface IComparable with",235],["interface IEnumerable with",288]],"useCount":11544},{"word":"internal","context":[["/// or marked 'internal' or 'private' and we have to check various conditions associated with that.",38],["// Compiler-internal references to items in fslib are Ref_nonlocals even when compiling fslib.",38],["module internal Utilities =",39],["module internal Misc =",60],["let internal options =  checker.GetProjectOptionsFromCommandLineArgs (projFileName, args)",43],["//    printfn \"internal form: %A\" internalForm",53],["module internal Utils =",56],["type internal ExpectedStackState =",57],["// There is an internal version of typeof defined in prim-types.fs that needs to be detected",57],["module internal AssemblyVersionInformation =",1560]],"useCount":6221},{"word":"into","context":[["/// Convert string into Option string where null and String.Empty result in None",34],["// Construct the code that saves the 'it' value into the 'SaveIt' register.",36],["// MUTABILITY: used when propagating signature attributes into the implementation.",93],["let item = Item.CustomOperation (\"into\", (fun () -> None), None)",36],["(* the xmlDocSigOf* functions encode type into string to be used in \"id\" *)",38],["// of which there can be many. Simply turn them all into one big AND expression as that is the",46],["// REVIEW: fold this into ILMethodDef",47],["// REVIEW: write into an accumuating buffer",78],["/// <param name=\"item\">Item to be inserted into queue</param>",59],["// close the connection first otherwise it won't get enlisted into the transaction",56]],"useCount":6162},{"word":"is","context":[["seek ctxt.is addr;",238],["// This file is part of WebSharper",342],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["// General Information about an assembly is controlled through the following",1065],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["\\ This file is part of Gforth.",664],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518],["\\ * which accompanies this distribution, and is available at",436],["// This file is subject to the terms and conditions defined in",233]],"useCount":65614},{"word":"isEmpty","context":[["| versions when Array.isEmpty versions |> not -> versions",36],["if Seq.isEmpty !compatibleVersions then",37],["let isEmpty s = s = ExpectedStackState.Empty",55],["if isEmpty expectedState then () else",58],["let popIfEmptyExpected s = if isEmpty s then pop()",60],["match returnTypeIsVoid, (isEmpty expectedState) with",61],["if isEmpty expectedState then ignore, ignore",61],["if isEmpty expectedState then ()",64],["if Array.isEmpty array then",77],["|> Seq.isEmpty",66]],"useCount":2485},{"word":"isNil","context":[["assert (isNil ilMethTypars)",30],["if isNil fsiOptions.SourceFiles then",19],["let emptyMeasure = match tycon.TypeOrMeasureKind with TyparKind.Measure -> isNil alldecls | _ -> false",26],["if isNil tps then env else",26],["|> List.filter (fun v -> isNil (Option.get v.MemberInfo).ImplementedSlotSigs)",26],["if isNil rest then",28],["if isNil rfields then None else",28],["if isNil enclosingNamespacePath then",54],["when (namedCurriedCallerArgs |> List.forall isNil &&",36],["let isNil x = match x with [] -> true | _ -> false",34]],"useCount":1888},{"word":"isStatic","context":[["if isStatic then",175],["let cconv = if isStatic then ILCallingConv.Static else ILCallingConv.Instance",32],["IsStatic = isStatic;",34],["| IncrClassBindingGroup(binds,isStatic,_) ->",40],["bindingAttr.HasFlag(if isStatic then BindingFlags.Static else BindingFlags.Instance) &&",50],["let isStatic, isPublic =",51],["with get()  = isStatic",123],["// Delay construction - to pick up the latest isStatic",125],["let mutable isStatic = false",125],["and set x = isStatic <- x",125]],"useCount":2409},{"word":"it","context":[["/// The documentation is re-computed  every time it is required.",212],["/// <param name=\"overwrite\">Enables overwriting of target file if it exists. Defaults to false.</param>",64],["// method produced something, but we don't need it",64],["// Add an I_nop if this is an initonly field to make sure we never recognize it as an lvalue. See mkExprAddrOfExpr.",60],["match it with",60],["// NICE: it would be better to do this check in the type checker",57],["// TODO: this is very fake, we rely on the fact it is never needed",58],["// OK, the implied nested type is not defined, define it now",59],["// nice: don't introduce awful temporary for r.h.s. in the 99% case where we know what we're binding it to",60],["///  - `outputPath` - If it is null or empty then the project settings are used.",60]],"useCount":13971},{"word":"item","context":[["for item in items do",84],["|> MapResults (fun (resInfo,item) -> (resInfo,item,[]))",60],["let notRequired opname item =",63],["let item =",66],["| Some item ->",68],["#nowarn \"44\" // This construct is deprecated. please use List.item",72],["// \"single named item\" rule. This is where we have a single accessible method",80],["let key = table.PutItem item",83],["match box item with",104],["match item with",782]],"useCount":8803},{"word":"items","context":[["let items =",238],["items",330],["let items = items |> RemoveExplicitlySuppressed g",95],["let items = items |> RemoveDuplicateItems g",95],["let items = items |> RemoveDuplicateItems g",95],["let items = items |> RemoveExplicitlySuppressed g",95],["for item in items do",84],["// Find all the items with an empty key list and call 'tipf'",79],["// Find all the items with a non-empty key list. Bucket them together by",79],["match items with",108]],"useCount":6504},{"word":"iter","context":[["|> List.iter",100],["employees |> Seq.iter (printfn \"%A\")",124],["List.iter",88],["|> List.iter (fun x ->",69],["Array.iter parameters.Add paras",68],["departments |> List.iter (printfn \"%A\")",66],["unsolved |> List.iter (fun tp ->",60],["let iter () : unit =",59],["c <- iter._Increment()",51],["List.iter walkAttribute attrs",88]],"useCount":8298},{"word":"its","context":[["//   (its implementation of IsAssignableFrom raises NotSupportedException so it will be safer to always emit castclass)",51],["// a 'let'. e.g. we've inlined a function and bound its arguments using 'let'",22],["// we are sometimes forced to generate a sequence point for the expression anyway based on its",22],["// else where would its value be defined?",25],["// Format each argument, including its name and type",27],["// zero out the current value to free up its memory",27],["// A full type signature is required on this method because it is used at more specific types within its own scope",32],["// 'delayed' is about to be dropped on the floor, first do rudimentary checking to get name resolutions in its body",36],["/// semantics if any. It is not present if the type defines its own implementation",80],["// Allow at most one constructor, and use its arguments as the fields of the type",64]],"useCount":1951},{"word":"j","context":[["let mutable j = 0",81],["j <- j + 1",81],["j",58],["let termSubst j s t =",50],["let intArr = Array2D.init 2 3 (fun i j -> i*100 + j)",44],["let j = ref 0",48],["for j in 0..15 do",46],["j <- j + 1",81],["for j = 0 to len2 - 1 do",95],["let v, j = jacobianT' f x",45]],"useCount":4159},{"word":"just","context":[["// For vector length zero, just propagate the prior timestamp.",34],["// TODO: check why F# compiler doesn't emit default value when just p.Attributes is used (thus bad metadata is emitted)",32],["/// For other values it is just the actual parent.",32],["// and \"{Major}.{Minor}.{Build}.*\" will update just the revision.",26],["// Really we should just search the path or otherwise resolve the 'mono' command?",24],["// FSharp.Data change: just using this.BaseType is not enough in the case of CsvProvider,",38],["// TEMP : Until any \"real\" code is added here (if ever), just emit a message",40],["// Try again, just case we can restart",42],["// Otherwise, assume this is a generative assembly and just emit a call to the constructor or method",63],["// just drop rhs on the floor",72]],"useCount":2612},{"word":"k","context":[["for k = 0 to len3 - 1 do",60],["|> Seq.map (fun k -> k.Key)",38],["|> Seq.map (fun k -> k.Key)",38],["if usedPackages.ContainsKey k |> not then",40],["k",43],["[|for KeyValue(k,v) in projectionColumns do",46],["| SetNode(k,l,r,_) ->",62],["| MapNode(k,v,l,r,_) ->",85],["match k with",242],["let c = comparer.Compare(k,k2)",295]],"useCount":8834},{"word":"key","context":[["| key::rest ->",74],["/// <param name=\"key\">The input key.</param>",70],["[ for (KeyValue(key,items)) in buckets -> nodef key items ]",78],["[ for (KeyValue(key,items)) in buckets -> nodef key items ]",78],["// Find all the items with a non-empty key list. Bucket them together by",79],["// the first key. For each bucket, call 'nodef' on that head key and the bucket.",79],["key",79],["// the first key. For each bucket, call 'nodef' on that head key and the bucket.",79],["// Find all the items with an empty key list and call 'tipf'",79],["let key = table.PutItem item",83]],"useCount":8256},{"word":"keys","context":[["/// <param name=\"id\">The primary key or the list of primary keys.</param>",48],["///  - `keyProj` - A function that transforms keys from original space to a new",28],["/// you can specify whether you want to save the row keys or not (and headers for the keys)",30],["/// you can specify whether you want to save the row keys or not (and headers for the keys)",30],["// value keys",220],["/// The list will be ordered by the keys of the map.",30],["/// <param name=\"projection\">A function to transform items of the input flow into comparable keys.</param>",31],["///    used as the smallest key in a chunk; for `Direction.Backward`, the keys are",39],["///    used as the greatest keys in a chunk.",39],["// reference keys",176]],"useCount":2139},{"word":"kind","context":[["match kind with",666],["match kind,args with",263],["let kind =",99],["\"kind\", upcast \"NON_NULL\"",96],["\"kind\", upcast \"SCALAR\"",87],["kind",84],["let kind = InferTyconKind cenv.g (kind,attrs,slotsigs,fields,inSig,isConcrete,m)",72],["let kind = InferTyconKind cenv.g (kind,attrs,slotsigs,fields,inSig,isConcrete,m)",72],["\"kind\", upcast \"OBJECT\"",66],["type ProvidedSymbolType(kind: SymbolKind, args: Type list) =",55]],"useCount":5599},{"word":"l","context":[["| Some l -> l",66],["let z = addL z pos l",70],["match l,r with",75],["| MapNode(k,v,l,r,_) ->",85],["(match l with",96],["| MapNode(k2,v2,l,r,_) ->",101],["l",106],["s = a && l = a",120],["use l = Logging.LogScope()",880],["match l with",1355]],"useCount":16763},{"word":"lambda","context":[["lambda.DefineMethodOverride(invoke, decl)",51],["lambda.CreateType() |> ignore",35],["// lambda name should be unique across all types that all type provider might contribute in result assembly",45],["emitExpr (ilg, copyOfLocals, [| Quotations.Var(\"this\", lambda); v|]) expectedState body",45],["let lambda = assemblyMainModule.DefineType(uniqueLambdaTypeName(), TypeAttributes.Class)",50],["let f = lambda.DefineField(v.Name, v.Type, FieldAttributes.Assembly)",51],["let ctor = lambda.DefineDefaultConstructor(MethodAttributes.Public)",51],["lambda.SetParent(baseType)",51],["pr \"lambda \";",78],["/// Event handler defined on server-side, lambda must be a call to a static member.",278]],"useCount":1865},{"word":"last","context":[["// This extension member adds to the FuncConvert type and is the last resort member in the method overloading rules.",38],["// There should be no bindings that have not been generalized since checking the vary last binding always",40],["[<DllImport(dll, CallingConvention=calling, ExactSpelling=exact, SetLastError=last)>]",73],["// ResultCell allows a race and throws away whichever comes last.",36],["cell serial /* # of last request processed by server */",30],["// format revision number for F# binary signature and optimization metadata. The last digit is not significant.",29],["|> Seq.last",54],["emit ExpectedStackState.Value last",56],["// for(loopVar = first..last) body",61],["| Quotations.Patterns.ForIntegerRangeLoop(loopVar, first, last, body) ->",53]],"useCount":2340},{"word":"lazy","context":[["lazy (",38],["member __.Log = lazy (Akka.Event.Logging.GetLogger(context))",39],["member this.SetBaseType t = baseType <- lazy Some t",41],["x <> 0 ==> lazy",41],["member this.SetAssembly assembly = theAssembly <- lazy assembly",46],["let mutable baseType   =  lazy baseType",58],["lazy [| for (namespaceName,types) in namespacesAndTypes do",62],["let mkXmlDocCustomAttributeData(s:string) =  mkXmlDocCustomAttributeDataLazy (lazy s)",63],["(lazy",239],["lazy",849]],"useCount":2439},{"word":"left","context":[["// The state of the left-to-right iteration through the bindings",38],["| Br (_, _, left, right) ->",96],["match left, right with",96],["/// Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.",59],["2 left +!",42],["else Br (p, m, left, s1)",40],["if left == s0 then s",40],["let breaks,l,pos,offsetl = fit breaks (pos,l)    // fit left",39],["-2 left +!",39],["/// Right-to-left Kleisli composition",38]],"useCount":2918},{"word":"len","context":[["for i = 0 to len - 1 do",403],["let len = array.Length",372],["let len = Array.length array",114],["let len = length arr",96],["for i = len - 1 downto 0 do",89],["let results = Array.zeroCreate len",82],["let buf = Array.zeroCreate<byte> (int len)",70],["let len = stream.Length",70],["let result = Array.zeroCreate len",64],["for i in 0 .. len - 1 do",60]],"useCount":4815},{"word":"length","context":[["|> Seq.length",226],["in error fi (msg i (List.length ctx))",48],["|> List.length",58],["ilg.Emit(OpCodes.Ldc_I4, List.length elements)",61],["/// <exception cref=\"System.ArgumentException\">Thrown when the input arrays differ in length.</exception>",71],["let len1 = length arr1",84],["if len1 <> length arr2 then invalidArg \"arr2\" \"the arrays have different lengths\"",84],["let len = length arr",96],["abstract length: float with get, set",111],["let len = Array.length array",114]],"useCount":7533},{"word":"let","context":[["let result =",1387],["let main argv =",1277],["let expected =",1155],["let customAttributesImpl = CustomAttributesImpl()",562],["let expr =",574],["let ad = env.eAccessRights",590],["let res =",593],["let mutable i = 0",677],["let args =",685],["let fu = 0",798]],"useCount":539287},{"word":"level","context":[["if lo2 <> None || hi2 <> None then invalidOp \"Slicing on level of a hierarchical indices is not supported\"",36],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["| _                   -> failwith \"Forward and reverse AD cannot run on the same level.\"",44],["/// Logs a message at Debug level using configured Akka logger.",28],["let level = ref 0",28],["/// Logs a message at Warning level using configured Akka logger.",28],["/// Is this represented as a \"top level\" static binding (i.e. a static field, static member,",32],["match level with",36],["if lo1 <> None || hi1 <> None then invalidOp \"Slicing on level of a hierarchical indices is not supported\"",36]],"useCount":2354},{"word":"lexbuf","context":[["let engine lexer lexbuf startState = (tables ()).Interpret(lexer, lexbuf, startState)",42],["error (Lexer.info lexbuf) \"Parse error\"",28],["IdentifierToken args lexbuf s",31],["token lexbuf",33],["code p buff lexbuf",40],["let lexbuf = UnicodeLexing.StringAsLexbuf source",40],["Microsoft.FSharp.Core.Operators.unbox ((tables ()).Interpret(lexer, lexbuf, 0))",41],["let engine lexer lexbuf startState = (tables ()).Interpret(lexer, lexbuf, startState)",42],["lexbuf.BufferLocalStore.[xmlDocKey] <- box (XmlDocCollector())",42],["match _fslex_tables.Interpret(_fslex_state,lexbuf) with",119]],"useCount":2752},{"word":"lib","context":[["[<DllImport(lib)>]",183],["match lib with",84],["#r \"../../packages/NUnit.2.6.3/lib/nunit.framework.dll\"",71],["@\"..\\Fantomas\\lib\\FSharp.Core.dll\"",68],["[ @\"..\\Fantomas\\lib\\FantomasLib.dll\"",68],["@\"..\\Fantomas\\lib\\Fantomas.exe\" ],",62],["| Reference.Library lib ->",61],["@\"..\\Microsoft.Net.Http\\lib\\net40\\System.Net.Http.Primitives.dll\"",55],["[<DllImport(lib);SuppressUnmanagedCodeSecurity>]",187],["#r \"../../packages/NUnit/lib/nunit.framework.dll\"",184]],"useCount":3985},{"word":"lid","context":[["| id :: lid when id.idText = MangledGlobalName ->",68],["let itemRange = ComputeItemRange wholem lid rest",34],["errorR(Error(FSComp.SR.buildMultipleToplevelModules(),rangeOfLid lid))",40],["| SynExpr.LongIdent(isOpt,LongIdentWithDots(lid,dots),None,_) ->",42],["let lid =",82],["ResolveLongIndentAsModuleOrNamespaceThen ncenv.amap m fullyQualified nenv ad lid",45],["match lookup_qname env lid with",63],["| SynExpr.DotGet(e,dm,LongIdentWithDots(lid,dots),_) ->",42],["match lid with",420],["| _ -> lid",83]],"useCount":2523},{"word":"line","context":[["/// <param name=\"lineText\">The text of the line where the information is being requested.</param>",59],["Line = line",57],["the whole box cannot fit on the current line",54],["information and line-breaking hints for the pretty-printing library:",52],["/// <param name=\"line\">The line number where the information is being requested.</param>",59],["member AddDefinitionLocation : line:int * column:int * filePath:string -> unit",249],["match line with",134],["for line in lines do",88],["let mkDefinitionLocationAttributeCustomAttributeData(line:int,column:int,filePath:string) =",63],["/// <param name=\"line\">The line number where the information is being requested.</param>",59]],"useCount":6541},{"word":"lines","context":[["let lines =",109],["/// Displays a series of connecting vertical lines where the thickness",29],["match lines with",101],["for line in lines do",88],["obox0  Same but indent continuation lines to the same column as the",54],["if lines.Length = 0 then XmlDoc.Empty",42],["// We'll need number of lines for adjusting error messages at EOF",33],["on two lines.",113],["lines",189],["/// and direction of the lines are dependent on the action",29]],"useCount":1896},{"word":"list","context":[["let emptyArr:int list = [ ]",114],["/// <param name=\"list\"></param>",106],["with set  (q:Quotations.Expr list -> Quotations.Expr) =",104],["/// <param name=\"list\">The input list.</param>",358],["list",127],["checkNonNull \"list\" list",265],["checkNonNull \"list\" list",265],["/// <param name=\"list\">The input list.</param>",358],["match list with",301],["with set (q:Quotations.Expr list -> Quotations.Expr) =",104]],"useCount":28258},{"word":"load","context":[["CompilerOption(\"load\",tagFile, OptionString (fun s -> inputFilesAcc <- inputFilesAcc @ [(s,false)]), None,",21],["\\ Open the connection to the gtk-server and load all definitions from the gtk-server.cfg file",22],["// Doing both a store and load keeps FxCop happier because it thinks the field is useful",32],["#load \"../../src/FSharpVSPowerTools.Core/Utils.fs\"",34],["#load \"TestHelpers.fs\"",35],["// Provider-generated assemblies don't necessarily have an on-disk representation we can load.",36],["// Restore the stack and load the result",41],["#load \"Common.fs\"",81],["#load \"FsUnit.fs\"",89],["#load \"../Common/FsUnit.fs\"",103]],"useCount":1835},{"word":"local","context":[["/// Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control",84],["// Do this by generating a fake \"looking from the outside in\" non-local value reference for",28],["local {",75],["let ldres = fun () -> ilg.Emit(OpCodes.Ldloc, local)",67],["let stres = fun () -> ilg.Emit(OpCodes.Stloc, local)",67],["let local = ilg.DeclareLocal (convType body.Type)",53],["// non-local values do not contain free variables",38],["//     bake our own function base contracts for local type functions",32],["/// Evaluate workflow in the local test process",31],["// allow us to resolve the compiler-non-local-references that arise from env.fs",28]],"useCount":3012},{"word":"location","context":[["// Like fsharp-compiler-location",32],["/// Registers location of RuntimeAssembly (from TypeProviderConfig) as probing folder",33],["System.Diagnostics.Debug.Assert(false, \"Error while determining default location of F# compiler\")",36],["/// Add definition location information to the provided field.",33],["/// Add definition location information to the provided field definition.",33],["/// The code location where the module, namespace or type is defined.",34],["/// Add definition location information to the provided constructor.",37],["let location =",41],["/// <param name=\"names\">The identifiers at the location where the information is being requested.</param>",59],["/// Add definition location information to the provided type definition.",146]],"useCount":1864},{"word":"lock","context":[["/// Find the matching lock file to a dependencies file",39],["lock (ClientController.ListOfClients) (fun() ->",33],["lock.Exit()",40],["/// Installs all packages from the lock file.",42],["lock ( x ) ( fun _ ->",55],["lock x (fun () ->",78],["lock syncRoot (fun () ->",107],["lock lockObj (fun () ->",95],["lock dbLock (fun () ->",32],["lock _lock <| fun _ ->",30]],"useCount":1870},{"word":"lockFile","context":[["lockFile.Groups.[Constants.MainDependencyGroup].Resolution.[PackageName \"NUnit\"].Version",57],["selectiveUpdate true noSha1 (VersionsFromGraph graph) (PackageDetailsFromGraph graph) lockFile dependenciesFile",70],["lockFile.GetGroupedResolution()",282],["let lockFile =",205],["let packages = List.rev lockFile.Packages",126],["let lockFile = LockFile.Parse(\"\",toLines lockFileData)",100],["let references = lockFile.SourceFiles",50],["let result = groupMap lockFile",52],["lockFile.Options.Strict |> shouldEqual false",48],["match lockFile.Groups |> Map.tryFind groupName with",99]],"useCount":2279},{"word":"log4net","context":[["nuget \"Castle.Windsor-log4net\" \"~> 3.2\"",65],["[(\"Castle.Core-log4net\",\"3.2.0\");",59],["log4net (1.2.10)",210],["(mainGroup,\"log4net\",\"1.2.10\")]",60],["open log4net",71],["nuget Castle.Core-log4net ~> 3.2",75],["log4net (>= 1.0)",81],["(\"log4net\",\"1.2.10\")]",98],["nuget Castle.Windsor-log4net ~> 3.2",132],["nuget Castle.Core-log4net",149]],"useCount":2399},{"word":"lookup","context":[["// (expr).(expr) is an ML-deprecated array lookup, but we want intellisense on the dot",30],["/// Treat a list of key-value pairs as a lookup collection.",32],["/// The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts",34],["/// [category:Sampling, resampling and advanced lookup]",48],["/// [category:Accessing frame data and lookup]",88],["// These come through as an empty plid and residue \"\". Otherwise we try an environment lookup",24],["Printf.sprintf \"Variable lookup failure: offset: %d, ctx size: %d\"",96],["/// [category:Accessing series data and lookup]",112],["// Use an environment lookup as the last resort",26],["// IL type references have a pre-computed hash code to enable quick lookup tables during binary generation.",24]],"useCount":2435},{"word":"loop","context":[["let rec loop i =",192],["loop ;",219],["return! loop()",148],["let rec loop () =",175],["let rec loop() =",173],["let rec loop expr = traverse loopCore expr",84],["loop ()",242],["loop()",268],["loop 0",286],["loop",908]],"useCount":8792},{"word":"m","context":[["| Some m ->",165],["(fun res -> ErrorD (ErrorFromAddingConstraint(denv,res,m)))",174],["errorRecovery e m",177],["m",206],["let m = csenv.m",238],["let m = csenv.m",238],["m: ####################",250],["match m with",1011],["let m = tycon.Range",330],["let m = expr.Range",265]],"useCount":125859},{"word":"m2","context":[["let m2 = sigFields |> NameMap.ofKeyedList (fun rfld -> rfld.Name)",42],["SolveDimensionlessNumericType csenv ndeep m2 trace argty1 ++ (fun () ->",42],["member b.Product (m1,m2) = typedefof<Core.CompilerServices.MeasureProduct<_,_>>.MakeGenericType [| m1;m2 |]",45],["member b.Ratio (m1, m2) = b.Product(m1, b.Inverse m2)",63],["member b.Ratio (m1, m2) = b.Product(m1, b.Inverse m2)",63],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty ++ (fun () ->",70],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace argty2 argty1 ++ (fun () ->",78],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty1 ++ (fun () ->",98],["(if m.StartLine <> m2.StartLine then",122],["member b.Product (m1,m2) = typedefof<Core.CompilerServices.MeasureProduct<_,_>>.MakeGenericType [| m1;m2 |]",45]],"useCount":3812},{"word":"main","context":[["let main argv =",1277],["void main()",1391],["let main() =",107],["void main(){",110],["let main _ =",125],["void main(void){",85],["void main(void) {",229],["let main args =",352],["void main(void)",494],["void main() {",717]],"useCount":6599},{"word":"make","context":[["// NOTE: we grab the name eagerly to make sure the type variable prints as a type variable",28],["let world = TestWorld.make ignore false EventFilter.Empty",29],["// Assign the argument to make sure it is only run once",38],["// Add an I_nop if this is an initonly field to make sure we never recognize it as an lvalue. See mkExprAddrOfExpr.",60],["// A huge number of these occur in pickled F# data, so make them unique",52],["// Both are shown to make the test easier to comprehend.",52],["/// Post-filter items to make sure they have precisely the right name",44],["0 encode-64+                    \\ | make mid and lo zero",40],["// The empty instantiation on the AbstractIL fspec is OK, since we make the correct fspec in IlxGen.GenAsm",42],["// TODO: make this an Eventually (which can be scheduled) or an Async (which can be cancelled)",44]],"useCount":2384},{"word":"map","context":[["|> Seq.map fst",117],["|> Seq.map (fun kv ->",196],["|> Seq.map snd",184],["|> List.map fst",163],["/// <param name=\"table\">The input map.</param>",147],["|> List.map (function",119],["map",127],["List.map",145],["checkNonNull \"map\" map",328],["checkNonNull \"map\" map",328]],"useCount":29561},{"word":"match","context":[["match expr with",2167],["match t with",1845],["match result with",1648],["match l with",1355],["match d with",1248],["match s with",1071],["match c with",1044],["match this with",2361],["match e with",2467],["match x with",6707]],"useCount":143617},{"word":"md","context":[["let md = x.RawMetadata",19],["let (|Valid|Invalid|) md =",19],["let code_of_mdef (md:ILMethodDef) =",19],["let mdef_code2code f md  =",25],["(match md.mdBody.Contents with",22],["let midx = GetMethodDefIdx cenv md",30],["match md with",51],["match md.mdBody.Contents with",66],["{md with",21],["member md.Code =",20]],"useCount":2198},{"word":"mdef","context":[["{mdef with",93],["if mdef.Access <> ILMemberAccess.Private then",32],["match mdef.Name with",32],["seq { match mdef with",34],["match mdef.mdKind with",35],["let mdef = copyAndRemapModDef g compgen tmenv mdef",38],["let mdef = copyAndRemapModDef g compgen tmenv mdef",38],["ILMethInfo(g,x.ILTypeInfo.ToType,None,mdef,[])",68],["EmitTheMethodDef mdef",80],["let mdef =",118]],"useCount":2959},{"word":"member","context":[["member this.AddXmlDocComputed xmlDoc                    = customAttributesImpl.AddXmlDocComputed xmlDoc",304],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["member this.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",304],["member this.AddXmlDocDelayed xmlDoc                     = customAttributesImpl.AddXmlDocDelayed xmlDoc",304],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["member __.Dispose() =",332],["member __.GetCustomAttributesDataImpl() = customAttributesImpl.GetCustomAttributesData()",476],["member this.Usage =",501],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["member x.Dispose() =",647]],"useCount":119446},{"word":"memberFlags","context":[["| Some memberFlags ->",94],["match memberFlags.MemberKind with",184],["if memberFlags.IsInstance then",60],["bindingRhs,logicalMethId,memberFlags",40],["let memberFlags = {memberFlags with MemberKind = MemberKind.PropertyGet}",40],["let logicalCompiledName = ComputeLogicalName id memberFlags",40],["| SynMemberSig.Member (_,memberFlags,_) when not memberFlags.IsDispatchSlot -> true",20],["match args, memberFlags.MemberKind  with",40],["let logicalMethId = ident (ComputeLogicalName memberId memberFlags,memberId.idRange)",40],["let memberFlags = {memberFlags with MemberKind = MemberKind.PropertyGet}",40]],"useCount":2104},{"word":"members","context":[["/// Add a set of members to a ProvidedTypeDefinition",37],["// members of the type",40],["// this variable for the implicit class constructor. For static members, we assert the type variables associated",38],["// members API",125],["members |> List.exists (function",120],["let members =",89],["/// Used to hide/filter members from super classes based on signature",72],["members",68],["// per spec, extension members in F1 keywords are qualified with definition class",51],["match members with",45]],"useCount":4510},{"word":"message","context":[["let message =",77],["testMessageDisplayReadModel readModel heading subHeading statusCode severity message",41],["// TEMP : Until any \"real\" code is added here (if ever), just emit a message",40],["message",57],["let mkObsoleteAttributeCustomAttributeData(message:string, isError: bool) =",57],["| Failure(message, _, _) -> Assert.Fail(message)",168],["| Failure(message, _, _) -> Assert.Fail(message)",168],["member AddObsoleteAttribute : message: string * ?isError: bool -> unit",190],["match message with",195],["// Emit a message to the NUnit console/log to record when this function is called.",40]],"useCount":3347},{"word":"metadata","context":[["/// The F#-defined custom attributes of the entity, if any. If the entity is backed by Abstract IL or provided metadata",34],["/// Get the flags as included in the F# binary metadata",40],["/// Indicate if this is a type definition backed by Abstract IL metadata.",34],["</metadata>",39],["/// Indicates that this DLL was compiled using the F# compiler and has F# metadata",38],["<metadata>",35],["/// Get the Abstract IL scope, nesting and metadata for this",34],["let metadata =",34],["/// then this _does_ include this documentation. If the entity is backed by Abstract IL metadata",34],["/// The XML documentation of the entity, if any. If the entity is backed by provided metadata",34]],"useCount":2502},{"word":"meth","context":[["| [meth]    -> meth :?> MethodInfo",63],["let gdtym = gdty.GetMethods() |> Seq.find (fun x -> x.Name = meth.Name)",58],["if meth.IsGenericMethod then",59],["elif meth.DeclaringType.IsGenericType then",59],["let meth =",147],["ProvidedMeth(amap, meth, None, m)",68],["ilg.Emit(OpCodes.Newobj, meth)",64],["| dty -> MethodBase.GetMethodFromHandle(meth.MethodHandle, dty.TypeHandle) :?> _",56],["| [meth]    -> meth :?> MethodInfo",63],["ilg.Emit(OpCodes.Call, meth)",63]],"useCount":2395},{"word":"method","context":[["// Eliminate F# property sets to method calls",64],["/// FSharp.Data addition: this method is used by Debug.fs",73],["// Eliminate F# property gets to method calls",64],["// method produced something, but we don't need it",64],["| _ -> failwithf \"unknown constant '%A' in generated method\" v",64],["/// static conversion method on the input type.</summary>",288],["[<CompilerMessage(\"This method is not intended for use from F#.\", 10001, IsHidden=true, IsError=false)>]",132],["Make sure each method works on:",111],["/// This operation is only supported on ordered series. The method throws",96],["// \"single named item\" rule. This is where we have a single accessible method",80]],"useCount":11393},{"word":"methods","context":[["methods",75],["(fun _ -> None) // We do not respect this attribute for provided methods",36],["// Base class methods",47],["(fun _ -> None) // We do not respect this attribute for IL methods",54],["// when comparing methods",61],["// This file contains a set of helper types and methods for providing types in an implementation",61],["// Emit the methods",64],["/// can be created using methods on the System.Array type.</summary>",64],["/// See the type provider spec for the methods that must be implemented.",68],["let methods =",81]],"useCount":4980},{"word":"mi","context":[["getInvokerExpression mi args",48],["let mi =",41],["verifyMethodInfoWasTaken mi",40],["| Quotations.Patterns.Call(inst, mi, args) ->",40],["mi.Invoke(null, args)",40],["mi.PUntaint((fun mi -> mi.IsVirtual), m)",34],["let mi = ArbitraryMethodInfoOfPropertyInfo pi m",51],["| ProvidedMeth(amap,mi,_,_) ->",34],["| ProvidedMeth(amap,mi,_,m) ->",97],["match mi with",78]],"useCount":2953},{"word":"minfo","context":[["match minfo with",361],["Quotations.Expr.Call(minfo, Array.toList parameters)",60],["pb.SetSetMethod (methMap.[minfo :?> ProvidedMethod ]))",63],["pb.SetGetMethod (methMap.[minfo :?> ProvidedMethod ])",63],["let minfo = pinfo.GetGetMethod(true)",64],["let minfo = pinfo.GetSetMethod(true)",64],["if minfo.IsStatic then",69],["| :? System.Reflection.MethodInfo as minfo ->",69],["let nm = minfo.LogicalName",97],["for minfo in ptd.GetMethods(ALL) do",104]],"useCount":7247},{"word":"minst","context":[["minfo, minst",24],["let retTy = minfo.GetFSharpReturnTy(amap, m, minst)",24],["let inst = GetInstantiationForMemberVal g x.IsCSharpStyleExtensionMember (typ,vref,minst)",68],["| FSMethSln(typ, vref,minst) ->",52],["| None -> minst",36],["mkILMethSpecInTyRaw (enclTyp, cc, nm, argtys, retty, minst)",36],["member x.GetCompiledReturnTy (amap, m, minst) =",34],["let (MethodData(enclTyp, cc, nm, argtys, retty, minst)) = seekReadMethodDefAsMethodData ctxt idx",32],["let minst = FreshenMethInfo m minfo",28],["let paramDatas = minfo.GetParamDatas(amap, m, minst)",25]],"useCount":2493},{"word":"model","context":[["let model =",466],["override this.InitModel model =",29],["model.TargetsFileFolders",29],["| _ -> model",33],["model.ReferenceFileFolders",33],["/// Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.",34],["/// Indicates if this is an F# type definition whose r.h.s. is known to be some kind of F# object model definition",34],["/// of an object model property.",38],["override this.SetBindings model =",49],["model",94]],"useCount":2498},{"word":"modref","context":[["if modrefs.Length > 0 && modrefs |> List.forall (fun modref -> modref.IsNamespace) then",40],["modref.ModuleOrNamespaceType.AllEntities",40],["|> List.map modref.NestedTyconRef",44],["let tcref = modref.NestedTyconRef tycon",48],["| Some(AccessibleEntityRef ncenv.amap m ad modref submodref) ->",60],["let mty = modref.ModuleOrNamespaceType",83],["if modrefs.Length > 0 && modrefs |> List.forall (fun modref -> modref.IsNamespace) then",40],["modrefs |> List.iter (fun (_,modref,_) ->",40],["modrefs |> List.iter (fun modref -> CheckEntityAttributes cenv.g modref m |> CommitOperationResult)",36],["modrefs |> List.iter (fun modref -> CheckEntityAttributes cenv.g modref m |> CommitOperationResult)",36]],"useCount":2851},{"word":"module","context":[["module Seq =",182],["module Nested =",184],["module program",196],["module Goat",198],["module Array =",200],["module List =",230],["module M =",289],["module TopLevel",290],["module Program",479],["module internal AssemblyVersionInformation =",1560]],"useCount":23358},{"word":"more","context":[["/// is detected, to allow more efficient processing of large arrays of uint16 constants.",40],["﻿// Learn more about F# at http://fsharp.org",78],["// See the 'F# Tutorial' project for more help.",208],["let elems = membersQueue |> Seq.toArray // take a copy in case more elements get added",63],["let elems = interfaceImplsDelayed |> Seq.toArray // take a copy in case more elements get added",60],["| _ -> failwith (sprintf \"There is more than one nested type called '%s' in type '%s'\" name this.FullName)",60],["more details.",57],["beginning of the box rather than 2 more columns to the right",54],["/// more recent language service work.",51],["﻿// Learn more about F# at http://fsharp.net",172]],"useCount":3072},{"word":"mref","context":[["let methB = envGetMethB emEnv mref",32],["| Some mref -> (resolveILMethodRef tdef mref).Access",34],["let consB = envGetConsB emEnv mref",32],["let resT  = convType cenv emEnv mref.ReturnType",32],["queryableTypeGetMethodBySearch cenv emEnv parentT mref",32],["let mref = mkILCtorMethSpecForTy(tref,[cenv.g.ilg.typ_Object]).MethodRef",40],["envBindMethodRef emEnv mref methB",32],["| ILScopeRef.Module mref -> mref.Name",31],["| Some mref -> (resolveILMethodRef tdef mref).Access",34],["| ILScopeRef.Module mref -> mref.Name",31]],"useCount":2525},{"word":"ms","context":[["let verNumber = ms.ReadInt64()",66],["use ms = new MemoryStream()",69],["use ms = new MemStream()",69],["let name = ms.ReadString()",75],["ms |> List.iter (patchUpAddedMemberInfo this) // strict: patch up now",45],["membersQueue.Add (fun () -> ms |> List.map (fun x -> x :> MemberInfo))",45],["ms.DecRef()",46],["let jobID = ms.ReadGuid()",52],["let ms = new MemStream()",55],["let pos = ms.Position",58]],"useCount":3980},{"word":"msg","context":[["failwith msg",461],["match msg with",658],["let msg =",317],["Logger.Log( LogLevel.Error, msg )",457],["let! msg = inbox.Receive()",178],["printfn \"%s\" msg",95],["System.Diagnostics.Debug.Assert(false, msg)",78],["msError.WriteString( msg )",69],["msg",74],["let se = new SerializationException(msg, e)",77]],"useCount":6282},{"word":"mspec","context":[["| Some mspec",32],["let innerParent = mkLocalModRef mspec",32],["mspec,ctps,mtps,paramInfos,retInfo",32],["emitInstrCall cenv emEnv ilG OpCodes.Callvirt tail mspec varargs",31],["mspec.Data.entity_modul_contents <- notlazy mtyp",30],["Method (topValInfo, vref, mspec, m, paramInfos, retInfo)",32],["let mtype = mspec.ModuleOrNamespaceType",38],["let env = AddLocalSubModule cenv.tcSink cenv.g cenv.amap m scopem env mspec",28],["let nargs = mspec.FormalArgTypes.Length",25],["| Method (topValInfo,vref,mspec,_,_,_) ->",32]],"useCount":4034},{"word":"mty","context":[["UpdateAccModuleOrNamespaceType cenv env (fun _ mty ->",40],["match mty.ExceptionDefinitionsByDemangledName.TryFind(id.idText) with",34],["(mty.AllValsAndMembers",34],["match mty.AllValsByLogicalName.TryFind(id.idText) with",34],["| TMAbstract(ModuleOrNamespaceExprWithSig(mty,_,_)) ->",34],["// Compute instances of the above for mexpr -> mty",38],["let vs = allValsOfModuleOrNamespaceTy mty",38],["let mty = modref.ModuleOrNamespaceType",83],["match mty.ModulesAndNamespacesByDemangledName.TryFind(id.idText) with",34],["mty.TypesByAccessNames.Values",45]],"useCount":1994},{"word":"must","context":[["/// When called on the server side, the handler must be a top-level function or a static member.",278],["if len < 0 then invalidArg \"len\" \"length must be positive\"",36],["// WARNING: this must match optimizeAlternativeToNull in ilx/cu_erase.fs",38],["// NOTE: this must be a tailcall",49],["/// arrays must have the same lengths, otherwise an <c>ArgumentException</c> is",57],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["/// See the type provider spec for the methods that must be implemented.",68],["// XML doc text that we only compute once, if any. This must _not_ be forced until the ConstructorArguments",64],["// the binding must have leaves that are themselves variables (due to the limited support for byrefs in expressions)",54]],"useCount":4169},{"word":"mutable","context":[["let mutable index = 0",167],["val mutable public sType : VkStructureType",150],["let mutable i = 0",677],["val mutable public pNext : nativeint",150],["let mutable disposed = false",133],["let mutable count = 0",216],["let mutable declaringType = null",245],["let mutable res = Unchecked.defaultof<_>",250],["let mutable state = state",271],["let mutable isStatic = false",125]],"useCount":25484},{"word":"n","context":[["n",398],["match n with",518],["if n <> 0 then",174],["match t.n with",201],["| Some n ->",158],["for i = 0 to n - 1 do",156],["| n ->",134],["let fullName = if fullName = \"\" then n else fullName + \".\" + n",116],["let fullName = if fullName = \"\" then n else fullName + \".\" + n",116],["[| n; n; n; n; |];",113]],"useCount":40770},{"word":"name","context":[["/// <param name=\"Color\">The color for the data.</param>",753],["/// <param name=\"Name\">The name of the data set.</param>",753],["/// <param name=\"YTitle\">The title of the Y-axis.</param>",753],["/// <param name=\"Name\">The name of the data set.</param>",753],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753],["/// <param name=\"Title\">The title of the chart.</param>",753],["/// <param name=\"array\">The input array.</param>",657],["/// <param name=\"value\">The input value.</param>",584],["/// <param name=\"source\">The input sequence.</param>",562],["name",511]],"useCount":54391},{"word":"names","context":[["/// <param name=\"names\">The identifiers at the location where the information is being requested.</param>",59],["let names =",46],["let args',acc = TcPatterns warnOnUpper cenv env vFlags (tpenv,names,takenNames) argtys args",42],["names",53],["#nowarn \"49\" // uppercase argument names",58],["(fun _ -> TPat_wild m), (tpenv,names,takenNames)",58],["(tpenv,names,takenNames)",62],["///  - `targets` - A string with the target names which should be run by MSBuild.",78],["// This type is used to give symbolic names to token indexes, useful for error messages",88],["// FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs",105]],"useCount":5428},{"word":"namespace","context":[["namespace FSharp.Core.Unittests.FSharp_Core.Microsoft_FSharp_Collections",97],["namespace FunScript.TypeScript",311],["namespace System",245],["namespace Microsoft.FSharp.Compiler.SourceCodeServices",123],["namespace Prajna.Core",120],["[\"namespace\"]);",110],["namespace Microsoft.FSharp.Collections",104],["namespace Microsoft.FSharp.Core",102],["namespace Microsoft.FSharp",100],["namespace FsCheck",99]],"useCount":8500},{"word":"ncenv","context":[["ncenv.InfoReader.GetRecordOrClassFieldsOfType(None,ad,m,typ)",45],["let typs = tcrefs |> List.map (fun (resInfo,tcref) -> (resInfo,FreshenTycon ncenv m tcref))",36],["let g = ncenv.g",200],["|> List.filter (IsTyconUnseen ad g ncenv.amap m >> not)",120],["ResolveLongIndentAsModuleOrNamespaceThen ncenv.amap m fullyQualified nenv ad lid",45],["let amap = ncenv.amap",68],["let typ = FreshenTycon ncenv m tcref",66],["|> List.filter (EntityRefContainsSomethingAccessible ncenv m ad)",64],["| Some(AccessibleEntityRef ncenv.amap m ad modref submodref) ->",60],["|> CollectResults (fun (resInfo,typ) -> ResolveObjectConstructorPrim ncenv nenv.eDisplayEnv resInfo id.idRange ad typ)",47]],"useCount":3160},{"word":"ndeep","context":[["let ndeep = ndeep + 1",42],["(TypesMustSubsumeOrConvertInsideUndo csenv ndeep (WithTrace newTrace) m)",42],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty1 ++ (fun () ->",98],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace argty2 argty1 ++ (fun () ->",78],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty ++ (fun () ->",70],["(loop (ndeep+1))",57],["List.lengthsEqAndForall2 (TypesFeasiblyEquiv ndeep g amap m) l1 l2",56],["(MustUnifyInsideUndo csenv ndeep newTrace)",42],["SolveDimensionlessNumericType csenv ndeep m2 trace argty1 ++ (fun () ->",42],["let ndeep = ndeep + 1",42]],"useCount":2684},{"word":"need","context":[["// REVIEW: consider if we need to show _cxs (the type parameter constrants)",204],["// REVIEW: need a better test for this",34],["// This does not need to be run on the background thread",34],["// Eliminate subsumption coercions for functions. This must be done post-typechecking because we need",34],["// We need a signature in terms of the values' type parameters.",40],["// SEQUENCE POINTS: need to build a let here consuming spBind",40],["/// If optKind=None, we need to determine the kind (we're in *synthesis* mode)",40],["// if we need result and method produce void and result should be unit - push null as unit value on stack",64],["// method produced something, but we don't need it",64],["// to COM components.  If you need to access a type in this assembly from",997]],"useCount":3660},{"word":"nenv","context":[["nenv.eFieldLabels",40],["|> CollectResults (fun (resInfo,typ) -> ResolveObjectConstructorPrim ncenv nenv.eDisplayEnv resInfo id.idRange ad typ)",47],["nenv",34],["let nenv =",38],["let nenv = envinner.NameEnv",40],["let env = ModifyNameResEnv (fun nenv -> AddValRefToNameEnv nenv (mkLocalValRef v)) env",40],["let env = ModifyNameResEnv (fun nenv -> AddValRefToNameEnv nenv (mkLocalValRef v)) env",40],["ResolveLongIndentAsModuleOrNamespaceThen ncenv.amap m fullyQualified nenv ad lid",45],["nenv.TyconsByDemangledNameAndArity(fullyQualified).Values",45],["{nenv with",51]],"useCount":4270},{"word":"nested","context":[["/// Create a new provided type definition, to be located as a nested type in some type definition.",37],["// No dotting through type generators to get to a nested type!",45],["/// Add a method, property, nested type or other member to a ProvidedTypeDefinition",37],["// nested types",48],["// OK, the implied nested type is not defined, define it now",59],["| _ -> failwith (sprintf \"There is more than one nested type called '%s' in type '%s'\" name this.FullName)",60],["/// Get a blob of data indicating how this type is nested inside other namespaces, modules and types.",63],["// Adjust the attributes - we're codegen'ing this type as nested",64],["// Adjust the attributes - we're codegen'ing as non-nested",64],["// Allow 'fake' nested types that are actually real .NET types",67]],"useCount":2154},{"word":"new","context":[["let sw = new System.Diagnostics.Stopwatch()",362],["use ts = new TransactionScope()",440],["let rnd = new System.Random()",110],["new StringBuilder()",128],["let sb = new StringBuilder()",195],["let cts = new CancellationTokenSource()",230],["{ new IDisposable with",242],["new-device",258],["{ new IProvidedCustomAttributeData with",329],["{ new CustomAttributeData() with",346]],"useCount":26854},{"word":"next","context":[["next,",397],["next",147],["match next with",73],["r@ tis-next-char",54],["let next =",54],["next()",38],["next env : 'Tail",50],["// next up is the FROM statement which includes joins ..",46],["// next up is the filter expressions",41],["let chunk sz next = ({addr=next; size=sz},next + sz)",37]],"useCount":5476},{"word":"nm","context":[["let s1,s2 = splitNameAt nm idx",76],["errorR(Error(FSComp.SR.tcInvalidRelationInJoin(nm.idText),relExpr.Range))",72],["match nm with",78],["let nm = readBlobHeapAsTypeName ctxt (nameIdx,namespaceIdx)",90],["let nm = minfo.LogicalName",97],["{ Name=nm;",119],["let nm = readStringHeap ctxt nameIdx",144],["let nm =",178],["match tryGetDataForCustomOperation nm with",180],["nm",102]],"useCount":17290},{"word":"no","context":[["| TypeCode.SByte -> () // no op",50],["s\" No data available\"  exception constant exp-no-data            ( -- n = No data available exception number )",44],["if v.Count = 0 then   // if no columns exist in the projection then get everything",46],["/// Return <c>None</c> if no such element exists.</summary>",47],["/// <exception cref=\"Soma.Core.NoAffectedRowException\">Thrown when there is no affected row.</exception>",48],["/// large or infinite sequences. The function makes no assumption on the ordering of the original",48],["| None -> failwith (sprintf \"ProvidedConstructor: no invoker for '%s'\" (nameText()))",60],["//failwith \"no file system\"",59],["| None -> wordL \"<no global g>\"",57],["// initially supporting update/create/delete of single entities, no hierarchies yet",56]],"useCount":6610},{"word":"node","context":[["member this.Node = node",164],["| Some node -> node",100],["match node with",364],["node",333],["node.ParentNode.RemoveChild node |> ignore",127],["node.ParentNode.RemoveChild node |> ignore",127],["|> List.filter (fun node ->",116],["| Some node -> node.InnerText",112],["| Some node -> node.InnerText",112],["| Some node -> node",100]],"useCount":6992},{"word":"nodes","context":[["// one of the nodes must have height > height t1 + 1",29],["// as we process nodes top-to-bottom, this matches the",25],["// one of the nodes must have height > height t2 + 1",27],["let nodes =",119],["tips @ nodes",77],["match nodes with",46],["// Construct syntactic AST nodes",42],["nodes",40],["verbosefn \"    - Deleting Paket %s nodes\" name",29],["/// Launching Prajna Service on a group of remote nodes.",36]],"useCount":1902},{"word":"non","context":[["| _ -> Some CompletionContext.Invalid // non-matching attributes",30],["/// defines a measure type with a relation to an existing non-measure type as a representation.",34],["// For non-generic type providers there is no difference",34],["///Build a generator that generates a value from one of the generators in the given non-empty seq, with",35],["// by looking at List.Head we are letting the intrinsics determine indexed/non-indexed",36],["// non-local values do not contain free variables",38],["/// This is used to typecheck legitimate 'non-main body of object constructor' expressions",40],["// this is because non-identity columns will have been set",30],["// Find all the items with a non-empty key list. Bucket them together by",79],["// Adjust the attributes - we're codegen'ing as non-nested",64]],"useCount":3332},{"word":"normalizeLineEndings","context":[["|> normalizeLineEndings",119],["let s2 = File.ReadAllText newFile |> normalizeLineEndings",514],["let s1 = File.ReadAllText oldFile |> normalizeLineEndings",514],["|> shouldEqual (normalizeLineEndings expected)",317],["let s2 = File.ReadAllText newWeavers |> normalizeLineEndings",116],["let s1 = File.ReadAllText oldWeavers |> normalizeLineEndings",116],["let config = File.ReadAllText(configPath) |> normalizeLineEndings",21],["File.ReadAllText newLockFilePath |> normalizeLineEndings |> shouldEqual expected",44],["let normalizeLineEndings (text : string) =",24],["|> shouldEqual (normalizeLineEndings result)",25]],"useCount":1963},{"word":"not","context":[["// Setting ComVisible to false makes the types in this assembly not visible",997],["if not success then",205],["(* Member of type 'CodeTypeConstructor' is not supported by the CodeDOM provider and was omitted *)",189],["[<CompilerMessage(\"This method is not intended for use from F#.\", 10001, IsHidden=true, IsError=false)>]",132],["if not res then",122],["|> List.filter (IsTyconUnseen ad g ncenv.amap m >> not)",120],["|> not",113],["//member __.ShouldSerializerole() = not _role.IsNone",95],["member this.DeclaringTypeImpl with set x = declaringType <- x // check: not set twice",214],["Assert.Ignore \"Test not yet implemented.\"",592]],"useCount":49104},{"word":"notRequired","context":[["override this.GetBaseDefinition()                                  = notRequired \"GetBaseDefinition\" this.Name",85],["override this.IsDefined(_attributeType, _inherit)             = notRequired \"IsDefined\" this.Name",169],["override this.GetCustomAttributes(_attributeType, _inherit)   = notRequired \"GetCustomAttributes\" this.Name",169],["override this.GetCustomAttributes(_inherit)                  = notRequired \"GetCustomAttributes\" this.Name",169],["override this.ReflectedType                                     = notRequired \"ReflectedType\" this.Name",168],["override this.Invoke(_obj, _invokeAttr, _binder, _parameters, _culture) = notRequired \"Invoke\" this.Name",85],["override this.GetCustomAttributes(_inherit)                     = notRequired \"GetCustomAttributes\" this.Name",85],["override this.ReturnTypeCustomAttributes                           = notRequired \"ReturnTypeCustomAttributes\" this.Name",85],["override this.ReflectedType                                        = notRequired \"ReflectedType\" this.Name",85],["override this.GetCustomAttributes(_attributeType, _inherit)      =  notRequired \"GetCustomAttributes\" this.Name",85]],"useCount":3287},{"word":"nowarn","context":[["#nowarn \"57\" // do not use create_DelegateEvent",58],["#nowarn \"67\" // this type test or downcast will always hold",59],["#nowarn \"44\" // This construct is deprecated. please use List.item",72],["#nowarn \"51\"",143],["#nowarn \"444\"",161],["#nowarn \"9\"",243],["#nowarn \"58\" // possible incorrect indentation..",58],["#nowarn \"51\" // address-of operator can occur in the code",58],["#nowarn \"49\" // uppercase argument names",58],["#nowarn \"40\"",182]],"useCount":1905},{"word":"ns","context":[["ns,",43],["| Some ns ->",139],["((None,\"\"),ns) ||> List.fold (fun (otb:TypeBuilder option,fullName) n ->",58],["(\"\",ns) ||> List.fold (fun fullName n ->",58],["ns = Some \"Myns\"",48],["match ns with",41],["| Some (ns, unitName) ->",37],["ns = Some \"TopNs\"",35],["vec4 x_ = floor(j * ns.z);",32],["let node = XElement(ns + name)",32]],"useCount":2370},{"word":"nuget","context":[["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://nuget.org/api/v2",139],["nuget FAKE\"\"\")",139],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://www.nuget.org/api/v2",147],["nuget Castle.Core-log4net",149],["nuget NUnit",151],["remote: http://www.nuget.org/api/v2",152],["source \"http://www.nuget.org/api/v2\"",165],["source http://www.nuget.org/api/v2",168],["source https://www.nuget.org/api/v2",137],["nuget FAKE",296]],"useCount":7654},{"word":"null","context":[["let nullArr = null:string[]",262],["let mutable declaringType = null",245],["null",1240],["| null -> None",670],["| null ->",668],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518],["// null array",508],["// null Seq",474],["| null -> ()",376],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324]],"useCount":20612},{"word":"number","context":[["// Only apply this rule if a candidate method exists with this number of arguments",40],["// being accessed we know the number of arguments the first class use of this",40],["s\" Index out of range\" exception constant exp-index-out-of-range ( -- n = Index out of range exception number )",44],["| MaxResults(_) -> \"Maximum number of results.\"",44],["s\" No data available\"  exception constant exp-no-data            ( -- n = No data available exception number )",44],["s\" Invalid state\"      exception constant exp-invalid-state      ( -- n = Invalid state exception number )",44],["s\" Invalid data\"       exception constant exp-invalid-data       ( -- n = Invalid data exception number )",47],["// A huge number of these occur in pickled F# data, so make them unique",52],["/// <param name=\"timeout\">Defines time window for number of retries to occur.</param>",54],["/// <param name=\"line\">The line number where the information is being requested.</param>",59]],"useCount":3800},{"word":"numtypars","context":[["let typ, sigptr = sigptrGetTy ctxt numtypars bytes sigptr",108],["let retty,sigptr = sigptrGetTy ctxt numtypars bytes sigptr",54],["let enclTyp = seekReadMethodRefParent ctxt numtypars mrpIdx",36],["let typ = seekReadTypeDefOrRef ctxt numtypars AsObject ILList.empty (uncodedTokenToTypeDefOrRefOrSpec uncoded)",28],["let numtypars = typars.Length",22],["let typ, sigptr = sigptrGetTy numtypars bytes sigptr",20],["and seekReadMemberRefAsFieldSpecUncached ctxtH (MemberRefAsFspecIdx (numtypars,idx)) =",18],["let events = seekReadEvents ctxt numtypars idx",18],["| tag when tag = mrp_TypeSpec -> readBlobHeapAsType ctxt numtypars (seekReadTypeSpecRow ctxt idx)",18],["and seekReadGenericParamConstraintsUncached ctxt numtypars gpidx =",18]],"useCount":2062},{"word":"o","context":[["| Some o -> trans (Quotations.Expr.Call(trans o,propInfo.GetGetMethod(),args))",54],["member this.OnNext( o ) =",68],["o",143],["match o with",636],["| Some o -> trans (Quotations.Expr.Call(trans o,propInfo.GetGetMethod(),args))",54],["and transList(o, ty : Type, nil, cons) =",55],["for el in o do",55],["o <- res",62],["override x.Equals o =",57],["let rec transArray (o : Array, ty : Type) =",56]],"useCount":3545},{"word":"obj","context":[["/// <param name=\"obj\">The input object.</param>",102],["match obj with",728],["if Utils.IsNull obj then",113],["override x.Equals(other : obj) =",108],["override t.CompareTo (other:obj,comparer:System.Collections.IComparer) =",72],["override this.GetValue(_obj) : obj = notRequired \"GetValue\" this.Name",84],["{ new obj() with",88],["override x.Equals(obj:obj) =",103],["override x.Equals(obj:obj) =",103],["override this.Equals(that:obj) =",94]],"useCount":10114},{"word":"object","context":[["/// <param name=\"obj\">The input object.</param>",102],["/// This is used to typecheck legitimate 'non-main body of object constructor' expressions",40],["// Note: static calls never mutate a struct object argument",40],["object class",42],["// This function gets the data carried by a token as an object",43],["/// Retrieve object info from the Factory class.",45],["/// for the CustomAttributeData object.",64],["/// of an object model property.",38],["// Return the disposable object that cleans up",76],["//let mutable _role: string option = Some \"object\"",95]],"useCount":4231},{"word":"of","context":[["/// <summary>Creates an instance of the attribute</summary>",427],["// This file is part of WebSharper",342],["// set of attributes. Change these attribute values to modify the information",1064],["\\ This file is part of Gforth.",664],["/// <param name=\"Name\">The name of the data set.</param>",753],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753],["/// <param name=\"YTitle\">The title of the Y-axis.</param>",753],["/// <param name=\"Title\">The title of the chart.</param>",753],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["// Version information for an assembly consists of the following four values:",1046]],"useCount":106248},{"word":"ofList","context":[["|> Map.ofList",426],["box <| NameValueLookup.ofList [",78],["|> Seq.ofList",79],["] |> List.map Guid.Parse |> Set.ofList",85],["Map.ofList",92],["\"ofType\", upcast NameValueLookup.ofList [",126],["\"type\", upcast NameValueLookup.ofList [",129],["upcast NameValueLookup.ofList [",177],["|> Set.ofList",459],["|> Array.ofList",207]],"useCount":4812},{"word":"ofSeq","context":[["|> List.ofSeq",791],["|> Map.ofSeq",597],["|> Set.ofSeq",563],["|> Array.ofSeq",308],["let valueKeyMap = Map.ofSeq [(2,\"b\"); (3,\"c\"); (4,\"d\"); (5,\"e\")]",133],["let oeleMap = Map.ofSeq [(1, \"one\")]",126],["let refMap = Map.ofSeq [for c in [\".\"; \"..\"; \"...\"; \"....\"] do yield (c, c.Length) ]",126],["let r = d.ToSeq() |> Array.ofSeq |> Array.sort",65],["let rest = List.ofSeq (Seq.skip 7 args)",61],["let q = ofSeq [\"a\";\"b\";\"c\";\"d\"]",60]],"useCount":4135},{"word":"offset","context":[["/// <param name=\"offset\">The offset. Nagative value means zero.</param>",90],["/// <param name=\"offset\">The offset. Nagative value means zero.</param>",90],["breaks,layout,pos,offset",44],["let mutable offset = 0",38],["/// <summary>Paginates the rows, and counts rows without the offset and the limit.</summary>",36],["processWhiteAndComment str offset delay cont )",34],["Printf.sprintf \"Variable lookup failure: offset: %d, ctx size: %d\"",96],["bytesToDWord(buffer.[offset+4], buffer.[offset+5], buffer.[offset+6], buffer.[offset+7]), // TimeDateStamp",32],["bytesToDWord(buffer.[offset+4], buffer.[offset+5], buffer.[offset+6], buffer.[offset+7]), // TimeDateStamp",32],["bytesToDWord(buffer.[offset+4], buffer.[offset+5], buffer.[offset+6], buffer.[offset+7]), // TimeDateStamp",32]],"useCount":4310},{"word":"ok","context":[["// if exist test.ok (del /f /q test.ok)",92],["|> ok",52],["// if NOT EXIST test.ok goto SetError",66],["gzi.ok",69],["ok",76],["if ok then res else",78],["let ok =",87],["// if exist test.ok (del /f /q test.ok)",92],["if ok then res",99],["if ok then",183]],"useCount":2558},{"word":"omit","context":[["﻿/// [omit]",11],["///   omit or erase these nodes then no debug info will be emitted for local",14],["| OmitContent omit -> { current.Options with Settings = { current.Options.Settings with OmitContent = Some omit } }",17],["| OmitContent omit -> { current.Options with Settings = { current.Options.Settings with OmitContent = Some omit } }",17],["checker = None;}; {omit = false;",18],["body = PSeq ([{omit = false;",40],["omit = false",181],["/// [omit]",1894]],"useCount":2192},{"word":"on","context":[["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// <param name=\"data\">The data for the chart. Each observation replaces the entire data on the chart.</param>",224],["/// static conversion method on the input type.</summary>",288],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["on two lines.",113],["Make sure each method works on:",111],["// Always allow subsumption on assignment to fields",100],["// Run InferTyconKind to raise errors on inconsistent attribute sets",100],["// COM, set the ComVisible attribute to true on that type.",997]],"useCount":18739},{"word":"one","context":[["// If the result is the same (physical equality) to one of the inputs,",36],["let oeleMap = Map.ofSeq [(1, \"one\")]",126],["// Allow at most one constructor, and use its arguments as the fields of the type",64],["/// Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll which uses",34],["| _ -> failwith (sprintf \"There is more than one nested type called '%s' in type '%s'\" name this.FullName)",60],["| _ -> failwith \"at most one implicit constructor allowed\"",59],["// of which there can be many. Simply turn them all into one big AND expression as that is the",46],["// Because there is only one accessible method info available based on the name of the item",40],["// We only count one argument block for these.",36],["///Build a generator that generates a value from one of the generators in the given non-empty seq, with",35]],"useCount":5538},{"word":"only","context":[["// MUTABILITY; used only during creation and remapping of tycons",76],["// XML doc text that we only compute once, if any. This must _not_ be forced until the ConstructorArguments",64],["/// The actor can only be used locally.",59],["/// This operation is only supported on ordered series. The method throws",96],["// convert NewTuple to the call to the constructor of the Tuple type (only for generated types)",60],["// convert TupleGet to the chain of PropertyGet calls (only for generated types)",61],["/// It is important that the text of the xml doc only get forced when poking on the ConstructorArguments",64],["// Custom atttributes that we only compute once",64],["/// Computation expressions only",85],["// optimized mutation-based implementation. This code is only valid in fslib, where mutation of private",114]],"useCount":7532},{"word":"op","context":[["| Expr.Op(op,tyargs,args,m) ->",60],["true to prefix-op",33],["| Expr.Op (op,tinst,args,_) ->",38],["match op,tyargs,args with",43],["let build op preds (rest:Condition list option) =",46],["let prefix = if i>0 then (sprintf \" %s \" op) else \"\"",46],["| TypeCode.SByte -> () // no op",50],["x.Emit(op,v)",128],["~~ (sprintf \" %s \" op)",184],["match op with",377]],"useCount":2368},{"word":"open","context":[["open System.Text",2206],["open System.Threading",2129],["open System.Diagnostics",2178],["open System",18368],["open System.Runtime.CompilerServices",2445],["open System.Runtime.InteropServices",2660],["open NUnit.Framework",4596],["open System.Collections.Generic",5952],["open System.Reflection",6185],["open System.IO",7314]],"useCount":159557},{"word":"operation","context":[["// Record the resolution of the custom operation for posterity",36],["// we've already reported error now we can use operands of binary operation as join components",36],["/// primitive numeric types. The operation requires an appropriate",44],["/// <remarks>Performs the operation in parallel using System.Threading.Parallel.For.",56],["/// This operation is only supported on ordered series. The method throws",96],["// this is not correct JoinRelation but it is still binary operation",36],["#nowarn \"52\" // The value has been copied to ensure the original is not mutated by this operation",41],["/// <returns>The result of the operation.</returns>",149],["/// with InvariantCulture settings. Otherwise the operation requires an appropriate",202],["/// primitive numeric types. Otherwise the operation requires an appropriate",42]],"useCount":2310},{"word":"option","context":[["let mutable invokeCode    = None : option<Quotations.Expr list -> Quotations.Expr>",104],["Description : string option",71],["VersionNo : int option }",80],["EmployeeId : int option",80],["DepartmentId : int option",82],["EmployeeName : string option",82],["/// <param name=\"option\">The input option.</param>",84],["/// <param name=\"option\">The input option.</param>",84],["//let mutable _role: string option = Some \"object\"",95],["SynAccess option *",130]],"useCount":14546},{"word":"optional","context":[["// Layout an optional argument",60],["/// <param name=\"timeout\">An optional timeout parameter (in milliseconds) to wait for a reply message.",28],["let optional =",29],["/// Working directory (optional).",29],["/// parameter is an optional name to restrict the set of properties returned.",32],["// Handle optional arguments",40],["/// types of optional arguments for function and member signatures.",40],["| ProjectInfo(core, optional) ->",33],["// detect parameter type, if ptyOpt is None - this is .NET style optional argument",30],["| CompleteInfo(core, optional) ->",33]],"useCount":2335},{"word":"options","context":[["checkOption options.OtherOptions \"--targetprofile:netcore\"",55],["let options =  checker.GetProjectOptionsFromCommandLineArgs (projFileName, args)",408],["let options =",281],["/// <param name=\"Options\">The chart's options.</param>",159],["let wholeProjectResults = checker.ParseAndCheckProject(Project1.options) |> Async.RunSynchronously",127],["let options = defaultArg Options <| Configuration.Options()",119],["options",72],["let props = applySpawnOptions (Props.Create e) options",64],["match options with",57],["let wholeProjectResults = checker.ParseAndCheckProject(Project4.options) |> Async.RunSynchronously",55]],"useCount":6878},{"word":"opts","context":[["let fvs = accFreevarsInVal opts v fvs",38],["accFreeInType opts typ",38],["let acc = accFreeInDecisionTree opts dtree acc",34],["if not opts.includeLocals then fvs else",38],["if not opts.includeLocalTycons then acc else",38],["match opts with",39],["opts",52],["(accFreeVarsInTys opts tys",57],["let opts =",120],["let opts source =",29]],"useCount":7418},{"word":"or","context":[["// You can specify all the values or you can default the Build and Revision Numbers",1037],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["// Otherwise, assume this is a generative assembly and just emit a call to the constructor or method",63],["/// Represents an array or other symbolic type involving a provided type as the argument.",68],["/// <param name=\"actorFactory\">Either actor system or parent actor</param>",71],["///  - `projects` - A list of project or solution files.",72],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["or",219],["// or",167],["/// Get or set a flag indicating if the property is static.",108]],"useCount":17860},{"word":"order","context":[["select * from Employee order by EmployeeId",120],["/// Describes the sequence order of the introduction of an extension method. Extension methods that are introduced",32],["/// Get a field by index in definition order",34],["let order (eltOrder: IComparer<'T>) =",36],["/// Note: result is a indexed table, and for each name the results are in reverse declaration order",37],["/// <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved.",36],["/// Note: result is alphabetically sorted, then for each name the results are in declaration order",37],["// This helps avoid issues with mutable state which arise because unit tests can run in any order.",40],["/// The order in which the given function is applied to elements of the input array is not specified.</remarks>",42],["let x = order.[i]",45]],"useCount":2713},{"word":"org","context":[["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://nuget.org/api/v2",139],["source https://www.nuget.org/api/v2",137],["source \"http://nuget.org/api/v2\"",134],["remote: http://nuget.org/api/v2",132],["remote: https://www.nuget.org/api/v2",111],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://www.nuget.org/api/v2",147],["remote: http://www.nuget.org/api/v2",152],["source \"http://www.nuget.org/api/v2\"",165],["source http://www.nuget.org/api/v2",168],["source http://nuget.org/api/v2",107]],"useCount":3171},{"word":"os","context":[["OutputExceptionR os e",118],["bufs (fun os ->",135],["output_string os \" \";",229],["writeInt32 os 0x00",96],["writeInt32 os 0x00;",84],["output_volatility os vol;",70],["output_alignment os al;",56],["let os = System.Text.StringBuilder()",54],["output_string os \",\";",50],["let os = StringBuilder()",49]],"useCount":10992},{"word":"other","context":[["override x.Equals(other : obj) =",108],["override t.CompareTo(other:obj) =",72],["override t.CompareTo (other:obj,comparer:System.Collections.IComparer) =",72],["override t.Equals(other:obj) =",72],["/// Represents an array or other symbolic type involving a provided type as the argument.",68],["let other = new OtherTree<_>(mAst)",68],["/// Get a blob of data indicating how this type is nested inside other namespaces, modules and types.",63],["override t.Equals (other:obj,comparer:System.Collections.IEqualityComparer) =",63],["box x === other ||",108],["match other with",511]],"useCount":5979},{"word":"out","context":[["// Check it isn't ruled out by the user",54],["out vec4 color;",236],["out vec4 fragColor;",244],["testEventTrigger tagger.TagsChanged \"Timed out before tags changed\" timeout",183],["// Filter out the additional TypeProviderTypeAttributes flags",123],["out vec4 FragColor;",101],["out vec4 FragmentColor;",98],["out vec4 outColor;",64],["let out = List<_>()",58],["out vec4 Fragment;",52]],"useCount":5825},{"word":"output","context":[["let output =",66],["/// Called by the evaluation session to ask the host for parameters to format text for output",60],["let output = getOutputDir()",47],["///  - `archiveFile` - The output archive file. If existing, will be overwritten.",40],["/// Builds the given project files or solution files and collects the output files.",39],["/// [category:Input and output]",69],["output",74],["// FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs",105],["/// Called by the evaluation session to ask the host for parameters to format text for output",110],["let fileNames = Directory.GetFiles(output)",38]],"useCount":2761},{"word":"over","context":[["///Map the given function over values to a function over generators of those values.",50],["// The basic iteration over the declarations in a single type definition",36],["// Skip over 'let' and 'do' bindings",36],["over 0< IF",48],["over swap",26],["MalVector new swap over MalVector/list ! ;;",27],["//     - show types before over other related items - they usually have very useful XmlDocs",27],["// Continue folding over the remaining array elements.",34],["/// Folds over the bindings in the map.",40],["///Map the given function over values to a function over generators of those values.",50]],"useCount":2159},{"word":"overallTy","context":[["TcExpr cenv overallTy env tpenv expr",54],["//solveTypAsError cenv env.DisplayEnv m overallTy",39],["let e1',tpenv = TcExpr cenv overallTy env tpenv e1",36],["UnifyTypes cenv env mStmt overallTy cenv.g.unit_ty",126],["let bodyExpr,tpenv = bodyChecker overallTy envinner tpenv body",37],["CallExprHasTypeSink cenv.tcSink (m,env.NameEnv,overallTy, env.DisplayEnv,env.eAccessRights)",108],["UnifyTypes cenv env m overallTy cenv.g.unit_ty",87],["UnifyTypes cenv env m tgty overallTy",36],["TcExprThen cenv overallTy env tpenv e1 [DelayedDotLookup(longId,mExprAndDotLookup)]",36],["TcLongIdentThen cenv overallTy env tpenv lidwd [ ]",36]],"useCount":3205},{"word":"override","context":[["override this.ReflectedType                                     = notRequired \"ReflectedType\" this.Name",168],["override x.ToString () =",155],["override x.Finalize() =",166],["override x.GetHashCode() =",156],["override this.GetCustomAttributes(_attributeType, _inherit)   = notRequired \"GetCustomAttributes\" this.Name",169],["override this.IsDefined(_attributeType, _inherit)             = notRequired \"IsDefined\" this.Name",169],["override this.GetCustomAttributes(_inherit)                  = notRequired \"GetCustomAttributes\" this.Name",169],["override x.ToString() =",1024],["override this.ToString() =",631],["override this.GetCustomAttributesData()                 = customAttributesImpl.GetCustomAttributesData()",311]],"useCount":24247},{"word":"p","context":[["|> invokeEventive p",126],["| Some p -> p",132],["let exec p = Command.exec dir cfg.EnvironmentVariables { Output = Inherit; Input = None; } p >> checkResult",118],["let exec p = Command.exec dir cfg.EnvironmentVariables { Output = Inherit; Input = None; } p >> checkResult",118],["for p in persons do",129],["| Some p -> p",132],["Eventive (fun p ->",183],["let p =",151],["match p with",737],["p",297]],"useCount":24551},{"word":"p_byte","context":[["| ILType.TypeVar n                -> p_byte 7 st; p_uint16 n st",12],["| I_ldsfld (a,b)                  -> p_byte itag_ldsfld st;      p_tup2 p_ILVolatility p_ILFieldSpec (a,b) st",12],["| TDBind (a,b)       -> p_byte 2 st; p_tup2 p_bind p_dtree (a,b) st",12],["| VRefLocal x    -> p_byte 0 st; p_local_item_ref ctxt st.ovals x st",12],["| TOp.LValueOp (a,b)             -> p_byte 17 st; p_tup2 p_lval_op_kind (p_vref \"lval\") (a,b) st",12],["p_byte (match x with",72],["let p_byte b st = st.os.EmitIntAsByte b",17],["p_byte 0xFF st;",17],["let p_bool b st = p_byte (if b then 1 else 0) st",17],["p_byte 2 st",13]],"useCount":2077},{"word":"package","context":[["/// Extracts the given package to the ./packages folder",57],["ZipFile.ExtractToDirectory(package, outPath)",54],["| Nuget(_) -> \"NuGet package id.\"",66],["| Some package ->",68],["/// Adds the given package with the given version to the dependencies file.",84],["/// Removes the given package from dependencies file.",48],["/// Updates the given package.",48],["active-package!",43],["| Source(_) -> \"Allows to specify the package source feed.\"",46],["| Version(_) -> \"Allows to specify version of the package.\"",46]],"useCount":4835},{"word":"packageName","context":[["let packageName = results.GetResult <@ AddArgs.Nuget @>",27],["tracefn \"Updating %O in %s group %O\" packageName dependenciesFileName groupName",27],["packageName",65],["return parseODataDetails(nugetURL,packageName,version,raw)",54],["traceWarnfn \"%s doesn't contain package %O in group %O. ==> Ignored\" fileName packageName groupName",30],["{ Name = packageName",30],["let! result = NuGetV3.GetPackageDetails force nugetSource packageName version",32],["let groupName,packageName = kv.Key",36],["let name = packageName.GetCompareString()",30],["match tryFindPackageLine groupName packageName with",30]],"useCount":2647},{"word":"packages","context":[["let packages =",109],["| Force -> \"Forces the download and reinstallation of all packages.\"",92],["#r \"../../packages/NUnit.2.6.3/lib/nunit.framework.dll\"",71],["| Redirects -> \"Creates binding redirects for the NuGet packages.\"",69],["/// Extracts the given package to the ./packages folder",57],["packages.Length |> shouldEqual 1",43],["| Keep_Major -> \"Allows only updates that are not changing the major version of the NuGet packages.\"",42],["let packages = List.rev lockFile.Packages",126],["#r \"../../packages/NUnit/lib/nunit.framework.dll\"",184],["packages",125]],"useCount":2894},{"word":"paket","context":[["let lockFile = LockFile.LoadFrom(Path.Combine(scenarioTempPath \"i001018-legacy-groups-update\",\"paket.lock\"))",28],["/// Restores the given paket.references files.",54],["/// Pulls new paket.targets and bootstrapper and puts them into .paket folder.",24],["/// Restores packages for all available paket.references files",24],["| No_Install -> \"Skips paket install --hard process afterward generation of dependencies / references files.\"",42],["paket \"install\" scenario |> ignore",40],["let lockFile = LockFile.LoadFrom(Path.Combine(scenarioTempPath \"i001178-update-with-regex\",\"paket.lock\"))",29],["{ ToolPath = (findToolFolderInSubPath \"paket.exe\" (currentDirectory @@ \".paket\")) @@ \"paket.exe\"",29],["{ ToolPath = (findToolFolderInSubPath \"paket.exe\" (currentDirectory @@ \".paket\")) @@ \"paket.exe\"",29],["{ ToolPath = (findToolFolderInSubPath \"paket.exe\" (currentDirectory @@ \".paket\")) @@ \"paket.exe\"",29]],"useCount":1896},{"word":"param","context":[["/// </param>",825],["/// <param name=\"Name\">The name of the data set.</param>",753],["/// <param name=\"Name\">The name of the data set.</param>",753],["/// <param name=\"Color\">The color for the data.</param>",753],["/// <param name=\"Color\">The color for the data.</param>",753],["/// <param name=\"Title\">The title of the chart.</param>",753],["/// <param name=\"YTitle\">The title of the Y-axis.</param>",753],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753],["/// <param name=\"YTitle\">The title of the Y-axis.</param>",753],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753]],"useCount":55202},{"word":"parameter","context":[["// to prevent unused parameter warning",36],["failwith \"unknown parameter/field\"",63],["if types      <> null then failwith \"Need to handle specified parameter types in GetPropertyImpl\"",60],["/// <param name=\"expr\">The name of the parameter, expressed as quotation of DU constructor.</param>",59],["else error fi \"parameter type mismatch\"",42],["/// Represents an erased provided parameter",40],["/// Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control",84],["/// <param name=\"y\">The second parameter.</param>",150],["/// <param name=\"x\">The first parameter.</param>",150],["// REVIEW: consider if we need to show _cxs (the type parameter constrants)",204]],"useCount":3909},{"word":"parameters","context":[["parameters",322],["/// Abstract a type to a parametric-type. Requires \"formal parameters\" and \"instantiation function\".",83],["let parameters =",288],["info.FileName <- parameters.ToolPath",169],["info.Arguments <- args) parameters.TimeOut",142],["m.GetInvokeCodeInternal false parameters",120],["///  - `setParams` - Function used to manipulate the WiX default parameters.",113],["/// Called by the evaluation session to ask the host for parameters to format text for output",110],["/// Get ParameterInfo[] for the parametric type parameters (//s GetGenericParameters)",83],["info.WorkingDirectory <- parameters.WorkingDir",83]],"useCount":10473},{"word":"parent","context":[["let vis,_ = ComputeAccessAndCompPath env None m vis parent",40],["if not parent.HasChildNodes then",34],["parent.ParentNode.RemoveChild parent |> ignore)",34],["parent.ParentNode.RemoveChild parent |> ignore)",34],["let vis = CombineReprAccess parent vis",60],["parent",34],["/// Get the actual parent entity for the value (a module or a type), i.e. the entity under which the",32],["/// <param name=\"actorFactory\">Either actor system or parent actor</param>",71],["let parent = node.ParentNode",74],["match parent with",135]],"useCount":3259},{"word":"parse","context":[["\"\"\"Failed to parse input as JSON",40],["with e -> (* errorR(Failure(\"parse failed\")); *) errorRecovery e rangeStartup; None",40],["parse {",41],["| _ -> failwithf \"could not parse version range \\\"%s\\\"\" text",43],["[char] \" parse",44],["/// parse including the reconstructed types in the file.",46],["| None -> failwithf \"unable to parse %s\" node.Name",47],["let statement = Sql.parse sql",54],["static member parse =",123],["[<Obsolete (\"Use parse instead.\")>]",61]],"useCount":3032},{"word":"parseState","context":[["(fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->",2648],["(fun (parseState : Internal.Utilities.Text.Parsing.IParseState) ->",1046],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : Ast.SynExpr)) in",43],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : int)) in",46],["let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : int)) in",47],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'opt_attributes)) in",56],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",195],["let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",115],["let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : 'recover)) in",57],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : SynExpr)) in",63]],"useCount":5809},{"word":"parser","context":[["let parser =",44],["|> parser.CreateParseResultsOfList",96],["match run path parser with",88],["return! parser {",60],["// Signature file for parser generated by fsyacc",53],["// This type is the type of tokens accepted by the parser",52],["|> parser.ToParseResults",48],["// Implementation file for parser generated by fsyacc",41],["parser {",37],["open parser",36]],"useCount":1929},{"word":"part","context":[["// This file is part of",41],["\\ This file is part of Gforth.",664],["/*  This file is part of Visualization Library                                        */",98],["This file is part of OpenSpades.",87],["// This file is part of WebSharper",342],["// This file is part of WebSharper",76],["//  This file is part of YaccConctructor.",68],["// This file is a part of Aivika for .NET",62],["// This file is a part of Aivika for .NET",57],["//    This file is part of F-AI.",42]],"useCount":3335},{"word":"pat","context":[["match pat' with",41],["let _,_,vspecs,envinner,_ = TcMatchPattern cenv (NewInferenceType()) env tpenv (pat,None)",54],["walkPat pat",56],["let m = pat.Range",38],["then match p.pat with",25],["/// F# syntax: fun pat -> expr",21],["/// F# syntax: let pat = expr in expr",21],["let mPat = pat.Range",21],["match pat with",230],["if subL <= dif && (((%% genComparator pat):array<byte> -> int -> bool) s i)",60]],"useCount":3006},{"word":"path","context":[["| SymbolKind.FSharpTypeAbbreviation (_,_,path),_ -> path.[path.Length-1]",53],["| SymbolKind.FSharpTypeAbbreviation (_,_,path),_ -> path.[path.Length-1]",53],["match path with",283],["let path =",195],["path",169],["match run path parser with",88],["/// <param name=\"path\">Path to input file.</param>",85],["/// <param name=\"path\">Path to file.</param>",68],["| Some path ->",66],["| SymbolKind.FSharpTypeAbbreviation (_,_,path),_ -> path.[path.Length-1]",53]],"useCount":12139},{"word":"pattern","context":[["/// Get the active pattern elements defined by a given value, if any",30],["sb.Replace(pattern,replacement) |> ignore",24],["let files = di.GetFiles(pattern, SearchOption.TopDirectoryOnly)",27],["|> Array.Parallel.map (fun pattern -> IsGlyphByPattern pattern txtGrid col row)",27],["for pattern,replacement in KnownAliases.Data do",24],["match pattern with",37],["// construct arising out the compilation of pattern matching. We decode these back to the form",44],["// Add active pattern result names to the environment",40],["// Unit-taking active pattern result can be applied to no args",40],["|> Array.Parallel.map (fun pattern -> IsGlyphByPattern pattern txtGrid col row)",27]],"useCount":2734},{"word":"pinfo","context":[["match pinfo with",113],["let pinfo = List.head pinfos",91],["let minfo = pinfo.GetSetMethod(true)",64],["let args = if pinfo.IsIndexer then args else []",40],["let minfo = pinfo.GetGetMethod(true)",64],["if  pinfo.CanRead then",63],["if  pinfo.CanWrite then",63],["let rty = pinfo.GetPropertyType(amap,m)",63],["let cattr = pinfo.GetCustomAttributesDataImpl()",53],["for pinfo in ptd.GetProperties(ALL) |> Seq.choose (function :? ProvidedProperty as pe -> Some pe | _ -> None) do",51]],"useCount":3239},{"word":"point","context":[["/// at the point of first generation.",38],["let! point = buffer.GetSnapshotPoint view.Caret.Position",71],["// This breaks certain invariants that hold elsewhere, because they dereference to point to",38],["// Note: We suppress the first sequence point in the body of this method since it is the initial state machine jump",48],["/// An intermediate definition that represent the point in an implicit class definition where",36],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234],["/// The identifier at the point of declaration of the type definition.",34],["/// First derivative of a scalar-to-scalar function `f`, at point `x`",28],["/// <param name=\"LabelPosition\">The relative data point width. Any double from 0 to 2.</param>",28],["/// Gradient of a vector-to-scalar function `f`, at point `x`",28]],"useCount":3381},{"word":"pop","context":[["///       B2:  pop",28],["CG.EmitInstr cgbuf (pop args.Length) (Push [typ])",28],["CG.EmitInstr cgbuf (pop 1) (Push [cenv.g.ilg.typ_Exception]) (I_castclass cenv.g.ilg.typ_Exception);",33],["r1 pop.w:g",39],["let popIfEmptyExpected s = if isEmpty s then pop()",60],["let pop () = ilg.Emit(OpCodes.Pop)",63],["pop()",64],["tos pop.w:g",69],["CG.EmitInstr cgbuf (pop 0) Push0 AI_nop",28],["let element,newPQ = pop newPQ",24]],"useCount":2387},{"word":"pos","context":[["if AstTraversal.rangeContainsPosLeftEdgeInclusive synExpr.Range pos then",90],["if rangeContainsPos m pos then",103],["pos=p;",104],["let z = addL z pos l",70],["let rec look i pos =",62],["let virtAddr = seekReadInt32 is (pos + 12)",58],["let virtSize = seekReadInt32 is (pos + 8)",58],["let pos = ms.Position",58],["| Some pos ->",51],["let afterJoin = CG.GenerateDelayMark cgbuf (pos + \"_join\")",48]],"useCount":5979},{"word":"position","context":[["// Check for the [<ProjectionParameter>] attribute on an argument position",36],["vec4 noisevec = vec4(snoise(position * base_freq * 1.0f) * 8.0f,",24],["snoise(position * base_freq * 8.0f) * 1.0f);",24],["// Use 1-based position for intuitive comparison",25],["in vec3 position;",25],["// Recheck cursor position to ensure it's still in new word",35],["vec3 position;",74],["snoise(position * base_freq * 4.0f) * 2.0f,",24],["let loc = getLocation position",24],["snoise(position * base_freq * 2.0f) * 4.0f,",24]],"useCount":1836},{"word":"pr","context":[["in (pr \"{\"; open_hovbox 0; p 1 fields; pr \"}\"; cbox ())",50],["pr \":\";",44],["in (pr \"{\"; open_hovbox 0; p 1 fields; pr \"}\"; cbox ())",50],["if outer then pr \" \" else ();",58],["pr x';",62],["pr x;",62],["pr \"lambda \";",78],["pr",81],["pr \",\";",89],["pr \".\";",100]],"useCount":2419},{"word":"predicate","context":[["let result = predicate ()",67],["/// <param name=\"predicate\">Predicate function.</param>",39],["/// that satisfies the given predicate.",42],["/// <param name=\"predicate\">The function to test the input elements.</param>",46],["let result = predicate testRecord",51],["let predicate = FSharpFunc<_,_,_>.Adapt predicate",64],["let predicate = FSharpFunc<_,_,_>.Adapt predicate",64],["/// <param name=\"predicate\">A function to test each source element for a condition.</param>",70],["/// <param name=\"predicate\"></param>",93],["/// <param name=\"predicate\">The function to test the input elements.</param>",207]],"useCount":2322},{"word":"prefix","context":[["if prefixes.vol <> Nonvolatile then failwith \"a volatile prefix is not allowed here\";",60],["let prefix =",145],["true to prefix-op",33],["let prefix = mkFragmentPath i",42],["let prefix = if i>0 then (sprintf \" %s \" op) else \"\"",46],["~~(sprintf \"%s%s\" prefix <|",46],["if prefixes.tl <> Normalcall then failwith \"a tailcall prefix is not allowed here\";",60],["if prefixes.ro <> NormalAddress then failwith \"a readonly prefix is not allowed here\";",75],["if prefixes.al <> Aligned then failwith \"an unaligned prefix is not allowed here\";",75],["if prefixes.constrained <> None then failwith \"a constrained prefix is not allowed here\";",75]],"useCount":2330},{"word":"print","context":[["print \")\"",53],[": print",27],["print \" = \"",27],["print ;",27],["print lBr",29],["print prefix",29],["// Note: We need nice printing of constants in order to print literals and attributes",31],["// Don't print individual methods forming interface implementations - these are currently never exported",34],["print \".\"",49],["print \"(\"",52]],"useCount":1847},{"word":"printfn","context":[["printfn \"cmd=\\\"%s\\\"\" cmd",95],["printfn \"%A\" argv",145],["employees |> Seq.iter (printfn \"%A\")",124],["printfn \"%s\" ex.Message",116],["printfn \"%s\" ps.Text",112],["printfn \"%A\" employee",103],["printfn \"%i\" result",101],["printfn \"%A\" department",97],["printfn \"%s\" msg",95],["printfn \"\"",436]],"useCount":6327},{"word":"private","context":[["private",127],["// optimized mutation-based implementation. This code is only valid in fslib, where mutation of private",114],["private {",51],["/// - A private key blob which has been encrypted and contains information to initialize RSA",42],["module private Helpers =",42],["module private Native =",41],["let mutable private cur = 0",28],["/// <param name=\"privateID\"> private ID of the provider </param>",36],["type private ParserOption =",39],["/// or marked 'internal' or 'private' and we have to check various conditions associated with that.",38]],"useCount":5766},{"word":"process","context":[["/// Runs the given process and returns the process result.",30],["/// Runs the given process and returns the exit code.",46],["///  - `timeOut` - The timeout for the process.",94],["/// Runs the given process and returns the process result.",30],["/// Evaluate workflow in the local test process",31],["/// A unique stamp within the context of this invocation of the compiler process",32],["| SynExpr.JoinIn _ ->  () // an error will be reported later when we process innerComp1 as a sequential",36],["// and the modifiations hang around even after the process has exited.",42],["with exn -> failwithf \"Start of process %s failed. %s\" proc.StartInfo.FileName exn.Message",42],["| No_Install -> \"Skips paket install --hard process afterward generation of dependencies / references files.\"",42]],"useCount":2003},{"word":"project","context":[["match project with",59],["| [<CustomCommandLine(\"project\")>] Project of string",59],["///  - `outputPath` - If it is null or empty then the project settings are used.",60],["let project = CreateProject(solution,\"testproject\")",64],["///  - `projects` - A list of project or solution files.",72],["for project in projects do",72],["Project = project",75],["project.Document",98],["// See the 'F# Tutorial' project for more help.",208],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998]],"useCount":8808},{"word":"prop","context":[["(\"property P\", \"file1\", (5, 13), (5, 14), [\"member\"; \"prop\"])]",22],["let prop =",67],["[\"slot\"; \"member\"; \"prop\"]);",55],["[\"member\"; \"prop\"]);",55],["prop",50],["match prop with",39],["let pref = ILPropertyRef.Create (tref,prop.Name)",32],["let pvals = (props,vals) ||> Array.map2 (fun prop v -> prop.Name,v)",26],["let pvals = (props,vals) ||> Array.map2 (fun prop v -> prop.Name,v)",26],["(\"property SomeProperty\", \"file2\", (10, 13), (10, 25), [\"member\"; \"prop\"]);",22]],"useCount":2081},{"word":"properties","context":[["parameters.Version outputPath nuspecFile packageAnalysis defaultExcludes includeReferencedProjects properties",33],["ILAttributeNamedArg list (* named args: values and flags indicating if they are fields or properties *)",34],["// REVIEW: for IL properties this is getter OR setter. For F# properties it is getter ELSE setter",34],["// REVIEW: for IL properties this is getter OR setter. For F# properties it is getter ELSE setter",34],["// can't infer extra polymorphism for properties",38],["///  - `properties` - A list with tuples of property name and property values.",39],["properties",40],["match (entry |> getNode \"properties\" |> optGetNode \"Id\") ++ (entry |> getNode \"title\") with",42],["let properties =",48],["/// A flag read eagerly from the provided type and used to compute basic properties of the type definition.",85]],"useCount":2240},{"word":"property","context":[["/// Converts the computation to a result property.",44],["/// and adjust the 'Assembly' property of all provided type definitions to return that",44],["/// Get or set a flag indicating if the property is static.",108],["/// Represents an erased provided property.",75],["///   - If this is a property then this is 'Foo'",72],["/// Set the function used to compute the implementation of sets of this property.",68],["/// Set the quotation used to compute the implementation of gets of this property.",68],["// Eliminate F# property gets to method calls",64],["// property of the custom attribute is foced.",64],["// Eliminate F# property sets to method calls",64]],"useCount":5580},{"word":"provided","context":[["/// Create a new provided field. It is not initially associated with any specific provided type definition.",66],["/// Create a new provided type. It is not initially associated with any specific provided type definition.",67],["/// Create a new provided type. It is not initially associated with any specific provided type definition.",67],["/// Note that the type provider specification does not require us to implement pointer-equality for provided types.",68],["/// Represents the type constructor in a provided symbol type.",68],["/// Represents an array or other symbolic type involving a provided type as the argument.",68],["/// Represents an erased provided property.",75],["/// A flag read eagerly from the provided type and used to compute basic properties of the type definition.",85],["/// Add definition location information to the provided type definition.",146],["/// Add XML documentation information to this provided constructor",217]],"useCount":5282},{"word":"provider","context":[["(* Member of type 'CodeTypeConstructor' is not supported by the CodeDOM provider and was omitted *)",189],["/// See the type provider spec for the methods that must be implemented.",68],["/// Note that the type provider specification does not require us to implement pointer-equality for provided types.",68],["attributes(provider)",56],["for provider in providers do",54],["let provider =",47],["// lambda name should be unique across all types that all type provider might contribute in result assembly",45],["member __.GetXmlDocAttributes(provider) = provide().GetXmlDocAttributes(provider)",39],["member __.GetDefinitionLocationAttribute(provider) = provide().GetDefinitionLocationAttribute(provider)",39],["member __.GetXmlDocAttributes(provider) = provide().GetXmlDocAttributes(provider)",39]],"useCount":2811},{"word":"ps","context":[["|> Seq.map (fun ps ->",27],["assert_equal DBNull.Value ps.Parameters.[0].Value",27],["assert_equal 2 ps.Parameters.Length",36],["else NewInferenceTypes ps",44],["match ps with",53],["ps",59],["let ps =",65],["printfn \"%A\" ps.Parameters",84],["printfn \"%s\" ps.Text",112],["assert_equal 1 ps.Parameters.Length",124]],"useCount":1876},{"word":"ptd","context":[["if typeMap.ContainsKey ptd then typeMap.[ptd] :> Type else ty",63],["iterateTypes (fun  tb ptd ->",63],["match ptd with",236],["| Some ptd ->",177],["iterateTypes (fun tb ptd ->",124],["for minfo in ptd.GetMethods(ALL) do",104],["for ityp in ptd.GetInterfaceImplementations() do",64],["let tb = typeMap.[ptd]",64],["let rec typeMembers (ptd : ProvidedTypeDefinition) =",64],["| :? ProvidedTypeDefinition as ptd ->",64]],"useCount":1882},{"word":"public","context":[["[<DefaultValue>] val mutable public F1 : 'b",30],["[<DefaultValue>] val mutable public F2 : 'c",29],["[<DefaultValue>] val mutable public F0 : 'a",31],["///Check all public static methods on the given type that have a testable return type with quick configuration",30],["/// Get the public path to the value, if any? Should be set if and only if",32],["/// <param name=\"publicID\"> public ID of the provider </param>",34],["public:",36],["let public Solutions = [RunA;RunB]",82],["val mutable public pNext : nativeint",150],["val mutable public sType : VkStructureType",150]],"useCount":2375},{"word":"q","context":[["else q",61],["let q = ofSeq [\"a\";\"b\";\"c\";\"d\"]",60],["let q =",65],["Utils.Run q",69],["// if exist test.ok (del /f /q test.ok)",92],["with set  (q:Quotations.Expr list -> Quotations.Expr) =",104],["with set (q:Quotations.Expr list -> Quotations.Expr) =",104],["| None -> invokeCode <- Some q",122],["let q = fun (persons : IQueryable<Person>) ->",139],["match q with",210]],"useCount":3023},{"word":"query","context":[["query.SelectColumns |> should equal gameTypePropertySet",66],["/// <returns>The query result list.</returns>",72],["query",57],["query.TakeCount.IsNone |> should equal true",58],["query {",810],["/// <returns>The query result sequence.</returns>",72],["test <@ %query = %expected @>",82],["//query {",96],["CollectionAssert.IsNotEmpty query",98],["let query =",279]],"useCount":3535},{"word":"queue","context":[["queue",55],["let queue = Cluster.Connects.LookforConnectBySignature( remoteSignature )",51],["queue.Initialize()",40],["let health = queue.Performance",42],["queue.Close()",43],["let queue = Cluster.Connects.LookforConnectBySignature( queueSignature )",50],["/// <param name=\"item\">Item to be inserted into queue</param>",59],["if Utils.IsNotNull queue && queue.CanSend then",84],["if Utils.IsNotNull queue && queue.CanSend then",84],["(LocalDNS.GetShowInfo(queue.RemoteEndPoint))",71]],"useCount":2065},{"word":"r","context":[["r>",315],["Assert.IsNotEmpty(r)",201],[">r",1488],["match r with",507],["r",471],["#r \"../../packages/NUnit/lib/nunit.framework.dll\"",184],["let r =",166],["r> drop",144],["match r.fsobjmodel_kind with",126],["match r.Location with",111]],"useCount":29186},{"word":"raise","context":[["raise (System.NotImplementedException())",767],["| _ -> raise Common.NoRuleAppliesException",54],["| _ -> raise <| Error.errExpectedX \"symbol\"",63],["raise (System.NotSupportedException msg)",64],["raise exn",66],["raise <| Exception(\"\", e)",98],["// Run InferTyconKind to raise errors on inconsistent attribute sets",100],["raise <| System.Collections.Generic.KeyNotFoundException ()",98],["raise e",137],["| _ -> raise <| Error.wrongArity ()",289]],"useCount":5957},{"word":"range","context":[["s\" Index out of range\" exception constant exp-index-out-of-range ( -- n = Index out of range exception number )",44],["|> NameMap.range",89],["range *",56],["member DeclarationLocation : range",55],["member Range : range",54],["range",54],["<@ fun (range:_1D) (buf:array<int>) ->",51],["|> makeCall com i.range i.returnType |> Some",48],["/// the signature range for an item in an implementation",44],["fun (range:_1D) (buf:array<int>) ->",216]],"useCount":16338},{"word":"re","context":[["// OK, we're done, Record the results for the type variable which provide the support",40],["// of the partial build to be re-evaluated.",30],["/// The documentation is re-computed  every time it is required.",212],["// Adjust the attributes - we're codegen'ing as non-nested",64],["// Adjust the attributes - we're codegen'ing this type as nested",64],["// nice: don't introduce awful temporary for r.h.s. in the 99% case where we know what we're binding it to",60],["/// If optKind=Some kind, then this is the kind we're expecting (we're in *analysis* mode)",40],["/// If optKind=Some kind, then this is the kind we're expecting (we're in *analysis* mode)",40],["/// If optKind=None, we need to determine the kind (we're in *synthesis* mode)",40],["// Check if we're compiling the property as a .NET event",32]],"useCount":2604},{"word":"read","context":[["/// or comes from another F# assembly then it does not (because the documentation will get read from",34],["// read a character - end the scan if there are no further transitions",34],["/// A flag read eagerly from the provided type and used to compute basic properties of the type definition.",85],["let mutable native = NativePtr.read ptr",83],["t{ xis3 xis-read xis+remove-read-parameters }t",58],["t{ xis3 xis-read xis+remove-read-parameters }t",58],["\"\",    // humans read this",54],["// The first string is what humans expect to read",52],["read()",43],["read",44]],"useCount":3617},{"word":"reader","context":[["[ while reader.Read() do",95],["use reader = command.ExecuteReader()",62],["let reader =",65],["use reader = com.ExecuteReader()",68],["let reader (r : ReadState) (_ : string) =",85],["use reader = CreateReader(stream)",51],["use reader = new StreamReader(stream)",72],["use reader = cmd.ExecuteReader()",83],["while reader.Read() do",101],["match reader.Read() with",52]],"useCount":2476},{"word":"rec","context":[["let rec loop () =",175],["let rec loop() =",173],["let rec loop expr = traverse loopCore expr",84],["let rec loop () = async {",82],["let rec aux = function",77],["let rec loop i =",192],["let rec gather acc unt =",76],["let rec loop types =",68],["let rec typeMembers (ptd : ProvidedTypeDefinition) =",64],["let rec emitC (v:obj) =",63]],"useCount":14023},{"word":"record","context":[["// The type constructor is in the signature. Hence record the repackage entry",38],["/// Get a list of all fields for F#-defined record, struct and class fields in this type definition,",34],["// Emit a message to the NUnit console/log to record when this function is called.",40],["/// <exception cref=\"System.ArgumentException\">Thrown when the input type is not a record type.</exception>",52],["/// Get a list of all instance fields for F#-defined record, struct and class fields in this type definition,",34],["/// Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition.",34],["/// Gets any implicit hash/equals methods added to an F# record, union or struct type definition.",34],["/// Builds the command line arguments from the given parameter record and the given assemblies.",35],["/// Get an array of fields for all the F#-defined record, struct and class fields in this type definition, including",34],["// We record the ones for which we have made this assumption.",40]],"useCount":3712},{"word":"recursive","context":[["// Type check local recursive binding",20],["// Helpers for type inference for recursive bindings",20],["// Type variables free in the non-recursive environment do not stop us generalizing the binding,",20],["// Eliminate recursive let bindings (which are unsupported by the type provider API) to regular let bindings",22],["// PassA: create member prelimRecValues for \"recursive\" items, i.e. ctor val and member vals",30],["// note: must be tail-recursive",30],["// Now that we know what we've generalized we can adjust the recursive references",40],["// tail recursive",44],["// Call the recursive implementation function.",72],["// Call the recursive implementation.",216]],"useCount":1871},{"word":"ref","context":[["let refValue = ref Unchecked.defaultof<_>",126],["let res = ref []",119],["let counter = ref 0",115],["let resultEpt = ref 0",98],["let resultInt = ref 0",82],["let iterationCount = ref 0",74],["let cell = ref 0",72],["let i = ref 0",182],["let count = ref 0",280],["let f1hole = ref (Unchecked.defaultof<_>)",63]],"useCount":9452},{"word":"reference","context":[["// reference type",118],["/// Rescoping. The first argument tells the function how to reference the original scope from",85],["// null reference",66],["{ /// Indicates a reference to something bound in this CCU",40],["/// Indicates a reference to something bound in another CCU",40],["// Helpers to freshen existing types and values, i.e. when a reference",40],["/// The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations",39],["#nowarn \"1183\" // unused 'this' reference",38],["// reference keys",176],["// e.g. for type abbreviations to types not in the reference set.",34]],"useCount":3841},{"word":"references","context":[["match references with",31],["// Compiler-internal references to items in fslib are Ref_nonlocals even when compiling fslib.",38],["// Compute the top-rooted module or namespace references",40],["// Now that we know what we've generalized we can adjust the recursive references",40],["| No_Install -> \"Skips paket install --hard process afterward generation of dependencies / references files.\"",42],["let references = lockFile.SourceFiles",50],["/// Restores the given paket.references files.",54],["references",159],["let references =",172],["for lib in references do",31]],"useCount":4649},{"word":"remarks","context":[["/// </remarks>",197],["/// <remarks>This function returns a sequence that digests the whole initial sequence as soon as",39],["/// The order in which the given function is applied to elements of the input array is not specified.</remarks>",42],["/// <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>",44],["/// <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>",44],["/// <remarks>A cancellation check is performed when the computation is executed.",49],["/// <remarks>Performs the operation in parallel using System.Threading.Parallel.For.",56],["/// <c>async { ... }</c> computation expression syntax.</remarks>",70],["///</remarks>",83],["/// <remarks>",196]],"useCount":2356},{"word":"res","context":[["match res with",864],["res",3169],["let res =",593],["| Some res -> res",582],["| Some res -> res",582],["let mutable res = Unchecked.defaultof<_>",250],["| Some res ->",207],["res)",190],["(fun res -> ErrorD (ErrorFromAddingConstraint(denv,res,m)))",174],["(fun res -> ErrorD (ErrorFromAddingConstraint(denv,res,m)))",174]],"useCount":20132},{"word":"resolution","context":[["/// later through 'open' get priority in overload resolution.",32],["uniform vec2 resolution;",75],["let resolution =",52],["| Some resolution -> Some resolution",40],["| Some resolution -> Some resolution",40],["match resolution with",37],["// Record the resolution of the custom operation for posterity",36],["/// Indicates a compiler generated field, not visible to Intellisense or name resolution",32],["// fold the available extension members into the overload resolution",32],["// Record the precise resolution of the field for intellisense",39]],"useCount":3679},{"word":"resolved","context":[["|> Seq.map (fun (KeyValue (_,resolved)) -> (string resolved.Name, string resolved.Version))",112],["|> Seq.map (fun (KeyValue (_,resolved)) -> (string resolved.Name, string resolved.Version))",112],["let resolved =",131],["|> Seq.map (fun (KeyValue (_,resolved)) -> (string resolved.Name, string resolved.Version))",112],["getVersion resolved.[PackageName \"Nancy.Bootstrappers.Windsor\"] |> shouldEqual \"0.23\"",107],["+ lineIfExists(resolved.fusionName)",80],["getVersion resolved.[PackageName \"Castle.Windsor\"] |> shouldEqual \"3.2.1\"",76],["match resolved with",65],["// this condition is used whenever ^T is resolved to a nominal type",60],["getVersion resolved.[PackageName \"Castle.Windsor-NLog\"] |> shouldEqual \"3.3.0\"",43]],"useCount":2497},{"word":"resource","context":[["// aapt resource value: 0",105],["// aapt resource value: 6",36],["resource.Dispose ()",42],["// aapt resource value: 5",43],["// aapt resource value: 4",50],["// aapt resource value: 3",53],["let resource =",54],["if not <| isNull (box resource) then",57],["// aapt resource value: 2",70],["// aapt resource value: 1",90]],"useCount":2015},{"word":"rest","context":[["match rest with",219],["let rest =",142],["| id :: rest ->",119],["| id::rest ->",85],["| id :: rest when id.idText = MangledGlobalName -> rest",80],["| id :: rest when id.idText = MangledGlobalName -> rest",80],["| key::rest ->",74],["-> unindentationLimit false rest",70],["| id:: rest ->",68],["buckets.[key] <- (rest,v) :: (if buckets.ContainsKey key then buckets.[key] else []);",68]],"useCount":7840},{"word":"result","context":[["return result",282],["match result with",1648],["result",1841],["static let result : ('T -> 'T) =",153],["/// <returns>The result of the comparison.</returns>",199],["assert_equal typeof<bool> (snd result)",220],["let result = source.ReadUInt32()",242],["target.Write(result)",242],["/// <returns>The result sequence.</returns>",414],["let result =",1387]],"useCount":20732},{"word":"results","context":[["let results =",264],["results",246],["// allocate results",84],["let results = Array.zeroCreate len",82],["return results",80],["/// <summary>Builds a new collection whose elements are the results of applying the given function",78],["// Return the completed results.",72],["// These don't have to return fully accurate results - they are used",60],["match results with",55],["results.[index] <- result",50]],"useCount":7458},{"word":"return","context":[["0 // return an integer exit code",537],["return ()",533],["return!",405],["return None",315],["return result",282],["return state",242],["| None -> return None",195],["return env",181],["return false",179],["return",896]],"useCount":17395},{"word":"returns","context":[["/// <returns></returns>",917],["/// <returns></returns>",917],["/// </returns>",445],["/// <returns>",415],["/// <returns>The result sequence.</returns>",414],["/// <returns>The result sequence.</returns>",414],["/// <returns>The resulting expression.</returns>",261],["/// <returns>The resulting expression.</returns>",261],["/// <returns>The result of the comparison.</returns>",199],["/// <returns>The result of the comparison.</returns>",199]],"useCount":14201},{"word":"rev","context":[["|> Array.rev",103],["let packages = List.rev lockFile.Packages",126],["| [] -> List.rev acc",47],["if n = 0 then List.rev acc else",46],["List.rev acc",33],["List.rev !res",32],["return List.rev mapped",30],["pc', List.rev (i :: rinstrs)",30],["for fileItem in fileItems |> List.rev do",29],["|> List.rev",501]],"useCount":2854},{"word":"rfref","context":[["|> List.filter (fun rfref -> rfref.IsStatic = statics  &&  IsFieldInfoAccessible ad rfref)",30],["| SafeInitField (rfref, _) ->",80],["| InField(true, idx, rfref),_ ->",40],["let fspec = GenRecdFieldRef m cenv eenv.tyenv rfref tyargs",32],["IsAccessible ad rfref.RecdField.Accessibility",32],["let projR = ConvRecdFieldRef cenv rfref",32],["let typR = ConvType cenv (mkAppTy rfref.TyconRef tyargs)",32],["|> List.filter (fun rfref -> rfref.IsStatic = statics  &&  IsFieldInfoAccessible ad rfref)",30],["|> List.filter (fun rfref -> rfref.IsStatic = statics  &&  IsFieldInfoAccessible ad rfref)",30],["if rfref.TyconRef.IsRecordTycon then",28]],"useCount":2599},{"word":"right","context":[["// This ensures we always get the type instantiation right when doing this from",80],["/// Left-to-right Kleisli composition",38],["// The state of the left-to-right iteration through the bindings",38],["if right == s1 then s",40],["else Br (p, m, s0, right)",40],["/// Post-filter items to make sure they have precisely the right name",44],["/// Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.",59],["match left, right with",96],["| Br (_, _, left, right) ->",96],["beginning of the box rather than 2 more columns to the right",54]],"useCount":3407},{"word":"root","context":[["match root with",34],["let targetFolder = DirectoryInfo(getTargetFolder root groupName packageName version includeVersionInPath).FullName",26],["else root",28],["at the root of this distribution.",31],["/// The assembly is only emitted when the Assembly property on the root type is accessed for the first time.",37],["root",42],["let root =",45],["let root = Path.GetDirectoryName dependenciesFile.FileName",46],["let di = getDirectoryInfo localNugetPath root",56],["XDocument(declaration, box root)",64]],"useCount":2316},{"word":"rty","context":[["let rty = GetFSharpViewOfReturnType denv.g rty",42],["let rty = GetFSharpViewOfReturnType denv.g rty",42],["let rty = (if isUnitTy g rty then None else Some rty)",38],["let rty = minfo.GetFSharpReturnTy(amap, m, minfo.FormalMethodInst)",51],["let rty = GetFSharpViewOfReturnType g rty",52],["let rty = GetFSharpViewOfReturnType g rty",52],["ParamsOfParamDatas g denv paramDatas rty",54],["let rty = pinfo.GetPropertyType(amap,m)",63],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty ++ (fun () ->",70],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty1 ++ (fun () ->",98]],"useCount":4562},{"word":"run","context":[["let run,check = checkResult command",176],["|> run",175],["run _1d intInArr",115],["let run n =",89],["match run path parser with",88],["///  - `targets` - A string with the target names which should be run by MSBuild.",78],["let run() =",75],["[<Ignore(\"Remove to run test\")>]",799],["let run () =",74],["run()",65]],"useCount":3787},{"word":"s","context":[["%s",184],["else s",208],["| Some s ->",232],["s",487],["match s with",1071],["let s =",168],["| Some s -> s",173],["| Some s -> s",173],["let s = if e.Type.IsValueType then ExpectedStackState.Address else ExpectedStackState.Value",176],["~~ (sprintf \" %s \" op)",184]],"useCount":58240},{"word":"s1","context":[["let s1 = File.ReadAllText oldWeavers |> normalizeLineEndings",116],["s1.Contains \"FodyWeavers.xml\" |> shouldEqual true",101],["else Zset.union s1 s2",95],["let s1,s2 = splitNameAt nm idx",76],["s2 |> shouldEqual s1",564],["env.Write s1",50],["else Br (p, m, left, s1)",40],["if right == s1 then s",40],["let s1 = File.ReadAllText oldFile |> normalizeLineEndings",514],["| Br (p, m, s0, s1), Br (q, n, t0, t1) ->",36]],"useCount":2821},{"word":"s2","context":[["s2 |> shouldEqual s1",564],["let s2 = File.ReadAllText newFile |> normalizeLineEndings",514],["let s2 = File.ReadAllText newWeavers |> normalizeLineEndings",116],["else Zset.union s1 s2",95],["let s1,s2 = splitNameAt nm idx",76],["s1 |> shouldEqual s2",36],["env.Write s2",30],["match s1, s2 with",21],["fun b1 b2 s1 s2 i1 i2 i3 l1 l2 l3 m1 m2 m3 m4 t1 t2 ->",20],["if s1 === emptyFreeTypars then s2",19]],"useCount":2328},{"word":"same","context":[["// Sort by name. For things with the same name,",27],["/// arrays must have the same lengths, otherwise an <c>ArgumentException</c> is",57],["/// The resultant datasets all have the same partition and collection structure of the original dataset.",33],["/// same name.",33],["/// Note that because of signatures, there are situations where in a single compilation the \"same\"",34],["// If the result is the same (physical equality) to one of the inputs,",36],["// Inside the incremental class sytntax we assert the type of the 'this' variable to be precisely the same type as the",38],["| _                   -> failwith \"Forward and reverse AD cannot run on the same level.\"",44],["/// Returns a data frame that contains the same data as the input,",45],["obox0  Same but indent continuation lines to the same column as the",54]],"useCount":2728},{"word":"sb","context":[["cmd.CommandText <- sb.ToString()",102],["let sb = System.Text.StringBuilder()",109],["let sb = new System.Text.StringBuilder()",82],["sb.ToString()",358],["let sb = Text.StringBuilder()",80],["sb.Append(\"(\").Append(box(x.Item1).ToString()).Append(\",\")",63],["sb.Clear() |> ignore",214],["let sb = new StringBuilder()",195],["let sb = StringBuilder()",173],["let (~~) (t:string) = sb.Append t |> ignore",119]],"useCount":2873},{"word":"scope","context":[["/// Rescoping. The first argument tells the function how to reference the original scope from",85],["let scope = Ag.getContext()",32],["scope.Complete()",51],["/// Get the Abstract IL scope, nesting and metadata for this",34],["/// the new scope.",85],["let scope =",86],["(fun (scope, _builder, _reactor) ->",51],["// In F# this only defines a new type if A is not in scope",40],["match scope with",36],["scope = \"\"",35]],"useCount":3250},{"word":"scopem","context":[["let scopem = unionRanges m endm",80],["CallEnvSink tcSink (scopem,env.NameEnv,env.eAccessRights)",162],["let scopem = unionRanges m scopem",40],["let scopem = unionRanges m scopem",40],["let env = AddRootModuleOrNamespaceRefs g amap scopem env modrefs",40],["let scopem = unionRanges m.EndRange endm",40],["let env = TcOpenDecl cenv.tcSink cenv.g cenv.amap m scopem env mp",36],["let env = AddLocalSubModule cenv.tcSink cenv.g cenv.amap m scopem env mspec",28],["let scopem =",20],["let binds,env,_ = TcLetrec  WarnOnOverrides cenv env tpenv (binds,m, scopem)",20]],"useCount":1855},{"word":"scoref","context":[["member scoref.QualifiedName =",20],["match scoref,scoref_old with",20],["member x.ILScopeRef = (let (CompPath(scoref,_)) = x in scoref)",20],["let scoref,_,tdef = tcref.ILTyconInfo",21],["let scoref,enc,tdef = tcref.ILTyconInfo",23],["match rescopeILTypeSpecQuick scoref cr with",34],["let scoref = seekReadImplAsScopeRef ctxt implIdx",36],["| ILTypeMetadata (scoref,tdef) ->",43],["match scoref with",180],["ILTypeMetadata (scoref,tdef)",34]],"useCount":1870},{"word":"second","context":[["/// <param name=\"e2\">The second value.</param>",165],["/// <param name=\"y\">The second parameter.</param>",150],["/// <param name=\"array2\">The second input array.</param>",87],["/// <param name=\"source2\">The second input sequence.</param>",83],["/// <param name=\"list2\">The second input list.</param>",77],["/// <param name=\"arg2\">The second arg.</param>",72],["/// <param name=\"start2\">The start index of the second dimension.</param>",68],["/// <param name=\"finish2\">The end index of the second dimension.</param>",68],["/// Sequence actions, discarding the value of the second argument.",51],["// and the second string list is what the function reads.",37]],"useCount":2482},{"word":"see","context":[["/// <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary>",33],["writeInt32 os 0x00; // Reserved Always 0 (see Section 23.1).",29],["/// Returns a sender of current message or <see cref=\"ActorRefs.NoSender\" />, if none could be determined.",27],["/// Gets <see cref=\"IActorRef\" /> for the current actor.",27],["\\g @see ansfile",44],["// Preset: --optimize+ -g --tailcalls+ (see 4505)",50],["* If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.",56],["#if CROSS_PLATFORM_COMPILER // see https://bugzilla.xamarin.com/show_bug.cgi?id=22591",62],["\\g @see anscore",355],["let enclTyp = seekReadTypeDefAsType ctxt AsObject (* not ok: see note *) finst tidx",36]],"useCount":2709},{"word":"self","context":[["override self.ToString() =",47],["member self.DegreeOfParallelism = None",59],["member self.Iterator() =",59],["let file = self.FileStore.GetRandomFilePath testDirectory.Value",64],["match self with",85],["Check.QuickThrowOnFail(f, self.FsCheckMaxNumberOfTests)",139],["|> self.PublishActorPrimary",55],["override self.ToString () =",53],["member self.DegreeOfParallelism = flow.DegreeOfParallelism",51],["member self.Invalidate() = invalidateE.Trigger(self,EventArgs())",41]],"useCount":3064},{"word":"seq","context":[["seq{",80],["// seq<'T> * ('T -> M<'U>) -> seq<M<'U>>",80],["let nullSeq:seq<'a> = null",210],["seq {",1993],["// seq<'T> * ('T -> M<'U>) -> M<'U>",80],["// seq<'T> * ('T -> M<'U>) -> seq<M<'U>>",80],["seq",47],["seq { for i in 0..9 do",45],["seq { use e = source.GetEnumerator()",46],["interface seq<'T> with",47]],"useCount":6112},{"word":"sequel","context":[["GenUnitThenSequel cenv eenv m eenv.cloc cgbuf sequel",126],["match sequel with",96],["GenSequelEndScopes cgbuf sequel",67],["match sequelAfterDiscard sequel with",48],["// NOTE: discard sequel",48],["GenSequel cenv eenvouter.cloc cgbuf sequel",48],["GenNewArraySimple cenv cgbuf eenv (elems,elemTy,m) sequel",32],["GenSequel cenv eenv.cloc cgbuf sequel",594],["GenExpr cenv cgbuf eenv SPSuppress expr sequel",30],["CommitCallSequel cenv eenv m eenv.cloc cgbuf mustGenerateUnitAfterCall sequel",28]],"useCount":3913},{"word":"sequence","context":[["/// <param name=\"source\">The input sequence.</param>",562],["checkNonNull \"sequence\" sequence",67],["checkNonNull \"sequence\" sequence",67],["/// <param name=\"source\">The input sequence.</param>",70],["/// <returns>The query result sequence.</returns>",72],["/// <exception cref=\"System.ArgumentException\">Thrown when the input sequence is empty.</exception>",73],["/// <returns>The result sequence.</returns>",414],["/// <param name=\"source2\">The second input sequence.</param>",83],["/// <param name=\"source1\">The first input sequence.</param>",78],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518]],"useCount":6192},{"word":"series","context":[["/// [category:Accessing series data and lookup]",112],["/// This operation is only supported on ordered series. The method throws",96],["let series =",90],["///  - `series` - The input series to be aggregated.",86],["///  - `series` - The input series to be aggregated.",86],["/// Displays a series of connecting vertical lines where the thickness",29],["series",31],["/// `InvalidOperationException` when the series is not ordered.",82],["///  - `series` - An input series to be resampled",84],["///  - `series` - An input series to be resampled",84]],"useCount":2168},{"word":"set","context":[["member this.DeclaringTypeImpl with set x = declaringType <- x // check: not set twice",214],["and set v =",182],["// set of attributes. Change these attribute values to modify the information",1064],["/// <param name=\"Name\">The name of the data set.</param>",753],["member this.DeclaringTypeImpl with set x = declaringType <- x // check: not set twice",214],["checkNonNull \"set\" set",458],["checkNonNull \"set\" set",458],["|> set",134],["and  set f =",132],["// COM, set the ComVisible attribute to true on that type.",997]],"useCount":24347},{"word":"should","context":[["|> should equal expected",311],["|> should equal \"\"\"",205],["|> should equal Valid",142],["actual |> should equal expected",387],["|> should equal true",407],["|> should equal Invalid",138],["true |> should be False",136],["///  - `targets` - A string with the target names which should be run by MSBuild.",78],["|> should equal false",121],["|> should be True",133]],"useCount":10876},{"word":"shouldEqual","context":[["|> shouldEqual (normalizeXml expected)",130],["allUsesOfAllSymbols |> shouldEqual",157],["|> shouldEqual true",212],["actual |> shouldEqual expected",283],["wholeProjectResults.Errors.Length |> shouldEqual 0",310],["|> shouldEqual (normalizeLineEndings expected)",317],["|> shouldEqual expected",478],["s2 |> shouldEqual s1",564],["|> shouldEqual",921],["cfg.Groups.[Constants.MainDependencyGroup].Options.Strict |> shouldEqual false",121]],"useCount":10339},{"word":"signature","context":[["/// Layout a function pointer signature using type-only-F#-style. No argument names are printed.",36],["let signature =",37],["// The type constructor is in the signature. Hence record the repackage entry",38],["// The type constructor is not present in the signature. Hence it is hidden.",38],["// at the member signature. If so, we know the type of this member, and the full slotsig",40],["// We need a signature in terms of the values' type parameters.",40],["let signature = getTooltipSignature input",43],["/// the signature range for an item in an implementation",44],["/// Used to hide/filter members from super classes based on signature",72],["// MUTABILITY: used when propagating signature attributes into the implementation.",93]],"useCount":4126},{"word":"sigptr","context":[["let ccByte,sigptr = sigptrGetByte bytes sigptr",120],["let typ, sigptr = sigptrGetTy ctxt numtypars bytes sigptr",108],["let b0,sigptr = sigptrGetByte bytes sigptr",110],["let b0,sigptr = sigptrGetByte bytes sigptr",110],["let b1,sigptr = sigptr_get_byte bytes sigptr",115],["let b1,sigptr = sigptr_get_byte bytes sigptr",115],["let ccByte,sigptr = sigptrGetByte bytes sigptr",120],["let sigptr = 0",125],["let b0,sigptr = sigptr_get_byte bytes sigptr",138],["let b0,sigptr = sigptr_get_byte bytes sigptr",138]],"useCount":10712},{"word":"since","context":[["// Note: We suppress the first sequence point in the body of this method since it is the initial state machine jump",48],["// The empty instantiation on the AbstractIL fspec is OK, since we make the correct fspec in IlxGen.GenAsm",42],["// There should be no bindings that have not been generalized since checking the vary last binding always",40],["// where X' is X but with occurrences of even/odd substituted by !even and !odd (since now even and odd are references)",22],["/// we can't just return the LexBuffer object, since the file it wraps wouldn't",23],["// ok to use ecmaILGlobals here since we're querying metadata, not making it",26],["// Handle these as special cases since mutables are allowed inside their bodies",27],["// Don't push a new context if next token is EOF, since that raises an offside warning",28],["/// Reading is delayed, since it does an import on the underlying type",34],["// since the shape of relExpr doesn't match our expectations (JoinRelation)",36]],"useCount":1956},{"word":"single","context":[["// \"single named item\" rule. This is where we have a single accessible method",80],["/// Note that because of signatures, there are situations where in a single compilation the \"same\"",34],["// The basic iteration over the declarations in a single type definition",36],["| Single of single",36],["// Eliminate lone single unit arguments",38],["// single case",51],["// A single group of tupled arguments",51],["// initially supporting update/create/delete of single entities, no hierarchies yet",56],["| Single of single",73],["// \"single named item\" rule. This is where we have a single accessible method",80]],"useCount":2853},{"word":"size","context":[["/// the size for the sampler",84],["r> encode-64+                   \\ | encode size",40],["let mutable size = 0",45],["let nochunk next = ({addr= 0x0;size= 0x0; } ,next)",37],["let compiler, a, b, c, size, wrapper = GetData()",46],["r> encode-64+                   \\ | Encode size                       ( paddr plen )",48],["r> encode-64+                   \\ | Encode assigned addr              ( paddr plen R: size )",48],["/// <param name=\"TitleFontSize\">The font size for the title of the axis</param>",56],["Printf.sprintf \"Variable lookup failure: offset: %d, ctx size: %d\"",96],["dup IF                                  \\ IF BAR-size > 0       ( paddr plen baddr bsize )",40]],"useCount":4557},{"word":"slot","context":[["| Some slot ->",25],["/// Check if an override matches a dispatch slot by name",24],["// outer counts up from 0, and is next slot to break if break forced.",23],["// next  is next slot to push into - aka size of current occupied stack.",23],["[\"slot\"; \"member\"]);",22],["let CheckStamp acc slot =",22],["[\"slot\"; \"member\"; \"prop\"]);",55],["/// Indicates if this value was a member declared 'override' or an implementation of an interface slot",29],["//   multiple member-binding(includes-overrides) or abstract-slot-declaration or interface-bindings",20],["/// Indicates if this member is an F#-defined dispatch slot.",29]],"useCount":2749},{"word":"snd","context":[["override x.ErrorCount = delayed |> Seq.filter snd |> Seq.length",35],["|> Seq.groupBy snd",26],["let lhsType = snd lhs",27],["let rhsType = snd rhs",27],["let cvar_sorts = List.map snd cvars in",37],["|> Array.map snd",53],["|> List.map snd",115],["|> snd",181],["|> Seq.map snd",184],["assert_equal typeof<bool> (snd result)",220]],"useCount":2997},{"word":"so","context":[["// Record the details so we can map System.Type --> TyconRef",36],["// A huge number of these occur in pickled F# data, so make them unique",52],["/// Is this a member, if so some more data about the member.",35],["// because the base type is CsvRow<RowType>, so we have to erase recursively to CsvRow<TupleType>",38],["// furnished to do so, subject to the following conditions:",39],["// to the NUnit console/log so we'll know this function has been executed.",40],["// at the member signature. If so, we know the type of this member, and the full slotsig",40],["//so use THIS instead to send credentials RIGHT AWAY",46],["// data structures involved here are so large we can't take the risk.",48],["//   (its implementation of IsAssignableFrom raises NotSupportedException so it will be safer to always emit castclass)",51]],"useCount":4422},{"word":"some","context":[["// These are some constant expressions which can be accessed from context",85],["// We avoid wrapping a StructBox, because under 64 JIT we get some \"hard\" tailcalls which affect performance",23],["// it appears we're getting some typings recorded for non-atomic expressions like \"f x\"",26],["///     can be used to marginally increase accuracy of intellisense results in some situations.",30],["/// This also checks that there are some remaining results",44],["// Error recovery - return some rubbish expression, but replace/annotate",38],["/// Create a new provided type definition, to be located as a nested type in some type definition.",37],["/// Is this a member, if so some more data about the member.",35],["/// Indicates if this is an F# type definition whose r.h.s. is known to be some kind of F# object model definition",34],["/// The name of the method in compiled code (with some exceptions where ilxgen.fs decides not to use a method impl)",32]],"useCount":3170},{"word":"source","context":[["let result = source.ReadUInt32()",242],["let resultType = source.ReadUInt32()",218],["use e = source.GetEnumerator()",308],["// By using this source code in any fashion, you are agreeing to be bound",490],["/// <param name=\"source\">The input sequence.</param>",562],["match source with",235],["checkNonNull \"source\" source",741],["checkNonNull \"source\" source",741],["source http://www.nuget.org/api/v2",168],["// By using this source code in any fashion, you are agreeing to be bound",203]],"useCount":14935},{"word":"sp","context":[["let sp = GenSequencePointForBind cenv cgbuf eenv bind",28],["sigptrFoldAcc f n bytes sp (i+1) (x::acc)",22],["SynSimplePats.SimplePats ([sp],m),laterf",23],["let spKind = Import.ImportProvidedType cenv.amap m (sp.PApply((fun x -> x.ParameterType), m))",29],["let sp =",70],["match sp with",66],["let spName = sp.PUntaint((fun sp -> sp.Name), m)",36],["let spName = sp.PUntaint((fun sp -> sp.Name), m)",36],["let spName = sp.PUntaint((fun sp -> sp.Name), m)",36],["for sp in meth.SequencePoints do",30]],"useCount":2481},{"word":"specified","context":[["/// Download an HTTP web resource from the specified URL synchronously",32],["if returnType <> null then failwith \"Need to handle specified return type in GetPropertyImpl\"",63],["if types      <> null then failwith \"Need to handle specified parameter types in GetPropertyImpl\"",60],["if modifiers  <> null then failwith \"Need to handle specified modifiers in GetPropertyImpl\"",60],["/// The body for POST request can be specified either as text or as a list of parameters",48],["/// that will be encoded, and the method will automatically be set if not specified",48],["/// The order in which the given function is applied to elements of the input array is not specified.</remarks>",42],["///<exception cref=\"T:System.ArgumentException\">Thrown when invalid dimension specified.</exception>",39],["/// Returns a data frame whose rows are indexed based on the specified column of the original",32],["/// If <c>cancelAction</c> is not specified, then cancellation causes the computation",35]],"useCount":2381},{"word":"sprintf","context":[["~~ (sprintf \" %s \" op)",184],["if declaringType<>null then failwith (sprintf \"ProvidedConstructor: declaringType already set on '%s'\" (nameText()));",60],["| Some _ -> failwith (sprintf \"ProvidedConstructor: code already given for '%s'\" (nameText()))",60],["| _ -> failwith (sprintf \"ApplyStaticArguments: static params for type %s are unexpected\" ty.FullName)",62],["override x.ToString() = sprintf \"%A\" x",63],["let name = sprintf \"@param%i\" i",63],["failwith (sprintf \"unknown expression '%A' in generated method\" n)",64],["sprintf",78],["sprintf \"\"\"",78],["Printf.sprintf \"Variable lookup failure: offset: %d, ctx size: %d\"",96]],"useCount":6986},{"word":"src","context":[["\"../../src/FSharpVSPowerTools.Core/Lexer.fs\"",34],["Name = \"src/app/FAKE/Cli.fs\"",77],["github fsharp/FAKE src/app/FakeLib/Globbing/Globbing.fs",62],["Name = \"src/app/FAKE/FileWithCommit.fs\"",62],["src.CopyTo(res)",52],["github fsprojects/Chessie src/Chessie/ErrorHandling.fs",50],["\"../../src/FSharpVSPowerTools.Core/LanguageService.fs\"",34],["#load \"../../src/FSharpVSPowerTools.Core/Utils.fs\"",34],["\"../../src/FSharpVSPowerTools.Core/AssemblyContentProvider.fs\"",34],["\"../../src/FSharpVSPowerTools.Core/CompilerLocationUtils.fs\"",34]],"useCount":1879},{"word":"st","context":[["let tag = u_byte st",301],["let a = p1 st in let b = p2 st in let c = p3 st in let d = p4 st in",104],["let e = p5 st in let f = p6 st in let x7 = p7 st in let x8 = p8 st in",104],["let a = p1 st in let b = p2 st in let c = p3 st in let d = p4 st in",104],["let a = p1 st in let b = p2 st in let c = p3 st in let d = p4 st in",104],["match st with",113],["match u_byte st with",117],["let e = p5 st in let f = p6 st in let x7 = p7 st in let x8 = p8 st in",104],["st",124],["let st = info.ProvidedType",131]],"useCount":21928},{"word":"stack","context":[["match stack with",152],["match i.stack with",42],["not i.stack.IsEmpty",42],["stack",43],["s\" Invalid parameters\" exception constant exp-invalid-parameters ( -- n = Invalid parameters on stack )",44],["rebuild cfg env stack t",50],["stack.Push l",56],["stack.Push r",56],["stack.Push(Compiling (fun gen ->",61],["// if we need result and method produce void and result should be unit - push null as unit value on stack",64]],"useCount":4047},{"word":"start","context":[["let start = System.DateTime.Now",76],["for i = fin downto start do",64],["start proc",65],["/// <param name=\"start2\">The start index of the second dimension.</param>",68],["/// <param name=\"start1\">The start index of the first dimension.</param>",68],["let start =",63],["|> Actor.start",81],["list MalList/start @ cell+ { arg0 }",80],["start chrome",42],["let (tab,idx) = seekReadUncodedToken ctxt.is (start + (!curr))",72]],"useCount":4903},{"word":"state","context":[["let state =",169],["/// <param name=\"state\">The initial state.</param>",188],["/// <param name=\"state\">The initial state.</param>",188],["state {",197],["state",892],["match state with",397],["let mutable state = state",271],["let mutable state = state",271],["return state",242],["fun state ->",239]],"useCount":11522},{"word":"static","context":[["static member Result : ('T -> 'T) = result",153],["static member Default =",136],["/// static conversion method on the input type.</summary>",288],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["/// Event handler defined on server-side, lambda must be a call to a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["static member Empty =",251],["static member Mapping =",202],["static do Android.Runtime.ResourceIdManager.UpdateIdValues()",189],["static let result : ('T -> 'T) =",153]],"useCount":18247},{"word":"str","context":[["let str =",85],["checkNonNull \"str\" str",60],["let nonNull str x = if x=null then failwith (\"Null in \" + str) else x",63],["let nonNull str x = if x=null then failwith (\"Null in \" + str) else x",63],["else str",68],["let str = emptyIfNull str",75],["let str = emptyIfNull str",75],["/// <param name=\"str\"></param>",90],["str",105],["match str with",147]],"useCount":4027},{"word":"stream","context":[["use reader = new StreamReader(stream)",72],["stream.Close()",86],["stream",95],["stream.Close ()",71],["fun stream ->",150],["let len = stream.Length",70],["/// <param name=\"stream\">The input stream.</param>",62],["use stream = resStream.Stream",59],["/// <param name=\"stream\">The input stream.</param>",62],["let n = stream.Read(buf, 0, int rem)",59]],"useCount":3818},{"word":"string","context":[["member AddDefinitionLocation : line:int * column:int * filePath:string -> unit",249],["let nullArr = null:string[]",262],["member AddXmlDocComputed   : xmlDocFunction: (unit -> string) -> unit",242],["member Name: string",226],["Name: string",262],["member AddXmlDocDelayed   : xmlDocFunction: (unit -> string) -> unit",275],["// string List",383],["Name : string",395],["// string Seq",431],["// string array",549]],"useCount":51822},{"word":"struct","context":[["struct Attenuation",44],["struct SpotLight",44],["// Note: static calls never mutate a struct object argument",40],["struct",1082],["/// Get a list of all instance fields for F#-defined record, struct and class fields in this type definition.",34],["struct%",47],["struct BaseLight",53],["struct DirectionalLight",54],["struct PointLight",58],["struct{",154]],"useCount":3421},{"word":"summary","context":[["/// <summary>",536],["/// <summary>Creates an instance of the attribute</summary>",427],["/// <summary>Creates an instance of the attribute</summary>",427],["/// </summary>",666],["/// </summary>",12770],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234],["///<summary>",251],["/// <summary>",12844],["///</summary>",496],["/// static conversion method on the input type.</summary>",288]],"useCount":36585},{"word":"sw","context":[["sw.Restart()",64],["let sw = new System.Diagnostics.Stopwatch()",362],["let sw = Stopwatch.StartNew()",114],["let sw = Stopwatch()",94],["sw.Start()",489],["sw.Stop()",574],["times, sw",64],["let sw = System.Diagnostics.Stopwatch.StartNew()",52],["let sw = new Stopwatch()",40],["let sw = System.Diagnostics.Stopwatch()",39]],"useCount":2820},{"word":"swap","context":[["r> swap",33],["swap 1+ swap",33],["swap 1+ swap",33],["1 swap +!",34],["swap !",42],["nil swap !",36],["swap",407],["swap >r",95],["0 swap !",37],["-1 swap +!",39]],"useCount":1935},{"word":"symbol","context":[["| Some symbol ->",26],["yield FSharpSymbolUse(scope.TcGlobals, denv, symbol, itemOcc, m) |])",26],["let signature = getFuncSignature symbol.DisplayContext func",24],["match symbol.FullTypeSafe with",25],["Some(signature, getSummaryFromSymbol func, footerForType symbol)",24],["match symbol with",210],["/// Represents the type constructor in a provided symbol type.",68],["| _ -> raise <| Error.errExpectedX \"symbol\"",63],["match symbol.Symbol with",57],["(* check what comes after the symbol is a number *)",32]],"useCount":1919},{"word":"synExpr","context":[["[dive synExpr synExpr.Range traverseSynExpr",90],["walkExpr synExpr",286],["getRangesSynExprK synExpr (fun r1 ->",138],["traverseSynExpr synExpr",108],["[dive synExpr synExpr.Range traverseSynExpr",90],["if AstTraversal.rangeContainsPosLeftEdgeInclusive synExpr.Range pos then",90],["TcIndexerThen cenv env overallTy mWholeExpr mDot tpenv synExpr e1 e2 delayed",36],["Some(synExpr.Range)",44],["[yield dive synExpr synExpr.Range traverseSynExpr",45],["[yield dive synExpr synExpr.Range traverseSynExpr",45]],"useCount":2411},{"word":"syntax","context":[["/// Indicates the type prefers the \"tycon<a,b>\" syntax for display etc.",38],["/// F# syntax: match expr with pat1 -> expr | ... | patN -> exprN",21],["/// F# syntax: 1.30, 1.40e10 etc.",21],["/// Note the member kind is actually computed partially by a syntax tree transformation in tc.fs",22],[".AppendLine(syntax)",23],["syntax-expr",25],["/// Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI'",27],["/// <c>async { ... }</c> computation expression syntax.</remarks>",70],["// no arguments are given or else based on the syntax of the arguments.",40],["/// Set if the user has explicitly turned indentation-aware syntax on/off",34]],"useCount":3537},{"word":"t","context":[["match t.n with",201],["| h :: t ->",107],["let (~~) (t:string) = sb.Append t |> ignore",119],["let (~~) (t:string) = sb.Append t |> ignore",119],["| _ -> t",127],["| Some t ->",175],["let t =",184],["match t with",1845],["t",526],["| h::t ->",378]],"useCount":37141},{"word":"t1","context":[["member t.Item1 = t1",72],["let t1 = (DateTime.UtcNow)",70],["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",72],["match t1 with",75],["if idx1 < idx2 then -1 elif idx1 > idx2 then 1 else compare t1.Tag t2.Tag",140],["match t1,t2 with",75],["emitConvIfNecessary t1",102],["if t1 = typeof<decimal> then",102],["| TmApp (fi, t1, t2) ->",81],["match t1, t2 with",78]],"useCount":7945},{"word":"t2","context":[["| TmApp (fi, t1, t2) ->",81],["match t1, t2 with",78],["let t2 = (DateTime.UtcNow)",70],["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",72],["let h2 = head t2",114],["let t2 = tail r1",114],["match t1,t2 with",75],["let t3 = tail t2",96],["if idx1 < idx2 then -1 elif idx1 > idx2 then 1 else compare t1.Tag t2.Tag",140],["| TmAbs (fi, x, tyT1, t2) ->",82]],"useCount":6340},{"word":"tab","context":[["let tab = (tycons,structuralTypes) ||> List.map2 (fun tycon c -> tycon.Stamp, (tycon,c)) |> Map.ofList",32],["getUncodedToken tab idx",45],["elif tab = TableNames.MemberRef then",36],["let codedBigness nbits tab =",37],["let (tycon,_) = tab.[tyconStamp]",40],["let addValByName (x:Val) tab =",40],["let (tycon,structuralTypes) = tab.[tyconStamp]",40],["let tab =",51],["let (tab,idx) = seekReadUncodedToken ctxt.is (start + (!curr))",72],["tab",184]],"useCount":2828},{"word":"table","context":[["/// <param name=\"table\">The input map.</param>",147],["/// <param name=\"Labels\">Labels for the data table columns.</param>",119],["</table>",98],["let key = table.PutItem item",83],["<table>",53],["table",51],["member __.GetPrimaryKey(table) =",46],["member __.GetColumns(con,table) =",46],["match pkLookup.TryGetValue table.FullName with",40],["member __.GetRelationships(con,table) =",44]],"useCount":4144},{"word":"tag","context":[["let tag =",75],["| tag when tag = tdor_TypeSpec ->",36],["member x.Tag = tag",72],["TaggedIndex(tag,tok)",44],["let tag = u_byte_as_int st",42],["| tag when tag = tdor_TypeSpec ->",36],["| Attr (tag,attrs,l) ->",36],["for tag in 0 .. tables.numTerminals-1 do",32],["let tag = u_byte st",301],["match tag with",608]],"useCount":4326},{"word":"tail","context":[["let t32 = tail t31",80],["let t31 = tail r3",80],["let t2c = tail r1c",84],["let t3 = tail t2",96],["let t22 = tail t21",96],["let t01 = tail r0",96],["let t21 = tail r2",96],["let t12 = tail t11",100],["let t11 = tail r1",112],["let t2 = tail r1",114]],"useCount":4383},{"word":"target","context":[["target.Write(resultType)",218],["target.Write(result)",242],["target",104],["///  - `targets` - A string with the target names which should be run by MSBuild.",78],["/// <param name=\"target\">The target array.</param>",69],["let target =",56],["/// <param name=\"overwrite\">Enables overwriting of target file if it exists. Defaults to false.</param>",64],["match target with",119],["/// <param name=\"target\">The target array.</param>",69],["target.Write(v)",50]],"useCount":4950},{"word":"targets","context":[["sprintf \"%s$(%s).targets\" buildPath propertyName",29],["tree',targets'",38],["let targets =",38],["| Expr.Match (_,_,dtree,targets,_,_) ->",38],["simplifyTrivialMatch spBind exprm matchm ty tree targets",38],["tree,targets",57],["///  - `targets` - A string with the target names which should be run by MSBuild.",78],["targets",63],["| Some p -> p.Equals(\"$(SolutionDir)\\\\.nuget\\\\nuget.targets\",",29],["| _ -> failwithf \"Unknown .targets filename %s\" propertyName",29]],"useCount":2880},{"word":"tau","context":[["let tpsorig,tau =  vref.TypeScheme",39],["| [] -> auxTypeL env tau",38],["| _ -> (auxTypeL env tau --- auxTyparConstraintsL env env.postfixConstraints)",38],["tps,tau",38],["let tau,cxs = tau,[]",38],["let _, tau = v.TypeScheme",39],["let tau = v.TauType",46],["let env = SimplifyTypes.CollectInfo false [tau] cxs",57],["NormalValUse,tinst,tau,tpenv",40],["if isFunTy denv.g tau && (arityOfVal v).HasNoArgs then",40]],"useCount":2397},{"word":"tc","context":[["let graph = Graph<Tycon, Stamp> ((fun tc -> tc.Stamp), tycons, edges)",40],["| TType_app (tc,tinst) ->",39],["for rf in tc.AllFieldsAsList do",38],["for uc in tc.UnionCasesAsList do",38],["for vref in tc.MembersOfFSharpTyconSorted do",38],["use p = ServiceProxy.getOrganizationServiceProxy m tc",35],["let tc = m.Authenticate(ac)",33],["let fields = tc.TrueInstanceFieldsAsList",33],["let graph = Graph<Tycon, Stamp> ((fun tc -> tc.Stamp), tycons, edges)",40],["tc",25]],"useCount":2784},{"word":"tcConfig","context":[["let tcConfig = tcConfigP.Get()",181],["SqmLoggerWithConfig tcConfig errorLogger.ErrorNumbers errorLogger.WarningNumbers",83],["let tcConfigB = tcConfig.CloneOfOriginalBuilder",80],["let tcConfigP = TcConfigProvider.Constant(tcConfig)",63],["AbortOnError(errorLogger, tcConfig, exiter)",59],["AbortOnError(errorLogger,tcConfig,exiter)",57],["match tcConfig.version with",48],["let file = tcConfig.ResolveSourceFile(rangeStartup,file,tcConfig.implicitIncludeDir)",41],["let file = tcConfig.ResolveSourceFile(rangeStartup,file,tcConfig.implicitIncludeDir)",41],["let tcConfig = TcConfig.Create(tcConfigB,validate=false)",184]],"useCount":7574},{"word":"tcConfigB","context":[["let addReferencedAssemblyByPath = fun () (m,s) -> tcConfigB.AddReferencedAssemblyByPath(m,s)",40],["| None -> tcConfigB.lcid <- lcidFromCodePage",40],["TcConfig.Create(tcConfigB,validate=false),nowarns",40],["SqmLoggerWithConfigBuilder tcConfigB delayForFlagsLogger.ErrorNumbers delayForFlagsLogger.WarningNumbers",68],["TcConfig.Create(tcConfigB,validate=false)",69],["delayForFlagsLogger.ForwardDelayedErrorsAndWarnings(tcConfigB)",72],["let tcConfigB = tcConfig.CloneOfOriginalBuilder",80],["testingAndQAFlags       tcConfigB])",38],["let tcConfig = TcConfig.Create(tcConfigB,validate=false)",184],["if tcConfigB.utf8output then",40]],"useCount":7797},{"word":"tcGlobals","context":[["g=tcGlobals;",28],["if tcConfig.useOptimizationDataFile || tcGlobals.compilingFslib || isCompilerServiceDll then",21],["let optEnv0 = GetInitialOptimizationEnv (tcImports, tcGlobals)",25],["TypeCheck(tcConfig,tcImports,tcGlobals,errorLogger,assemblyName,NiceNameGenerator(),tcEnv0,inputs,exiter)",27],["let tcGlobals,frameworkTcImports = TcImports.BuildFrameworkTcImports (foundationalTcConfigP, sysRes, otherRes)",27],["tcGlobals: TcGlobals,",36],["let tcGlobals,tcImports =",40],["match TryFindFSharpAttribute tcGlobals (mkMscorlibAttrib tcGlobals attrib) attribs with",51],["match TryFindFSharpAttribute tcGlobals (mkMscorlibAttrib tcGlobals attrib) attribs with",51],["tcGlobals,tcImports",57]],"useCount":2099},{"word":"tcImports","context":[["match tcImports.TryFindDllInfo(Range.rangeStartup,ilAssemRef.Name,lookupOnly=false) with",38],["tcImports",39],["let importMap = tcImports.GetImportMap()",40],["let tcGlobals,tcImports =",40],["tcImports: TcImports,",49],["ImportProvidedType = (fun ty -> Import.ImportProvidedType (tcImports.GetImportMap()) m ty)",54],["match look tcImports with",60],["let amap = tcImports.GetImportMap()",97],["tcGlobals,tcImports",57],["let g = tcImports.GetTcGlobals()",38]],"useCount":3319},{"word":"tcref","context":[["match tcref.TypeReprInfo with",99],["| Parent tcref ->",100],["let tcrefs = tcrefs |> List.map (fun tcref -> (resInfo,tcref))",102],["let tcrefs = tcrefs |> List.map (fun tcref -> (resInfo,tcref))",102],["let tcref = tcrefOfAppTy g typ",103],["let tinst,ty = mkMinimalTy g tcref",104],["let tycon = tcref.Deref",112],["let tcref,tinst = destAppTy g ty",171],["let tcref = mkLocalTyconRef tycon",206],["| Some tcref ->",112]],"useCount":16390},{"word":"td","context":[["for ntd in td.GetNestedTypes(ALL) do",52],["<tr><td>1</td></tr>",30],["let rec typeMembers (tb:TypeBuilder)  (td : ProvidedTypeDefinition) =",63],["let env = envForTypeDef td",45],["let tidx = GetIdxForTypeDef cenv (TdKey(enc,td.Name))",45],["GenericParams= td.GenericParams;",41],["match td.tdKind with",37],["| ILTypeMetadata (_,td) -> (td.tdKind = ILTypeDefKind.Interface)",34],["| ILTypeMetadata (_,td) -> (td.tdKind = ILTypeDefKind.Interface)",34],["match td.Layout with",30]],"useCount":2563},{"word":"tdef","context":[["let nesting = nesting @ [tdef]",80],["member tdef.IsStructOrEnum =",23],["traverseTypeDef priority tref tdef;",26],["ILTypeMetadata (scoref,tdef)",34],["| Some mref -> (resolveILMethodRef tdef mref).Access",34],["| ILTypeMetadata (scoref,tdef) ->",43],["match tdef with",46],["| ILTypeMetadata (_,tdef) ->",107],["let tref = mkRefForNestedILTypeDef ILScopeRef.Local (nesting,tdef)",80],["let tdef =",51]],"useCount":2723},{"word":"test","context":[["[<Ignore(\"Remove to run test\")>]",799],["/// <param name=\"predicate\">The function to test the input elements.</param>",207],["// Sample usage test cases.",170],["let test () =",118],["let test sql =",97],["// if exist test.ok (del /f /q test.ok)",92],["// if exist test.ok (del /f /q test.ok)",92],["test <@ %query = %expected @>",82],["test <@ %update = %expected @>",72],["/// <param name=\"predicate\">A function to test each source element for a condition.</param>",70]],"useCount":6158},{"word":"text","context":[["text",209],["let text =",221],["/// It is important that the text of the xml doc only get forced when poking on the ConstructorArguments",64],["let text = String.Join(\",\",paras |> Array.map (fun p -> p.ParameterName))",68],["let text = \"\"\"type file",76],["/// Called by the evaluation session to ask the host for parameters to format text for output",110],["FSharpToolTipElement.Single(text, xml)",115],["/// <param name=\"lineText\">The text of the line where the information is being requested.</param>",59],["/// Called by the evaluation session to ask the host for parameters to format text for output",60],["// XML doc text that we only compute once, if any. This must _not_ be forced until the ConstructorArguments",64]],"useCount":5832},{"word":"than","context":[["/// will result in a more efficient application than applying the arguments successively.</summary>",36],["invalidArg \"count\" \"Must be greater than zero and less than the number of keys.\"",24],["| Silent -> \"Doesn't trace other output than the search result.\"",34],["| _ -> failwith (sprintf \"There is more than one nested type called '%s' in type '%s'\" name this.FullName)",60],["beginning of the box rather than 2 more columns to the right",54],["// the bool is true if / rather than * follows the type",25],["///given probabilities. The sum of the probabilities must be larger than zero.",25],["// (that's better than the next case - here we'd return 'int' as a type)",26],[": if specified more than once, acts as an OR operation",26],["| Silent -> \"Doesn't trace other output than installed packages.\"",26]],"useCount":1897},{"word":"that","context":[["// Return the disposable object that cleans up",76],["// the first key. For each bucket, call 'nodef' on that head key and the bucket.",79],["/// not in the subset that can be converted to a LINQ expression tree",71],["// This sets a value in another module to indicate that initialization has happened",85],["override this.Equals(that:obj) =",94],["match that with",300],["// /// <param name=\"Labels\">The labels that match the data.</param>",301],["/// <param name=\"Labels\">The labels that match the data.</param>",392],["override this.Equals(that) =",89],["// COM, set the ComVisible attribute to true on that type.",997]],"useCount":22277},{"word":"the","context":[["// You can specify all the values or you can default the Build and Revision Numbers",1037],["// You can specify all the values or you can default the Build and Revision Numbers",1037],["// Version information for an assembly consists of the following four values:",1046],["// set of attributes. Change these attribute values to modify the information",1064],["// General Information about an assembly is controlled through the following",1065],["// by using the '*' as shown below:",1021],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["// Setting ComVisible to false makes the types in this assembly not visible",997],["// COM, set the ComVisible attribute to true on that type.",997]],"useCount":210804},{"word":"them","context":[["// Find all the items with a non-empty key list. Bucket them together by",79],["// If we have nonempty items from environment that were resolved from a type, then use them...",26],["// A huge number of these occur in pickled F# data, so make them unique",52],["// only logical way to deal with them.",46],["// of which there can be many. Simply turn them all into one big AND expression as that is the",46],["/// Returns a supervisor strategy appliable to each supervised actor when any of them had faulted during execution.",41],["/// Pulls new paket.targets and bootstrapper and puts them into .paket folder.",24],["| None, true -> failwith \"Could not parse condition; multiple conditions found with no \\\"AND\\\" or \\\"OR\\\" between them.\"",25],["// Now report them",40],["// and unit type inference. Normalize them here",38]],"useCount":2412},{"word":"then","context":[["if cenv.reportErrors then",235],["if verbose then",275],["then None",304],["if isUnresolved() then false else",324],["let cleanFileName a = if a = fileName1 then \"file1\" else \"??\"",343],["then ;",450],["if bExist then",463],["if c <> 0 then c else",662],["if not success then",205],["then",6585]],"useCount":125739},{"word":"there","context":[["/// <exception cref=\"Soma.Core.NoAffectedRowException\">Thrown when there is no affected row.</exception>",48],["// there's probably a nicer way to do this",46],["/// Note that because of signatures, there are situations where in a single compilation the \"same\"",34],["// If there is an unblock handle, set it.",34],["// if there are both intrinsics and extensions in pinfos, intrinsics will be listed first.",36],["// there seems to be no way to check if a type abbreviation exists",38],["// Because there is only one accessible method info available based on the name of the item",40],["/// This also checks that there are some remaining results",44],["// For non-generic type providers there is no difference",34],["// of which there can be many. Simply turn them all into one big AND expression as that is the",46]],"useCount":2706},{"word":"these","context":[["// set of attributes. Change these attribute values to modify the information",1064],["(* The printing functions call these utility functions to insert grouping",54],["// A huge number of these occur in pickled F# data, so make them unique",52],["// construct arising out the compilation of pattern matching. We decode these back to the form",44],["//    then it also asserts.  But these are edge cases that can be fixed later, e.g. in bug 4651.",40],["// QUERY: should these be false for non-equal rigid typars? warn-if-not-rigid typars?",28],["//  -- \"contract\" ones, which are part of the return type. We separate these to enable use to",32],["// Don't print individual methods forming interface implementations - these are currently never exported",34],["// We only count one argument block for these.",36],["/// Set the method attributes of the method. By default these are simple 'MethodAttributes.Public'",37]],"useCount":4168},{"word":"they","context":[["// functionality System.Reflection for dynamic modules that means they can't be read back out",21],["// Compute the object arguments as they appear in a compiled call",22],["// First, use unfiltered name resolution items, if they're not empty",26],["//     - show types before over other related items - they usually have very useful XmlDocs",27],["/// CSV file (if they are present) and infers the type of values for each column. Columns",30],["ILAttributeNamedArg list (* named args: values and flags indicating if they are fields or properties *)",34],["// This breaks certain invariants that hold elsewhere, because they dereference to point to",38],["// method will take. Optional and out args are _not_ included, which means they will be resolved",40],["/// Post-filter items to make sure they have precisely the right name",44],["// These don't have to return fully accurate results - they are used",60]],"useCount":2134},{"word":"this","context":[["// By using this source code in any fashion, you are agreeing to be bound",490],["\\ * which accompanies this distribution, and is available at",436],["this",460],["member this.Usage =",501],["override this.ToString() =",631],["this.Parse \"\"\"",656],["// to COM components.  If you need to access a type in this assembly from",997],["// Setting ComVisible to false makes the types in this assembly not visible",997],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["match this with",2361]],"useCount":83239},{"word":"through","context":[["/// later through 'open' get priority in overload resolution.",32],["// These come through as an empty plid and residue \"\". Otherwise we try an environment lookup",24],["(* General Information about an assembly is controlled through the following",26],["/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then",30],["// Walk through the tree of scopes and write all variables",30],["// General Information about an assembly is controlled through the following",1065],["/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>",57],["// No dotting through type generators to get to a nested type!",45],["// The state of the left-to-right iteration through the bindings",38],["/// Applies a function to each element of the collection, threading an accumulator argument through the computation.",36]],"useCount":2813},{"word":"time","context":[["//dist *= nsin(time);",101],["Console.WriteLine(\"  \" + test + \" execution time (kernel is compiled): \" + timer.ElapsedMilliseconds.ToString() + \"ms\")",27],["/// It will be invoked each time, an actor will receive a message.",28],["does> ( Compilation: -- ) ( Run-time: -- w )",32],["// At compile-time we check arithmetic",34],["/// The assembly is only emitted when the Assembly property on the root type is accessed for the first time.",37],["/// <param name=\"timeout\">Defines time window for number of retries to occur.</param>",54],["if (dist < 0.1 + 0.3*nsin(time)) {",101],["uniform float time;",141],["/// The documentation is re-computed  every time it is required.",212]],"useCount":2067},{"word":"tinst","context":[["NormalValUse,tinst,tau,tpenv",40],["(tinst, tcref.TyparsNoRange) ||> List.lengthsEqAndForall2 (fun ty tp ->",40],["match tinst with",120],["let tcref,tinst = destAppTy g ty",171],["| SpecialEquatableHeadType g tinst ->",42],["/// Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)",45],["MakeCheckSafeInit g tinst safeStaticInitInfo (mkInt g m idx) expr",60],["let tinst = finfo.TypeInst",60],["let tcref,tinst = destAppTy g typ",76],["let tinst,ty = mkMinimalTy g tcref",104]],"useCount":7277},{"word":"title","context":[["/// <param name=\"TitleAlignment\">The alignment of the title for the axis</param>",56],["Title = title",35],["match (entry |> getNode \"properties\" |> optGetNode \"Id\") ++ (entry |> getNode \"title\") with",42],["/// <param name=\"TitleFontSize\">The font size for the title of the axis</param>",56],["/// <param name=\"TitleColor\">The color of the title of the axis</param>",56],["/// <param name=\"Title\">The title of the axis</param>",56],["/// <param name=\"TitleFontName\">The font name for the title of the axis</param>",56],["/// <param name=\"XTitle\">The title of the X-axis.</param>",753],["/// <param name=\"YTitle\">The title of the Y-axis.</param>",753],["/// <param name=\"Title\">The title of the chart.</param>",753]],"useCount":3281},{"word":"tmenv","context":[["let tps',tmenvinner = tmenvCopyRemapAndBindTypars (remapAttribs g tmenv) tmenv tps",38],["let op' = remapOp tmenv op",19],["let e1' = remapExpr g compgen tmenv e1",38],["let _,_,tmenvinner = copyAndRemapAndBindTyconsAndVals g compgen tmenv tycons vs",38],["let tps',tmenvinner = tmenvCopyRemapAndBindTypars (remapAttribs g tmenv) tmenv tps",38],["let mdef = copyAndRemapModDef g compgen tmenv mdef",38],["let args' = remapExprs g compgen tmenv args",38],["let arg = remapExpr g compgen tmenv arg",23],["let tinst = remapTypes tmenv tinst",23],["let bind',tmenvinner = copyAndRemapAndBindBinding g compgen tmenv bind",38]],"useCount":4356},{"word":"to","context":[["[<Ignore(\"Remove to run test\")>]",799],["// set of attributes. Change these attribute values to modify the information",1064],["// The following GUID is for the ID of the typelib if this project is exposed to COM",998],["// to COM components.  If you need to access a type in this assembly from",997],["// to COM components.  If you need to access a type in this assembly from",997],["// Setting ComVisible to false makes the types in this assembly not visible",997],["// COM, set the ComVisible attribute to true on that type.",997],["// By using this source code in any fashion, you are agreeing to be bound",490],["for i = 0 to len - 1 do",403],["/// <param name=\"input\">The input expression to match against.</param>",315]],"useCount":90081},{"word":"toArray","context":[["|> Seq.toArray",1381],["|> Seq.toArray)",43],["|> List.toArray",359],["} |> Seq.toArray",148],["let assemblies = assemblies |> Seq.toArray",47],["override this.GetParameters() = parameters |> List.toArray",46],["|> CloudFlow.toArray",71],["let elems = membersQueue |> Seq.toArray // take a copy in case more elements get added",63],["|> toArray",51],["let elems = interfaceImplsDelayed |> Seq.toArray // take a copy in case more elements get added",60]],"useCount":3562},{"word":"toList","context":[["|> Option.toList",60],["|> Map.toList",97],["} |> Seq.toList",85],["|> Set.toList",97],["Quotations.Expr.Call(parameters.[0], minfo, Array.toList parameters.[1..])",59],["Quotations.Expr.NewObject(cinfo, Array.toList parameters)",60],["Quotations.Expr.Call(minfo, Array.toList parameters)",60],["let namespaceParts = match ty.Namespace with null -> [] | s -> s.Split '.' |> Array.toList",63],["|> Seq.toList",2561],["|> Array.toList",512]],"useCount":7207},{"word":"tok","context":[["| Parser.Error (num, tok, err, _, _) -> printErr (num, tok, err)",28],["| Parser.Error (num, tok, err,_, _) -> printErr (num, tok, err)",32],["| Parser.Error (num, tok, err,_, _) -> printErr (num, tok, err)",32],["| Parser.Error (num, tok, err) -> printErr (num, tok, err)",34],["| Parser.Error (num, tok, message) -> printErr (num, tok, message)",30],["| Parser.Error (num, tok, err) -> printErr (num, tok, err)",34],["tok",35],["| Parser.Error (num, tok, message) -> printErr (num, tok, message)",30],["TaggedIndex(tag,tok)",44],["match tok with",51]],"useCount":1843},{"word":"token","context":[["if args.aux.token.IsCancellationRequested then",52],["/// This function maps integers indexes to symbolic token ids",64],["type token =",65],["// This type is used to give symbolic names to token indexes, useful for error messages",88],["match token with",468],["returnToken tokenLexbufState token",576],["val token_to_string: token -> string",53],["/// This function gets the name of a token as a string",53],["type token =",54],["val tagOfToken: token -> int",53]],"useCount":7552},{"word":"tokenTup","context":[["let tokenReplaced = rulesForBothSoftWhiteAndHardWhite(tokenTup)",28],["pushCtxt tokenTup (CtxtParen (token,tokenStartPos))",48],["let tokenTup = popNextTokenTup()",84],["delayToken tokenTup",126],["match tokenTup.Token with",140],["tokenTup",40],["pushCtxt tokenTup (CtxtMemberHead(tokenStartPos))",36],["replaceCtxt tokenTup (CtxtModuleHead (moduleTokenPos, token))",36],["replaceCtxt tokenTup (CtxtNamespaceHead (namespaceTokenPos, token))",34],["pushCtxtSeqBlockAt (tokenTup, true, AddBlockEnd)",28]],"useCount":1835},{"word":"top","context":[["// Compute the top-rooted type definitions",40],["/// Is this represented as a \"top level\" static binding (i.e. a static field, static member,",32],["/// When called on the server side, the handler must be a top-level function or a static member.",278],["/// When called on the server side, the handler must be a top-level function or a static member.",284],["// as we process nodes top-to-bottom, this matches the",25],["// it at least does the right thing for top level 'null' list and option values (but not for nested ones).",21],["// Compute the top-rooted module or namespace references",40],["/// Are we in a script? if so relax the reporting of discarded-expression warnings at the top level",20],["let rec top racc  p =",20],["| None -> error(InternalError(\"PartitionValTypars: not a top value\", v.Range))",36]],"useCount":2068},{"word":"tp","context":[["let tp',tpenv = TcTypar cenv env newOk tpenv tp",102],["let tp',tpenv = TcTypar cenv env newOk tpenv tp",102],["unsolved |> List.iter (fun tp ->",60],["if not tp.IsSolved then",49],["let tpn = tp.Stamp",42],["let tp = (destTyparTy cenv.g ty)",40],["let tp',tpenv = TcTypar cenv env NewTyparsOK tpenv tp",40],["for tp in tycon.Typars(tycon.Range) do",40],["(tinst, tcref.TyparsNoRange) ||> List.lengthsEqAndForall2 (fun ty tp ->",40],["match tp.Kind with",111]],"useCount":7446},{"word":"tpenv","context":[["NewErrorType (), tpenv",196],["(tpenv,names,takenNames)",62],["let args',tpenv = TcExprs cenv env m tpenv flexes argtys args",62],["let args',tpenv = TcExprs cenv env m tpenv flexes argtys args",62],["let ty',_ = TcTypeAndRecover cenv NoNewTypars NoCheckCxs ItemOccurence.UseInType env tpenv ty",72],["let tpenv = emptyUnscopedTyparEnv",72],["let tp',tpenv = TcTypar cenv env newOk tpenv tp",102],["let tp',tpenv = TcTypar cenv env newOk tpenv tp",102],["expr,tpenv",178],["tpenv",342]],"useCount":17432},{"word":"tps","context":[["let tps' = copyTypars tps",38],["let topValInfo = ValReprInfo (ValReprInfo.InferTyparInfo tps,[],ValReprInfo.unnamedRetVal)",39],["let tps = NormalizeDeclaredTyparsForEquiRecursiveInference g tps",47],["match tps with",113],["let tps,vsl,body,returnTy = stripTopLambda (expr,vspec.Type)",60],["let tps = NormalizeDeclaredTyparsForEquiRecursiveInference g tps",47],["let tps',tmenvinner = tmenvCopyRemapAndBindTypars (remapAttribs g tmenv) tmenv tps",38],["let tps',tmenvinner = tmenvCopyRemapAndBindTypars (remapAttribs g tmenv) tmenv tps",38],["(tps,paramArgInfos,rty,retInfo)",38],["let tps' = copyTypars tps",38]],"useCount":5935},{"word":"trace","context":[["match trace with",107],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty1 ++ (fun () ->",98],["/// Determines whether or not an item corresponding to this trace is shown in the legend.",31],["/// Determines which trace information appear on hover.",31],["| Silent -> \"Doesn't trace other output than the search result.\"",34],["GenericChart.Chart (trace,None)",35],["let trace =",41],["SolveDimensionlessNumericType csenv ndeep m2 trace argty1 ++ (fun () ->",42],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace rty argty ++ (fun () ->",70],["SolveTypEqualsTypKeepAbbrevs csenv ndeep m2 trace argty2 argty1 ++ (fun () ->",78]],"useCount":3647},{"word":"trans","context":[["trans (mkGet e.Type i (trans e))",56],["else trans (Quotations.Expr.Call(e,tagMeth,[]))",55],["let trans : uint16[] array =",58],["trans (mkCtor items tupleTy)",56],["Quotations.Expr.Lambda(v, trans body)",56],["trans (mkGet e.Type i (trans e))",56],["let rec trans q =",59],["trans (Quotations.Expr.Call(trans f, f.Type.GetMethod \"Invoke\", [ e ]) )",55],["|> trans",233],["trans <@@ (%%(tagExpr) : int) = tagNumber @@>",59]],"useCount":2142},{"word":"tree","context":[["// (i.e., the tree was modified).",106],["match tree with",598],["// Only create a new tree when the subtree is actually modified.",64],["* FSharp.Quotations.Compiler - a compiler for F# expression tree",56],["| Success tree ->",41],["/// returning the value along with the updated tree.",50],["/// * recurseOnMatch - If a match is found continues down the tree matching child elements",60],["simplifyTrivialMatch spBind exprm matchm ty tree targets",38],["/// not in the subset that can be converted to a LINQ expression tree",71],["tree,targets",57]],"useCount":4242},{"word":"tref","context":[["let tref = tcref.CompiledRepresentationForNamedType",33],["| Some tref ->",35],["| Item.ExnCase tref -> Some(ArgumentContainer.Type(tref))",36],["| Item.ExnCase tref -> Some(ArgumentContainer.Type(tref))",36],["let mref = mkILCtorMethSpecForTy(tref,[cenv.g.ilg.typ_Object]).MethodRef",40],["let tref = tspec.TypeRef",41],["match tref.Enclosing with",43],["let (AttribInfo(tref,_)) = g.attrib_SystemObsolete",52],["let tref = mkRefForNestedILTypeDef ILScopeRef.Local (nesting,tdef)",80],["let typB  = envGetTypB emEnv tref",32]],"useCount":5215},{"word":"true","context":[["true",4186],["if true then",192],["|> shouldEqual true",212],["true)",232],["|> should equal true",407],["while true do",493],["// COM, set the ComVisible attribute to true on that type.",997],["| _ -> true",594],["| true ->",431],["| None -> true",445]],"useCount":51960},{"word":"try","context":[["try",15964],["(try",163],["try f()",60],["let runningOnMono = try System.Type.GetType(\"Mono.Runtime\") <> null with e -> false",44],["(try Thread.ResetAbort() with _ -> ());",42],["//    try",39],["//        try",37],["try  ComputeProvider.Create(platformName, deviceType)",37],["try body resource",36],["//try",30]],"useCount":20028},{"word":"tryFind","context":[["match dependenciesFile.Groups |> Map.tryFind groupName with",67],["match groups |> Map.tryFind groupName with",132],["match types |> Array.tryFind (fun ty -> ty.Name = typeName) with",63],["|> Seq.tryFind IO.File.Exists",59],["let implicitCtorArgFieldOpt = implicitCtorArgsAsFields |> List.tryFind (fun f -> f.Name = v.Name)",58],["match structuralTypes |> List.tryFind (fst >> checkIfFieldTypeSupportsComparison tycon >> not) with",40],["match structuralTypes |> List.tryFind (fst >> checkIfFieldTypeSupportsEquality tycon >> not) with",40],["match referencesFile.Groups |> Map.tryFind groupName with",40],["match Map.tryFind key map with",36],["match lockFile.Groups |> Map.tryFind groupName with",99]],"useCount":2876},{"word":"tspec","context":[["let tref = tspec.TypeRef",41],["| ILType.Boxed tspec | ILType.Value tspec -> tspec.TypeRef",23],["| ILType.Boxed tspec | ILType.Value tspec -> tspec.GenericArgs",23],["| ILType.Boxed tspec | ILType.Value tspec -> tspec.GenericArgs",23],["| ILType.Boxed tspec | ILType.Value tspec -> tspec.GenericArgs",23],["let tspec = mkILNonGenericTySpec tref",23],["ILType.Value(tspec),sigptr",23],["| ILType.Boxed tspec | ILType.Value tspec -> tspec.TypeRef",23],["| ILType.Boxed  tspec | ILType.Value tspec ->",33],["| ILType.Boxed  tspec | ILType.Value tspec ->",33]],"useCount":2319},{"word":"tuple","context":[["let tuple = ref Unchecked.defaultof<_>",56],["let pool, _ = tuple",24],["// to their default values (for optionals) and be part of the return tuple (for out args).",40],["// result tuple",84],["for tuple in seqs do",27],["let _, del = tuple",34],["/// <param name=\"tuple\">The input tuple.</param>",36],["/// <param name=\"tuple\">The input tuple.</param>",36],["// statically with a tuple type.",36],["/// coerce it to a tuple that satisfies the matching coerced argument type(s).",38]],"useCount":1886},{"word":"two","context":[["/// <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the",26],["/// Combines two path strings using Path.Combine",34],["// Does it take two arguments without side effect?",36],["/// Sequentially compose two actions, passing any value produced by the first as an argument to the second.",36],["/// <summary>Compare two values   </summary>",36],["// The assert below is almost ok, but it fires in two cases:",40],["obox   Open a \"box\" whose contents will be indented by two spaces if",54],["on two lines.",113],["// In other words, the free type variables get divided into two sets",32],["/// Concatenate two addresses, forcing the type of first address.",26]],"useCount":2673},{"word":"ty","context":[["match ty with",838],["else ty",262],["ty",253],["if isTyparTy g ty then",192],["if ty.IsArray then",190],["let tcref,tinst = destAppTy g ty",171],["let rank = ty.GetArrayRank()",129],["elif ty.HasElementType then",129],["| Some ty -> ty",139],["| Some ty -> ty",139]],"useCount":44649},{"word":"ty1","context":[["let equivHeadTypes (ty1:Type) (ty2:Type) =",38],["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",72],["let ty1 = stripTyEqns g ty1",42],["match ty1,ty2 with",42],["let ty1 = stripTyEqns g ty1",42],["let e1',ty1,tpenv = TcExprOfUnknownType cenv env tpenv e1",40],["if ty1.IsGenericType then",39],["isNamedType(ty1) &&",39],["ty2.IsGenericType && (ty1.GetGenericTypeDefinition()).Equals(ty2.GetGenericTypeDefinition())",39],["ty1.Equals(ty2)",38]],"useCount":3583},{"word":"ty2","context":[["let t1,t2,tpcs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",36],["let t1, t2, _cxs = NicePrint.minimalStringsOfTwoTypes denv ty1 ty2",72],["let equivHeadTypes (ty1:Type) (ty2:Type) =",38],["ty1.Equals(ty2)",38],["ty2.IsGenericType && (ty1.GetGenericTypeDefinition()).Equals(ty2.GetGenericTypeDefinition())",39],["let ty2 = stripTyEqns g ty2",42],["let (-->) ty1 ty2 = Reflection.FSharpType.MakeFunctionType(ty1,ty2)",33],["let ty2 = stripTyEqns g ty2",42],["match ty1,ty2 with",42],["ty2.IsGenericType && (ty1.GetGenericTypeDefinition()).Equals(ty2.GetGenericTypeDefinition())",39]],"useCount":3287},{"word":"tyOfExpr","context":[["let enumExpr = mkCoerceIfNeeded cenv.g (mkSeqTy cenv.g enumElemTy) (tyOfExpr cenv.g enumExpr) enumExpr",40],["None, (exprT, tyOfExpr g exprT)",117],["None, (ce, tyOfExpr g ce)",78],["let expr = mbuilder.Close(dtree,m,tyOfExpr g e2)",56],["let ty = tyOfExpr cenv.g e1",44],["let exprty = tyOfExpr g e",42],["let exprTy = tyOfExpr cenv.g expr",40],["let e1 = mkCoerceIfNeeded cenv.g (mkSeqTy cenv.g genResultTy) (tyOfExpr cenv.g e1) e1",40],["let mut = (if isStructTy cenv.g (tyOfExpr cenv.g objExpr) then DefinitelyMutates else PossiblyMutates)",40],["let e2 = mkCoerceIfNeeded cenv.g (mkSeqTy cenv.g genResultTy) (tyOfExpr cenv.g e2) e2",40]],"useCount":1983},{"word":"tyT","context":[["| TmAscribe (fi, t1, tyT) ->",40],["let tyT = simplifyty ctx tyT",31],["| VarBind tyT -> tyT",46],["let tyT = simplifyTy ctx tyT",31],["| VarBind tyT -> tyT",46],["then tyT",63],["let tyT = simplifyTy ctx tyT",31],["let tyT = simplifyty ctx tyT",31],["match tyT with",206],["match (tyS, tyT) with",62]],"useCount":2444},{"word":"tyargs","context":[["match tyargs.Length with",72],["CheckTypeInstNoByrefs cenv env m tyargs",68],["| Expr.Op (c,tyargs,args,m) ->",64],["| Expr.Op(op,tyargs,args,m) ->",60],["let tyargsR = ConvTypes cenv env m tyargs",112],["CheckTypeInstNoByrefs cenv m tyargs;",96],["match tyargs with",73],["let tyargs = destTupleTy cenv.g ty",77],["let tcref,tyargs = StripToNominalTyconRef cenv ty",84],["CheckTypeInstNoByrefs cenv env m tyargs;",84]],"useCount":6078},{"word":"tycon","context":[["let id = tycon.Id",60],["let m = tycon.Range",330],["let tcref = mkLocalTyconRef tycon",206],["match tycon.TypeReprInfo with",143],["let tycon = tcref.Deref",112],["let tcaug = tycon.TypeContents",102],["tycon.MembersOfFSharpTyconSorted",98],["let thisTyconRef = mkLocalTyconRef tycon",80],["let envinner = AddDeclaredTypars CheckForDuplicateTypars (tycon.Typars(m)) envinner",76],["match tycon.TypeAbbrev with",74]],"useCount":9724},{"word":"tycons","context":[["| TMDefRec(tycons,binds,mbinds,_) ->",54],["// MUTABILITY; used only during creation and remapping of tycons",76],["let tycons =",51],["let graph = Graph<Tycon, Stamp> ((fun tc -> tc.Stamp), tycons, edges)",40],["tycons",51],["| TMDefRec(tycons,binds,mbinds,m) ->",44],["@ (tycons",34],["for tycon in tycons do",38],["// MUTABILITY; used only when establishing tycons.",38],["let _,_,tmenvinner = copyAndRemapAndBindTyconsAndVals g compgen tmenv tycons vs",38]],"useCount":2307},{"word":"tyenv","context":[["let ilTy = GenType cenv.amap m cenv.g eenv.tyenv ty",48],["let ilTypeInst = GenTypeArgsAux amap m g tyenv tinst",32],["let ilElemTy = GenType cenv.amap m cenv.g eenv.tyenv elemTy",32],["let fspec = GenRecdFieldRef m cenv eenv.tyenv rfref tyargs",32],["let ilty = GenType cenv.amap m cenv.g eenv.tyenv (destByrefTy cenv.g v.Type)",32],["let cuspec,idx = GenUnionCaseSpec cenv.amap m cenv.g eenv.tyenv ucref tyargs",51],["match tyenv.tyconRefRemap.TryFind tcr with",57],["if isRemapEmpty tyenv then x else",76],["let ilActualRetTy = GenType cenv.amap m cenv.g eenv.tyenv actualRetTy",41],["let ilToTy = GenType cenv.amap m cenv.g eenv.tyenv tgty",32]],"useCount":3988},{"word":"typ","context":[["let typ, sigptr = sigptrGetTy ctxt numtypars bytes sigptr",108],["if isAppTy g typ then",112],["match metadataOfTy g typ with",115],["match stripTyparEqns typ with",142],["| FSMeth(g,typ,vref,_) ->",152],["match typ with",337],["typ",104],["let tcref = tcrefOfAppTy g typ",103],["let tcref,tinst = destAppTy g typ",76],["let inst = GetInstantiationForMemberVal g x.IsCSharpStyleExtensionMember (typ,vref,minst)",68]],"useCount":15295},{"word":"typars","context":[["//    internal-typars = free-typars - contract-typars",32],["// QUERY: should these be false for non-equal rigid typars? warn-if-not-rigid typars?",28],["typars)",40],["//    internal-typars = free-typars - contract-typars",32],["//    {LAM <tyfunc-typars>. expr }[free-typars] : overall-type[contract-typars]",32],["//    {LAM <tyfunc-typars>. expr }[free-typars] : overall-type[contract-typars]",32],["//    {LAM <tyfunc-typars>. expr }[free-typars] : overall-type[contract-typars]",32],["// QUERY: should these be false for non-equal rigid typars? warn-if-not-rigid typars?",28],["let numtypars = typars.Length",22],["//    internal-typars = free-typars - contract-typars",32]],"useCount":2582},{"word":"type","context":[["// COM, set the ComVisible attribute to true on that type.",997],["type C() =",173],["type",160],["type Class() =",175],["(* Member of type 'CodeTypeConstructor' is not supported by the CodeDOM provider and was omitted *)",189],["// REVIEW: consider if we need to show _cxs (the type parameter constrants)",204],["abstract addEventListener: ``type``: string * listener: EventListenerOrEventListenerObject * ?useCapture: bool -> unit",208],["/// Add definition location information to the provided type definition.",146],["// to COM components.  If you need to access a type in this assembly from",997],["/// static conversion method on the input type.</summary>",288]],"useCount":87474},{"word":"typeEquiv","context":[["elif typeEquiv g ty g.int32_ty then mkInt32Val g (Unchecked.int32 a)",36],["when valRefEq cenv.g vf cenv.g.range_op_vref && typeEquiv cenv.g tyarg cenv.g.int_ty ->",20],["typeEquiv cenv.g typ cenv.g.system_Delegate_typ then",20],["if typeEquiv g tgtTy srcTy then",21],["if typeEquiv cenv.g tgtTy srcTy then",22],["elif typeEquiv g ty g.uint32_ty then mkUInt32Val g (Unchecked.uint32 a)",36],["if not (typeEquiv g t1 t2) then (",36],["List.lengthsEqAndForall2 (typeEquiv g) l1 l2",42],["if not (typeEquiv csenv.g calledArgTy callerArgTy) then ErrorD(Error(FSComp.SR.csArgumentTypesDoNotMatch(),m)) else",25],["let isString = typeEquiv cenv.g cenv.g.string_ty e1ty",20]],"useCount":2272},{"word":"typeof","context":[["| true, false when expr.Type = typeof<unit> ->",64],["member __.Constructor =  typeof<ParamArrayAttribute>.GetConstructors().[0]",62],["member __.Constructor =  typeof<TypeProviderEditorHideMethodsAttribute>.GetConstructors().[0]",63],["member __.ConstructorArguments = upcast [| CustomAttributeTypedArgument(typeof<string>, lazyText.Force())  |]",63],["let aty = typeof<'T>",274],["assert_equal typeof<bool> (snd result)",220],["if t1 = typeof<decimal> then",102],["[<ExpectedException(typeof<ArgumentException>)>]",88],["member __.Constructor =  typeof<TypeProviderXmlDocAttribute>.GetConstructors().[0]",63],["member __.Constructor =  typeof<TypeProviderDefinitionLocationAttribute>.GetConstructors().[0]",63]],"useCount":6406},{"word":"types","context":[["let types =",83],["// Setting ComVisible to false makes the types in this assembly not visible",997],["// Allow 'fake' nested types that are actually real .NET types",67],["// Allow 'fake' nested types that are actually real .NET types",67],["/// Note that the type provider specification does not require us to implement pointer-equality for provided types.",68],["let rec loop types =",68],["| _ -> invalidArg \"yobj\" \"cannot compare values of different types\"",71],["types",121],["/// .NET symbolic types made from this type, e.g. when building Nullable<SomeProvidedType[]>.FullName",65],["[<Test ; Category(\"Custom types\")>]",64]],"useCount":14061},{"word":"tys","context":[["let tys = [| for e in items -> e.Type |]",60],["(accFreeVarsInTys opts tys",57],["let n = List.length tys",40],["| _ -> mkTupleTy tys",34],["match tys with",199],["let tupleTy = Reflection.FSharpType.MakeTupleType tys",61],["let _,tys,_ = PrettyTypes.PrettifyTypesN amap.g (apparentTy :: minfo.FormalMethodInst)",24],["let apparentTyR,minst = List.headAndTail tys",24],["| TyparConstraint.SimpleChoice (tys,_) ->",29],["| TyparConstraint.SimpleChoice(tys,_) ->",29]],"useCount":3497},{"word":"u","context":[["match u with",65],["let u,sigptr = sigptrGetInt32 bytes sigptr",44],["// pure (.) <*> u <*> v <*> w = u <*> (v <*> w)",44],["let u,sigptr = sigptr_get_i64 bytes sigptr",46],["int16 u,sigptr",45],["uint32 u,sigptr",45],["let u,sigptr = sigptr_get_i32 bytes sigptr",46],["w.Apply(v.Apply(u.Apply(pointed))) = w.Apply(v).Apply(u)",44],["// pure (.) <*> u <*> v <*> w = u <*> (v <*> w)",44],["w.Apply(v.Apply(u.Apply(pointed))) = w.Apply(v).Apply(u)",44]],"useCount":1924},{"word":"ucref","context":[["let mkR = ConvUnionCaseRef cenv ucref",34],["let cuspec,idx = GenUnionCaseSpec cenv.amap m cenv.g eenv.tyenv ucref tyargs",51],["acc.Add (ucref.CaseName, item))",30],["let ucref = tcref.MakeNestedUnionCaseRef ucase",26],["let avoidHelpers = entityRefInThisAssembly cenv.g.compilingFslib ucref.TyconRef",25],["| Test.UnionCase (ucref, tyargs) ->",22],["let typR = ConvType cenv (mkAppTy ucref.TyconRef tyargs)",32],["let item = Item.UnionCase(GeneralizeUnionCaseRef ucref,false)",36],["let ucinfo = FreshenUnionCaseRef ncenv m ucref",34],["| TOp.UnionCase ucref,_,_ ->",22]],"useCount":2031},{"word":"uint16","context":[["| UInt16 of uint16",73],["/// is detected, to allow more efficient processing of large arrays of uint16 constants.",40],["| :? uint16 as x -> ilg.Emit(OpCodes.Ldc_I4, int32 (int16 x))",64],["let trans : uint16[] array =",58],["elif t1 = typeof<uint16> then",50],["| UInt16 of uint16",36],["when 'T : uint16  = (# \"ceq\" x y : bool #)",33],["[| UShort (uint16 flags)",48],["[| UShort (uint16 flags);",42],["| UInt16s of uint16[]",40]],"useCount":3708},{"word":"uint32","context":[["| UInt32 of uint32",73],["when 'T : uint32  = (# \"ceq\" x y : bool #)",33],["| UInt32 of uint32",36],["elif typeEquiv g ty g.uint32_ty then mkUInt32Val g (Unchecked.uint32 a)",36],["prgCmds.[0].cmdf <- (uint32 OLECMDF.OLECMDF_SUPPORTED) ||| (uint32 OLECMDF.OLECMDF_ENABLED)",39],["prgCmds.[0].cmdf <- (uint32 OLECMDF.OLECMDF_SUPPORTED) ||| (uint32 OLECMDF.OLECMDF_ENABLED)",39],["uint32 u,sigptr",45],["val Timestamp:uint32",51],["val Type:uint32",51],["| :? uint32 as x -> ilg.Emit(OpCodes.Ldc_I4, int32 x)",64]],"useCount":1942},{"word":"unbox","context":[["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'opt_attributes)) in",56],["let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : 'recover)) in",57],["|> unbox",55],["let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : int)) in",47],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : int)) in",46],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : SynExpr)) in",63],["let genAndName = unbox x",112],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : Ast.SynExpr)) in",43],["let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",195],["let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in",115]],"useCount":2809},{"word":"uniform","context":[["uniform sampler2D tex;",103],["uniform float time;",141],["uniform vec4 targetSize;",52],["uniform sampler2D tex0;",54],["uniform vec4 sourceSize[];",71],["uniform sampler2D diffuse;",73],["uniform vec2 resolution;",75],["uniform sampler2D texture;",82],["uniform sampler2D sampler;",86],["uniform sampler2D source[];",92]],"useCount":2828},{"word":"union","context":[["/// Gets any implicit hash/equals methods added to an F# record, union or struct type definition.",34],["// disc union",42],["/// Get the union cases for a type, if any, as a list",34],["/// records, lists and union types.</summary>",36],["// rec disc union",42],["match union with",51],["/// Gets any implicit CompareTo methods added to an F# record, union or struct type definition.",34],["/// Get the union cases for a type, if any",34],["let f union =",56],["else Zset.union s1 s2",95]],"useCount":2687},{"word":"unit","context":[["abstract addEventListener: ``type``: string * listener: EventListenerOrEventListenerObject * ?useCapture: bool -> unit",208],["member AddXmlDocDelayed   : xmlDocFunction: (unit -> string) -> unit",275],["member AddXmlDocDelayed   : xmlDocFunction: (unit -> string) -> unit",275],["member AddDefinitionLocation : line:int * column:int * filePath:string -> unit",249],["member AddXmlDocComputed   : xmlDocFunction: (unit -> string) -> unit",242],["member AddXmlDocComputed   : xmlDocFunction: (unit -> string) -> unit",242],["member AddXmlDoc            : xmlDoc: string -> unit",203],["member AddObsoleteAttribute : message: string * ?isError: bool -> unit",190],["(fun (env : unit -> PrintfEnv<'State, 'Residue, 'Result>) ->",110],["when 'S : (new : unit ->  'S) and 'S :> IMatrixOps<'T>",98]],"useCount":16396},{"word":"up","context":[["// Instance IL event (fake up event-as-value)",60],["| :? ProvidedProperty    as p -> p.DeclaringTypeImpl <- this // patch up \"declaring type\" on provided MethodInfo",63],["| :? ProvidedConstructor as c -> c.DeclaringTypeImpl <- this // patch up \"declaring type\" on provided MethodInfo",63],["| :? ProvidedMethod      as m -> m.DeclaringTypeImpl <- this // patch up \"declaring type\" on provided MethodInfo",63],["// Open up the compiler as an incremental service for parsing,",72],["// Return the disposable object that cleans up",76],["// Delay construction - to pick up the latest isStatic",125],["| :? ProvidedEvent       as e -> e.DeclaringTypeImpl <- this // patch up \"declaring type\" on provided MethodInfo",60],["//printfn \"looking up assembly '%s'\" assembly.FullName",59],["// In principle the JIT should be able to do good liveness analysis to clean things up, but the",48]],"useCount":4399},{"word":"upcast","context":[["actual.[\"data\"] |> equals (upcast expected)",72],["\"kind\", upcast \"NON_NULL\"",96],["\"kind\", upcast \"SCALAR\"",87],["member __.NamedArguments = upcast [| |] }",272],["member __.ConstructorArguments = upcast [| |]",190],["\"args\", upcast []",99],["\"isDeprecated\", upcast false",120],["\"ofType\", upcast NameValueLookup.ofList [",126],["upcast NameValueLookup.ofList [",177],["\"type\", upcast NameValueLookup.ofList [",129]],"useCount":2383},{"word":"url","context":[["DownloadError url |> fail",48],["use client = createWebClient (url,auth)",39],["use client = createWebClient(url,auth)",55],["| Some url ->",81],["url",38],["let! raw = getFromUrl(auth,url,acceptXml)",48],["let url =",41],["let! result = followODataLink auth url",40],["tracefn \"Response from %s:\" url",84],["url testpage",152]],"useCount":2892},{"word":"use","context":[["use l = Logging.LogScope()",880],["use ts = new TransactionScope()",440],["use e = source.GetEnumerator()",308],["use unwindBuildPhase = PushThreadBuildPhaseUntilUnwind (BuildPhase.Parameter)",289],["use con = MsSqlCe.createConnection()",136],["[<CompilerMessage(\"This method is not intended for use from F#.\", 10001, IsHidden=true, IsError=false)>]",132],["use con = SQLite.createConnection()",130],["use _holder = TemporarilySuspendReportingTypecheckResultsToSink cenv.tcSink",126],["// FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs",105],["use ie = source.GetEnumerator()",102]],"useCount":16152},{"word":"used","context":[["/// Set the function used to compute the implementation of sets of this property.",68],["/// Set the quotation used to compute the implementation of gets of this property.",68],["/// FSharp.Data addition: this method is used by Debug.fs",73],["// MUTABILITY; used only during creation and remapping of tycons",76],["/// Only used in FSharp.Core",84],["/// A flag read eagerly from the provided type and used to compute basic properties of the type definition.",85],["// This type is used to give symbolic names to token indexes, useful for error messages",88],["// MUTABILITY: used when propagating signature attributes into the implementation.",93],["///  - `setParams` - Function used to manipulate the WiX default parameters.",113],["/// <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>",234]],"useCount":10974},{"word":"using","context":[["/// Indicates that this DLL was compiled using the F# compiler and has F# metadata",38],["/// <summary>Used to display stock information using high, low, open and close values.</summary>",42],["// by using the '*' as shown below:",1021],["// By using this source code in any fashion, you are agreeing to be bound",490],["// By using this source code in any fashion, you are agreeing to be bound",203],["/// are analyzed using reflection. The type is representationally equivalent to",76],["using x.ResourceLock (fun _ ->",73],["/// can be created using methods on the System.Array type.</summary>",64],["/// <remarks>Performs the operation in parallel using System.Threading.Parallel.For.",56],["/// Elements within each partition/bin are sorted using the 'comparer'.",48]],"useCount":6076},{"word":"v","context":[["| Some v ->",401],["| Some v -> v",311],["| Some v -> v",311],["match v.MemberInfo with",254],["let v =",231],["this.x <- v.x",192],["match v.ValReprInfo with",188],["and set v =",182],["match v with",735],["v",440]],"useCount":57075},{"word":"v1","context":[["| V1_1 -> \"v1.1\"",34],["let t2' = eval1 ctx t2 in TmApp (fi, v1, t2')",40],["| Some (v1,v2) -> yield v1; yield v2",40],["| Some (v1,v2) -> yield v1; yield v2",40],["| TmApp (fi, v1, t2) when isval ctx v1 ->",50],["| TmApp (fi, v1, t2) when isval ctx v1 ->",50],["and set v = v1 <- v",50],["with get() = v1",52],["(* let v = v1 in bexpr => bexpr[v/v1] *)",59],["(* let v = v1 in bexpr => bexpr[v/v1] *)",59]],"useCount":2748},{"word":"v2","context":[["remote: http://www.nuget.org/api/v2",152],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://www.nuget.org/api/v2",147],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://nuget.org/api/v2",139],["source https://www.nuget.org/api/v2",137],["source \"http://nuget.org/api/v2\"",134],["remote: http://nuget.org/api/v2",132],["remote: https://www.nuget.org/api/v2",111],["source http://nuget.org/api/v2",107],["source \"http://www.nuget.org/api/v2\"",165],["source http://www.nuget.org/api/v2",168]],"useCount":5589},{"word":"val","context":[["val prodIdxToNonTerminal: int -> nonTerminalId",53],["val Timestamp:uint32",51],["val Type:uint32",51],["val tagOfToken: token -> int",53],["val token_to_string: token -> string",53],["val tokenTagToTokenId: int -> tokenId",53],["[<Parameter>] member val Force = SwitchParameter() with get, set",54],["/// static fields, 'val' declarations and hidden fields from the compilation of implicit class constructions.",102],["val mutable public sType : VkStructureType",150],["val mutable public pNext : nativeint",150]],"useCount":22570},{"word":"value","context":[["| Some value ->",172],["/// <param name=\"e1\">The first value.</param>",165],["/// <param name=\"value\"></param>",160],["/// <param name=\"e2\">The second value.</param>",165],["// value keys",220],["value",331],["match value with",581],["/// <param name=\"value\">The input value.</param>",584],["/// <param name=\"value\">The input value.</param>",584],["let value =",201]],"useCount":29595},{"word":"values","context":[["/// [category:Missing values]",93],["// set of attributes. Change these attribute values to modify the information",1064],["//could theoretically go wrong, if all the values do happen to be zero.",57],["(fun values ->",60],["| _ -> invalidArg \"yobj\" \"cannot compare values of different types\"",71],["let values =",74],["/// of measure is erased in compiled code and when values of this type",76],["values",136],["// You can specify all the values or you can default the Build and Revision Numbers",1037],["// Version information for an assembly consists of the following four values:",1046]],"useCount":11494},{"word":"variable","context":[["// the type of the current expression with a type variable that indicates an error",38],["/// this allows the use of mapping functions requiring a (possibly mutable) state variable.",40],["// FSharp.Data change: use the real variable names instead of indices, to improve output of Debug.fs",105],["variable ffl.endian   1 ffl.endian !",54],["// Add the variables to the query variable space, on demand",54],["moduleValue (variable \"'a\"),",45],["// OK, we're done, Record the results for the type variable which provide the support",40],["// to C<_> occurs then generate C<?ty> for a fresh type inference variable ?ty.",40],["// baseValOpt is the 'base' variable associated with the inherited portion of a class",40],["// Inside the incremental class sytntax we assert the type of the 'this' variable to be precisely the same type as the",38]],"useCount":4085},{"word":"variables","context":[["// In other words, the free type variables get divided into two sets",32],["/// State variables always get zero-initialized",32],["/// Instantiate type variables that occur within types and other items.",34],["// non-local values do not contain free variables",38],["// this variable for the implicit class constructor. For static members, we assert the type variables associated",38],["// So collect up free vars in all constraints first, then bind all variables",38],["/// systematically with lower-case type inference variables such as <c>'a</c>.",42],["// Add the variables to the query variable space, on demand",54],["// the binding must have leaves that are themselves variables (due to the limited support for byrefs in expressions)",54],["/// variables unnecessarily",62]],"useCount":3624},{"word":"ve","context":[["match ve with",104],["match GetVectorWidthByExpr(bt,ve) with",80],["// Now that we know what we've generalized we can adjust the recursive references",40],["mkCompGenLet m v e (f (v,ve))",39],["let v,ve = mkCompGenLocal m nm ty",39],["let v,ve = mkCompGenLocal appm nm argExprTy",38],["// we've already reported error now we can use operands of binary operation as join components",36],["match ve,resultSet with",34],["// Remove all duplicates. We've put the types first, so this removes the DelegateCtor and DefaultStructCtor's.",27],["// FSharp.Compiler support setting an appkey for compiler location. I've never seen this used.",24]],"useCount":1960},{"word":"vec3","context":[["vec3 position;",74],["vec3 color;",92],["varying vec3 worldPos0;",40],["vec3 normal;",42],["varying vec3 normal0;",43],["vec3 specular;",48],["vec3 ambient;",49],["vec3 Direction;",51],["vec3 diffuse;",52],["vec3 direction;",83]],"useCount":2999},{"word":"vec4","context":[["out vec4 Fragment;",52],["out vec4 fragColor;",244],["gl_FragColor = vec4(color, 1.0);",48],["uniform vec4 targetSize;",52],["vec4 color;",58],["out vec4 outColor;",64],["uniform vec4 sourceSize[];",71],["out vec4 FragmentColor;",98],["out vec4 FragColor;",101],["out vec4 color;",236]],"useCount":3306},{"word":"vector","context":[["// null vector",32],["checkInitialized \"vector\" vector",110],["checkInitialized \"vector\" vector",110],["/// <param name=\"vec\">The input vector.</param>",102],["| _ -> raise <| Error.errExpectedX \"list or vector\"",50],["// For vector length zero, just propagate the prior timestamp.",34],["// string vector",32],["|> vector.UnsafeCreate",32],["// empty vector",30],["/// Jacobian of a vector-to-vector function `f`, at point `x`",28]],"useCount":2063},{"word":"version","context":[["let version =",135],["/// Adds the given package with the given version to the dependencies file.",84],["#version 430 core",93],["#version 130",115],["version",205],["#version 120",233],["// The assembly version has the format {Major}.{Minor}.{Build}.{Revision}",300],["#version 150",300],["#version 330 core",300],["#version 330",462]],"useCount":9916},{"word":"view","context":[["let view = helper.GetView(buffer)",194],["let tagger = helper.GetTagger(buffer, view)",194],["let docEventListener = new DocumentEventListener ([ViewChange.layoutEvent view; ViewChange.caretEvent view],",35],["let docEventListener = new DocumentEventListener ([ViewChange.layoutEvent view; ViewChange.caretEvent view],",35],["match buffer.GetSnapshotPoint view.Caret.Position, currentWord with",45],["let buffer = view.TextBuffer",54],["view: ITextView,",54],["view",59],["let array = view.Array",64],["let! point = buffer.GetSnapshotPoint view.Caret.Position",71]],"useCount":1896},{"word":"void","context":[["void main()",1391],["void main() {",717],["void main(void)",494],["void main(void)",494],["void main(void) {",229],["void main(void) {",229],["void main(){",110],["void main(void){",85],["void main(void){",85],["// if we need result and method produce void and result should be unit - push null as unit value on stack",64]],"useCount":4611},{"word":"vref","context":[["match vref.ActualParent with",107],["let inst = GetInstantiationForMemberVal g x.IsCSharpStyleExtensionMember (typ,vref,minst)",68],["| Item.Value vref ->",73],["match vref.MemberInfo with",236],["| FSMeth(g,typ,vref,_) ->",152],["let v = vref.Deref",129],["match vref.ValReprInfo with",119],["| FSProp(_,_,Some vref,_)",116],["let vref =",112],["match vref with",110]],"useCount":13657},{"word":"vs","context":[["match vs, cs with",57],["let vs = ListMeasureVarOccsWithNonZeroExponents unt",38],["let env = BindInternalValsToUnknown cenv vs env",36],["let tupledv, untupler =  untupledToTupled vs",34],["let vs = ListMeasureVarOccsWithNonZeroExponents ms",33],["let _,_,tmenvinner = copyAndRemapAndBindTyconsAndVals g compgen tmenv tycons vs",38],["let vs = allValsOfModuleOrNamespaceTy mty",38],["vs,body",38],["testFunction f.Invoke vs",44],["match vs with",107]],"useCount":4969},{"word":"vspec","context":[["match vspec.MemberInfo with",40],["let tps,vsl,body,returnTy = stripTopLambda (expr,vspec.Type)",60],["let item = Item.Value(mkLocalValRef vspec)",30],["let m = vspec.Range",30],["match StorageForVal m vspec eenv with",30],["success(resInfo,Item.Value (mkNestedValRef modref vspec),rest)",34],["Binding = TBind(vspec,expr,spBind) }",40],["vspec.Attribs",28],["let vspec = vref.Deref",24],["let idvs,_ = TcAndPublishValSpec (cenv,env,containerInfo,ModuleOrMemberBinding,None,emptyUnscopedTyparEnv,vspec)",20]],"useCount":2886},{"word":"w","context":[["this.w <- v.x",120],["this.w <- v.w",48],["fun (w : int) v ->",50],["tos push.w:g",60],["/// This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.",64],["override w.ToString() =",65],["tos pop.w:g",69],["match w with",74],["this.w <- v.z",96],["this.w <- v.y",136]],"useCount":3406},{"word":"walkExpr","context":[["yield! walkExpr true e",77],["List.tryPick walkExpr [synExpr1; synExpr2; synExpr3]",57],["yield! walkExpr false e2",60],["walkExpr synExpr",286],["List.tryPick walkExpr [synExpr1; synExpr2]",193],["walkExpr e",148],["yield! walkExpr false e1",137],["walkExpr e1 || walkExpr e2",95],["walkExpr e1 || walkExpr e2",95],["yield! walkExpr true e2",79]],"useCount":2344},{"word":"warning","context":[["warning(InternalError(msg,m));",52],["// to prevent unused parameter warning",36],["(warning (LetRecCheckedAtRuntime m); reportedEager := true)",36],["// expect no warning, and attribute to be in compiled code",36],["/// Use to reset error and warning handlers",34],["| _ -> dprintn (\"warning: duplicate decode entries for \"+string i);",30],["// Don't push a new context if next token is EOF, since that raises an offside warning",28],["warning(e)",21],["/// Decompose a warning or error into parts: position, severity, message",22],["// Note we are not calling errorLogger.GetErrors() anywhere for this task. This warning will not be reported...",24]],"useCount":2903},{"word":"was","context":[["/// Indicates that this DLL was compiled using the F# compiler and has F# metadata",38],["// This file was autogenerated by running the script in this directory",170],["(* Member of type 'CodeTypeConstructor' is not supported by the CodeDOM provider and was omitted *)",189],["// (i.e., the tree was modified).",106],["| None -> failwith \"ProvidedTypeDefinition: DefineStaticParameters was not called\"",79],["// If an error was encountered, return None.",52],["// If the error was set, return it.",52],["// If the type was excluded, say why",40],["//     This code was generated by a tool.",41],["traceError \"Command was:\"",47]],"useCount":3003},{"word":"we","context":[["// REVIEW: consider if we need to show _cxs (the type parameter constrants)",204],["// Adjust the attributes - we're codegen'ing as non-nested",64],["// if we need result and method produce void and result should be unit - push null as unit value on stack",64],["// method produced something, but we don't need it",64],["// Custom atttributes that we only compute once",64],["// XML doc text that we only compute once, if any. This must _not_ be forced until the ConstructorArguments",64],["// This ensures we always get the type instantiation right when doing this from",80],["// \"single named item\" rule. This is where we have a single accessible method",80],["// This is a value we can access from the outside to definitely force initialziation of the module",85],["// This is a value we will access from the outside.",85]],"useCount":20493},{"word":"when","context":[["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input array is null.</exception>",324],["/// <exception cref=\"System.ArgumentNullException\">Thrown when the input sequence is null.</exception>",518],["// This ensures we always get the type instantiation right when doing this from",80],["| id :: rest when id.idText = MangledGlobalName -> rest",80],["let field = match field with :? ProvidedField as pf when fieldMap.ContainsKey pf -> fieldMap.[pf] :> FieldInfo | m -> m",80],["/// `InvalidOperationException` when the series is not ordered.",82],["// MUTABILITY: used when propagating signature attributes into the implementation.",93],["when 'S : (new : unit ->  'S) and 'S :> IMatrixOps<'T>",98],["/// Close All Active Connection, to be called when the program gets shutdown.",103],["when",140]],"useCount":29044},{"word":"where","context":[["// optimized mutation-based implementation. This code is only valid in fslib, where mutation of private",114],["break  Insert a breakpoint indicating where the line maybe broken if",52],["if n < rem then loop (where  + n) (rem - n)",58],["/// <param name=\"lineText\">The text of the line where the information is being requested.</param>",59],["/// <param name=\"line\">The line number where the information is being requested.</param>",59],["let rec loop where rem =",59],["// Handle the case where this is a generic method instantiated at a type being compiled",51],["/// <param name=\"names\">The identifiers at the location where the information is being requested.</param>",59],["// \"single named item\" rule. This is where we have a single accessible method",80],["// nice: don't introduce awful temporary for r.h.s. in the 99% case where we know what we're binding it to",60]],"useCount":4811},{"word":"which","context":[["// of which there can be many. Simply turn them all into one big AND expression as that is the",46],["/// The order in which the given function is applied to elements of the input array is not specified.</remarks>",42],["/// - A private key blob which has been encrypted and contains information to initialize RSA",42],["// TODO: make this an Eventually (which can be scheduled) or an Async (which can be cancelled)",44],["// TODO: make this an Eventually (which can be scheduled) or an Async (which can be cancelled)",44],["// next up is the FROM statement which includes joins ..",46],["///  - `targets` - A string with the target names which should be run by MSBuild.",78],["///  - `configProcessStartInfoF` - A function which overwrites the default ProcessStartInfo.",82],["// These are some constant expressions which can be accessed from context",85],["\\ * which accompanies this distribution, and is available at",436]],"useCount":6707},{"word":"while","context":[["while e.MoveNext() do",257],["while reader.Read() do",101],["[ while reader.Read() do",95],["while i < lenx do",81],["while not fin do",66],["while xptr <> eX do",66],["while xptr <> eY do",64],["while true do",493],["while",460],["while xptr <> eZ do",60]],"useCount":4917},{"word":"wholeProjectResults","context":[["let allSymbols = allSymbolsInEntities true wholeProjectResults.AssemblySignature.Entities",64],["wholeProjectResults.Errors.Length |> shouldEqual 0",310],["let wholeProjectResults = checker.ParseAndCheckProject(Project1.options) |> Async.RunSynchronously",127],["wholeProjectResults.GetAllUsesOfAllSymbols()",261],["let wholeProjectResults = checker.ParseAndCheckProject(Project25.options) |> Async.RunSynchronously",44],["let wholeProjectResults = checker.ParseAndCheckProject(Project3.options) |> Async.RunSynchronously",44],["let wholeProjectResults = checker.ParseAndCheckProject(Project31.options) |> Async.RunSynchronously",50],["let wholeProjectResults = checker.ParseAndCheckProject(Project2.options) |> Async.RunSynchronously",55],["let wholeProjectResults = checker.ParseAndCheckProject(Project4.options) |> Async.RunSynchronously",55],["wholeProjectResults .Errors.Length |> shouldEqual 0",64]],"useCount":2498},{"word":"will","context":[["// This is a value we will access from the outside.",85],["/// remote execution behavior. If successfully imported, the function will be cached for faster reimporting.",84],["#nowarn \"67\" // this type test or downcast will always hold",59],["// We expect accessing the value 'x' will _not_ trigger initialization of this module",57],["assert (gdtym <> null) // ?? will never happen - if method is not found - KeyNotFoundException will be raised",56],["assert (gdtym <> null) // ?? will never happen - if method is not found - KeyNotFoundException will be raised",56],["obox   Open a \"box\" whose contents will be indented by two spaces if",54],["// add let bindings for arguments to ensure that arguments will be evaluated",53],["//   (its implementation of IsAssignableFrom raises NotSupportedException so it will be safer to always emit castclass)",51],["/// Exceptions: InvalidArgumentException will be raised if the input expression is",67]],"useCount":6511},{"word":"with","context":[["match result with",1648],["match l with",1355],["match t with",1845],["match x with",6707],["match expr with",2167],["match this with",2361],["match e with",2467],["with e ->",2621],["with",9067],["with get() =",3875]],"useCount":212911},{"word":"wordL","context":[["|> wordL",53],["let nmL = wordL (DemangleOperatorName ucase.Id.idText)",31],["let lhs = wordL fld.Name",32],["let stat = if memFlags.IsInstance || (memFlags.MemberKind = MemberKind.Constructor) then emptyL else wordL \"static\"",33],["elif memFlags.IsOverrideOrExplicitImpl then stat ++ wordL \"override\"",33],["let stat = if memFlags.IsDispatchSlot then stat ++ wordL \"abstract\"",33],["let lhs = if fld.IsMutable then wordL \"mutable\" --- lhs else lhs",34],["(lhsL ^^ wordL \"=\") @@-- rhsL",45],["wordL str",45],["| None -> wordL \"<no global g>\"",57]],"useCount":6544},{"word":"writer","context":[["writer.WriteEndElement()",67],["writer.WriteLine ()",82],["let writer =",36],["writer.Indent ctx.Indentation",56],["writer.Unindent ctx.Indentation",55],["IndentedTextWriter.indented writer <| fun writer ->",54],["IndentedTextWriter.indented writer <| fun writer ->",54],["writer",44],["writer.Close()",41],["writer.Flush()",80]],"useCount":2180},{"word":"www","context":[["/*  http://www.visualizationlibrary.org                                               */",56],["let expected = \"\"\"source https://www.nuget.org/api/v2",59],["let config = \"\"\"source https://www.nuget.org/api/v2",71],["source \"http://www.nuget.org/api/v2\" // first source",97],["remote: https://www.nuget.org/api/v2",111],["source https://www.nuget.org/api/v2",137],["let dependenciesFile = DependenciesFile.FromCode(\"\"\"source http://www.nuget.org/api/v2",147],["remote: http://www.nuget.org/api/v2",152],["source \"http://www.nuget.org/api/v2\"",165],["source http://www.nuget.org/api/v2",168]],"useCount":2103},{"word":"x","context":[["match x with",6707],["override x.ToString() =",1024],["x",793],["| Some x -> x",759],["| Some x -> x",759],["member x.Dispose() =",647],["| x -> x",438],["| x -> x",438],["| x::xs ->",293],["match x.Handle with",273]],"useCount":176354},{"word":"x1","context":[[": r'@              ( R: x1 x2 -- x1 x2; -- x1 = Fetch the second cell on the return stack )",34],[": r'@              ( R: x1 x2 -- x1 x2; -- x1 = Fetch the second cell on the return stack )",34],["match x1,x2 with",49],["GenericEqualityWithComparerFast comparer x1 y1 &&",36],["let  n = GenericComparisonWithComparerFast comparer x1 y1",36],["let r1 = x1.Value",48],[": r'@              ( R: x1 x2 -- x1 x2; -- x1 = Fetch the second cell on the return stack )",34],["vec3 x1 = x0 - i1 + C.xxx;",30],["(\"val x1\", \"x1\", \"file1\", ((4, 4), (4, 6)), [\"defn\"], [\"val\"]);",22],["(\"val x1\", \"x1\", \"file1\", ((4, 4), (4, 6)), [\"defn\"], [\"val\"]);",22]],"useCount":2571},{"word":"x2","context":[["GenericEqualityWithComparerFast comparer x2 y2 &&",27],[": r'@              ( R: x1 x2 -- x1 x2; -- x1 = Fetch the second cell on the return stack )",34],["let r2 = x2.Value",48],[": r'@              ( R: x1 x2 -- x1 x2; -- x1 = Fetch the second cell on the return stack )",34],["match x2.PublicPath with",38],["let  n = GenericComparisonWithComparerFast comparer x2 y2",27],["(\"val x2\", \"x2\", \"file1\", ((5, 4), (5, 6)), [\"defn\"], [\"val\"]);",22],["(\"val x2\", \"x2\", \"file1\", ((5, 4), (5, 6)), [\"defn\"], [\"val\"]);",22],["match x1, x2 with",21],["match x1,x2 with",49]],"useCount":2335},{"word":"xml","context":[["/// This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.",64],["let newWeavers = Path.Combine(scenarioTempPath scenario,\"MyClassLibrary\",\"MyClassLibrary\",\"FodyWeavers.xml\")",42],["let expectedPropertyNodes = \"\"\"<?xml version=\"1.0\" encoding=\"utf-16\"?>",43],["DataTipElement(text, xml)",44],["/// It is important that the text of the xml doc only get forced when poking on the ConstructorArguments",64],["/// This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.",64],["s1.Contains \"FodyWeavers.xml\" |> shouldEqual true",101],["FSharpToolTipElement.Single(text, xml)",115],["type AtomSearch = XmlProvider<\"../../FSharp.Data.Tests/Data/search.atom.xml\", SampleIsList=true>",120],["type philosophyType = XmlProvider<\"../../FSharp.Data.Tests/Data/Philosophy.xml\">",120]],"useCount":1993},{"word":"xmlDoc","context":[["member this.AddXmlDocDelayed xmlDoc                     = customAttributesImpl.AddXmlDocDelayed xmlDoc",304],["member AddXmlDoc            : xmlDoc: string -> unit",203],["member this.AddXmlDocComputed xmlDoc                    = customAttributesImpl.AddXmlDocComputed xmlDoc",304],["member this.AddXmlDocDelayed xmlDoc                     = customAttributesImpl.AddXmlDocDelayed xmlDoc",304],["member this.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",304],["member __.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",126],["member __.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",126],["member __.AddXmlDocComputed(xmlDoc : unit -> string) = xmlDocAlwaysRecomputed <- Some xmlDoc",45],["member this.AddXmlDocComputed xmlDoc                    = customAttributesImpl.AddXmlDocComputed xmlDoc",304],["member this.AddXmlDoc xmlDoc                            = customAttributesImpl.AddXmlDoc xmlDoc",304]],"useCount":3027},{"word":"xs","context":[["xs",307],["match xs with",553],["</xs:complexType>",58],["| x :: xs ->",75],["let xs = [|1.; 2.; 3.; 4.|]",78],["aux xs",94],["Spec.ForAny<int[]>(fun xs ->",116],["let xs = [1.; 2.; 3.; 4.]",133],["let f(xs : int[]) =",146],["| x::xs ->",293]],"useCount":7257},{"word":"y","context":[["this.x <- v.y",160],["let y = getMatrixFromMatlab(app, \"b\")",168],["this.z <- v.y",168],["this.y <- v.y",176],["this.y <- v.x",176],["this.y <- v.y",176],["match y with",258],["/// <param name=\"y\">The second parameter.</param>",150],["this.w <- v.y",136],["x = y).QuickCheckThrowOnFailure()",134]],"useCount":17781},{"word":"yield","context":[["| [] -> yield tipf v",79],["yield! walkExpr true e2",79],["yield (x :> FSharpSymbol)",78],["yield! walkExpr true e",77],["yield!",83],["yield {",90],["yield Quotations.Var(p.Name, p.ParameterType) |]",107],["let refMap = Map.ofSeq [for c in [\".\"; \"..\"; \"...\"; \"....\"] do yield (c, c.Length) ]",126],["yield! walkExpr false e1",137],["yield",268]],"useCount":17134},{"word":"you","context":[["// a written agreement between you and David Sorokin, Yoshkar-Ola, Russia.",62],["// to COM components.  If you need to access a type in this assembly from",997],["// a written agreement between you and David Sorokin, Yoshkar-Ola, Russia.",57],["// By using this source code in any fashion, you are agreeing to be bound",203],["// By using this source code in any fashion, you are agreeing to be bound",490],["// You can specify all the values or you can default the Build and Revision Numbers",1037],["//  By using this source code in any fashion, you are agreeing",36],["/// Note that using this function in a job workflow is not optimal and you",36],["By using this source code in any fashion, you are agreeing to be bound",31],["//  - if you have a #line directive, e.g.",40]],"useCount":4571},{"word":"z","context":[["this.z <- v.x",168],["z",310],["this.z <- v.y",168],["this.y <- v.z",112],["this.x <- v.z",112],["this.z <- v.z",112],["this.z <- v.z",112],["Some z",98],["this.w <- v.z",96],["let z = getMatrixFromMatlab(app, \"c\")",83]],"useCount":7963},{"word":"~","context":[["nuget Rx-Main ~> 2.0",110],["nuget \"FAKE\" \"~> 3.0\"",83],["nuget Newtonsoft.Json ~> 6.0",33],["nuget Castle.Core-log4net ~> 3.2",75],["nuget \"Castle.Windsor-log4net\" \"~> 3.2\"",65],["nuget \"Rx-Main\" \"~> 2.2\"",51],["nuget FAKE ~> 3.0",48],["nuget Castle.Windsor !~> 3.3",33],["nuget FakeItEasy ~> 1.23",33],["nuget Castle.Windsor-log4net ~> 3.2",132]],"useCount":2150},{"word":"﻿","context":[["﻿#if INTERACTIVE",291],["﻿(*",1226],["﻿[<AutoOpen>]",643],["﻿",456],["﻿// ----------------------------------------------------------------------------",260],["﻿//----------------------------------------------------------------------------",252],["﻿// --------------------------------------------------------------------------------------",194],["﻿// Learn more about F# at http://fsharp.net",172],["﻿//",161],["﻿//-----------------------------------------------------------------------",105]],"useCount":5280},{"word":"﻿namespace","context":[["﻿namespace Nessos.FsPickler",58],["﻿namespace FSharpVSPowerTools.ProjectSystem",58],["﻿namespace MonoDevelop.FSharp",64],["﻿namespace Aardvark.Rendering.Vulkan",70],["﻿namespace FSharpVSPowerTools.Tests",76],["﻿namespace MBrace.Thespian.Runtime",81],["﻿namespace MBrace.Runtime",86],["﻿namespace FSharpVSPowerTools",104],["﻿namespace Paket",158],["﻿namespace System",1402]],"useCount":5897}]